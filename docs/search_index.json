[["index.html", "Learning Statistics with CogStat A tutorial for psychology students and other beginners About this book Licensing", " Learning Statistics with CogStat A tutorial for psychology students and other beginners Danielle Navarro1 Róbert Fodor2 5 Nov 2022 About this book First published on 27 September 2022 (electronic). Aligns with Cogstat v2.3. Second edition published on 23 September 2023 (electronic). Aligns with Cogstat v2.4. To reference this book, please use the following citation (APA7 format): Navarro, D., &amp; Fodor, R. (2023). Learning Statistics with CogStat (2nd ed.). https://learningstatisticswithcogstat.com Licensing This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. Danielle Navarro – Github | 0000-0001-7648-6578↩︎ Róbert Fodor – Github | 0000-0001-8470-335X↩︎ "],["foreword.html", "Foreword Foreword for the First Edition Foreword for the Second Edition", " Foreword Foreword for the First Edition This book is intended for psychology students and other beginners who are interested in learning statistics and want to use CogStat to perform their analyses. CogStat is a statistics software written in Python by Attila Krajcsi3 and developed with the help of supporters. Its distinct advantage is automatic hypothesis test selection and chart creation with an APA-style output to suit the needs of psychology researchers and students. Learning Statistics with CogStat is a book which covers the contents of an introductory statistics class. It is an adaptation made by Róbert Fodor based on Danielle Navarro’s original, Learning Statistics with R, version 0.64. While the theory laid out in the original book is still valid, this book focuses on the practical application of statistical methods in CogStat. The book is not intended to be a comprehensive guide to either CogStat or statistical theory, though. One of the key challenges of the adaptation was to balance between a fully applied approach (like how CogStat handles analysis) and a theoretical one (like the fantastic textbook it is based on). Danielle’s original content, while making up a massive chunk of the material, has been revised, reorganised, redacted, expanded on and rewritten to fit the new purpose. This book will always be a living thing. As CogStat expands and evolves, so will this book. If you have any suggestions, comments or questions, please feel free to reach out to me on GitHub. — Robert Foreword for the Second Edition This edition brings in plenty of changes, well beyond 10% of the book, which should warrant, per publishing standards, for it to be called “second edition”. The main drive behind these edits was reflections on the material’s usefulness and accuracy, since some explanations and wordings needed to be more robust to withstand scientific scrutiny, which Attila Krajcsi provided. I must thank him for his helpful notes as consulting editor for this version, not due to sheer obligation but on account of genuine appreciation. His feedback was essential, and while I spent quite some time defending most of my earlier decisions (some of which I still do), I had to accept that I simply couldn’t have got it quite right the first time, and I shouldn’t be too attached to the source material. I loved that the original was accessible and the opposite of stuffy, but I decided to cut down plenty (mostly the chattiness) and replace it with, hopefully still accessible but scientifically more accurate parts. I consulted some other textbooks comparing the way they present the material for it not to be stuffy. I firmly believe scientific communication in all its forms needs to be in everyday language while using precise terminology, appropriate analogies, and accurate examples. I hope that this edition is something you, dear reader, will love to read. I hope this edition is a step in the right direction. — Robert Changelog: Chapters 3 and 4 were amended and slightly expanded, and now they follow Chapter 2, so that the reader can better appreciate automatic statistical analysis. Chapter 2 was largely rewritten – particularly reliability and validity – to make definitions more accurate, and examples are now related to health and psychology research. The rest of the chapter discussing bias and study design were scrapped due to their lack of relevance to the book’s purpose. Chapter 5 was largely revised to tie to other statistics textbooks, also focusing on differentiating between population and sample measures. New: callout boxes added throughout some chapters to explain chart types and other concepts. New: definitions and examples are now presented markedly in the text. New: explanatory charts were added to the text. Typos and minor errors were fixed all throughout the book. Attila Krajcsi – Website | 0000-0001-9792-9091↩︎ This book is compiled from scratch in bookdown but some code snippets rely on Emily Kothe’s bookdown adaptation of the originasl material (e.g. some knitr plots and tables appear in the source code without alteration), numbered as version 0.6.1↩︎ "],["whywhywhy.html", "Chapter 1 Why do we learn statistics? 1.1 The curse of belief bias 1.2 The Simpson’s paradox 1.3 Statistics in psychology 1.4 There’s more to research methods than statistics", " Chapter 1 Why do we learn statistics? To the surprise of many students, statistics is a fairly significant part of a psychological education. To the surprise of no-one, statistics is very rarely the favourite part of one’s psychological education. Not surprisingly, there’s a pretty large proportion of the student base that isn’t happy about the fact that psychology has so much statistics in it. A big part of this issue at hand relates to the very idea of statistics. Why do you do statistics? Why don’t scientists just use common sense? Humans are susceptible to all kinds of biases, temptations and frailties, and much of statistics is basically a safeguard. Using “common sense” to evaluate evidence means trusting gut instincts, relying on verbal arguments and on using the raw power of human reason to come up with the right answer, which is not scientific at all. 1.1 The curse of belief bias Psychologists have shown over the years is that we really do find it hard to be neutral, to evaluate evidence impartially and without being swayed by pre-existing biases. A good example of this is the belief bias effect in logical reasoning: if you ask people to decide whether a particular argument is logically valid (i.e., conclusion would be true if the premises were true), we tend to be influenced by the believability of the conclusion, even when we shouldn’t. For instance, here’s a valid argument where the conclusion is believable: No cigarettes are inexpensive (Premise 1) Some addictive things are inexpensive (Premise 2) Therefore, some addictive things are not cigarettes (Conclusion) And here’s a valid argument where the conclusion is not believable: No addictive things are inexpensive (Premise 1) Some cigarettes are inexpensive (Premise 2) Therefore, some cigarettes are not addictive (Conclusion) The logical structure of argument #2 is identical to the structure of argument #1, and they’re both valid. However, in the second argument, there are good reasons to think that premise 1 is incorrect, and as a result it’s probably the case that the conclusion is also incorrect. But that’s entirely irrelevant to the topic at hand: an argument is deductively valid if the conclusion is a logical consequence of the premises. That is, a valid argument doesn’t have to involve true statements. On the other hand, here’s an invalid argument that has a believable conclusion: No addictive things are inexpensive (Premise 1) Some cigarettes are inexpensive (Premise 2) Therefore, some addictive things are not cigarettes (Conclusion) And finally, an invalid argument with an unbelievable conclusion: No cigarettes are inexpensive (Premise 1) Some addictive things are inexpensive (Premise 2) Therefore, some cigarettes are not addictive (Conclusion) Now, suppose that people really are perfectly able to set aside their pre-existing biases about what is true and what isn’t, and purely evaluate an argument on its logical merits. We’d expect 100% of people to say that the valid arguments are valid, and 0% of people to say that the invalid arguments are valid. So if you ran an experiment looking at this, you’d expect to see data like this: conclusion feels true conclusion feels false argument is valid 100% say valid 100% say valid argument is invalid 0% say valid 0% say valid If the psychological data looked like this (or even a good approximation to this), we might feel safe in just trusting our gut instincts. That is, it’d be perfectly okay just to let scientists evaluate data based on their common sense, and not bother with all this murky statistics stuff. In a classic study, Evans et al. (1983) ran an experiment looking at exactly this. What they found is that when pre-existing biases (i.e., beliefs) were in agreement with the structure of the data, everything went the way you’d hope: conclusion feels true conclusion feels false argument is valid 92% say valid argument is invalid 8% say valid Not perfect, but that’s pretty good. But look what happens when our intuitive feelings about the truth of the conclusion run against the logical structure of the argument: conclusion feels true conclusion feels false argument is valid 92% say valid 46% say valid argument is invalid 92% say valid 8% say valid Apparently, when people are presented with a strong argument that contradicts our pre-existing beliefs, we find it pretty hard to even perceive it to be a strong argument (people only did so 46% of the time). Even worse, when people are presented with a weak argument that agrees with our pre-existing biases, almost no-one can see that the argument is weak. It’s just too easy for us to “believe what we want to believe”; so if we want to “believe in the data” instead, we’re going to need a bit of help to keep our personal biases under control. That’s what statistics does: it helps keep us honest. 1.2 The Simpson’s paradox In 1973, the University of California, Berkeley, had some worries about the gender breakdown of student admissions into postgraduate courses. Given that there were nearly 13,000 applicants, a difference of 9 percentage points in admission rates between males and females is just way too big to be a coincidence. Number of applicants Percent admitted Males 8442 46% Females 4321 35% When people started looking more carefully at the admissions data (Bickel et al., 1975) on a department by department basis, it turned out that most of the departments actually had a slightly higher success rate for female applicants than for male applicants. Male Female Department Applicants Admitted Applicants Admitted A 825 62% 108 82% B 560 63% 25 68% C 325 37% 593 34% D 417 33% 375 35% E 191 28% 393 24% F 272 6% 341 7% Yet the overall rate of admission across the university for females was lower than for males. How can both of these statements be true at the same time? Firstly, notice that the departments are not equal to one another in terms of their admission percentages: some departments (e.g., engineering, chemistry) tended to admit a high percentage of the qualified applicants, whereas others (e.g., English) tended to reject most of the candidates, even if they were high quality. So, among the six departments shown above, notice that department A is the most generous, followed by B, C, D, E and F in that order. Next, notice that males and females tended to apply to different departments. If we rank the departments in terms of the total number of male applicants, we get A&gt;B&gt;D&gt;C&gt;F&gt;E (the “easy” departments are in bold). On the whole, males tended to apply to the departments that had high admission rates. Now compare this to how the female applicants distributed themselves. Ranking the departments in terms of the total number of female applicants produces a quite different ordering C&gt;E&gt;D&gt;F&gt;A&gt;B. In other words, what these data seem to be suggesting is that the female applicants tended to apply to “harder” departments. And in fact, if we look at Figure 1.1, we see that this trend is systematic, and quite striking. This effect is known as Simpson’s paradox. It’s not common, but it does happen in real life, and most people are very surprised by it when they first encounter it, and many people refuse to even believe that it’s real. It is very real. Figure 1.1: The Berkeley 1973 college admission rate for the 85 departments that had at least one female applicant based on Bickel et al. (1975). Circles plot departments with more than 40 applicants; the area of the circle is proportional to the total number of applicants. The crosses plot department with fewer than 40 applicants. When doing research, there are lots of subtle, counterintuitive traps lying in wait for the unwary. Truth is sometimes cunningly hidden in the nooks and crannies of complicated data. Statistics only solves part of the problem. Remember that we started, we looked at the “aggregated” data, and it did seem like the university was discriminating against women, but when we “disaggregated” and looked at the individual behaviour of all the departments, it turned out that the actual departments were, if anything, slightly biased in favour of women. The gender bias in total admissions was caused by the fact that women tended to self-select for harder departments. If you’re interested in the overall structural effects of subtle gender biases, then you probably want to look at both the aggregated and disaggregated data. If you’re interested in the decision making process at Berkeley itself then you’re probably only interested in the disaggregated data. In short there are a lot of critical questions that you can’t answer with statistics, but the answers to those questions will have a huge impact on how you analyse and interpret data. And this is the reason why you should always think of statistics as a tool to help you learn about your data, no more and no less. It’s a powerful tool to that end, but there’s no substitute for careful thought. 1.3 Statistics in psychology We hope that the discussion above helped explain why science in general is so focused on statistics. But we’re guessing that you have a lot more questions about what role statistics plays in psychology, and specifically why psychology classes always devote so many lectures to stats. So here’s an attempt to answer a few of them… Why does psychology have so much statistics? The most important reason is that psychology is a statistical science. There’s a saying used sometimes in physics, to the effect that “if your experiment needs statistics, you should have done a better experiment”. The “things” that we study are people. Real, complicated, gloriously messy people. The “things” of physics include object like electrons, and while there are all sorts of complexities that arise in physics, electrons don’t have minds of their own. They don’t have opinions, they don’t differ from each other in weird and arbitrary ways, they don’t get bored in the middle of an experiment, and they don’t get angry at the experimenter and then deliberately try to sabotage the data set.5 We teach statistics to you as psychologists because you need to be better at stats than physicists. They have the luxury of being able to say that because their objects of study are simple in comparison to the vast mess that confronts social scientists. Can’t someone else do the statistics? To some extent, but not completely. It’s true that you don’t need to become a fully trained statistician just to do psychology, but you do need to reach a certain level of statistical competence. There’s three reasons that every psychological researcher ought to be able to do basic statistics: Firstly, there’s the fundamental reason: statistics is deeply intertwined with research design. If you want to be good at designing psychological studies, you need to at least understand the basics of stats. Secondly, if you want to be good at the psychological side of the research, then you need to be able to understand the psychological literature, right? But almost every paper in the psychological literature reports the results of statistical analyses. So if you really want to understand the psychology, you need to be able to understand what other people did with their data. And that means understanding a certain amount of statistics. Thirdly, there’s a big practical problem with being dependent on other people to do all your statistics: statistical analysis is expensive. In almost any real life situation where you want to do psychological research, the cruel facts will be that you don’t have enough money to afford a statistician. So the economics of the situation mean that you have to be self-sufficient. Note that a lot of these reasons generalise beyond researchers. If you want to be a practicing psychologist and stay on top of the field, it helps to be able to read the scientific literature, which relies pretty heavily on statistics. I don’t care about jobs, research, or clinical work. Do I need statistics? Statistics should matter to you in the same way that statistics should matter to everyone: we live in the 21st century, and data are everywhere. Frankly, given the world in which we live these days, a basic knowledge of statistics is pretty damn close to a survival tool! Which is the topic of the next section… 1.4 There’s more to research methods than statistics Most research methods courses will cover a lot of topics that relate much more to the pragmatics of research design, and in particular the issues that you encounter when trying to do research with humans. Most student fears relate to the statistics part of the course. Hopefully you are convinced that statistics matters, and more importantly, that it’s not to be feared. Introductory classes focus a lot on the statistics because you almost always find yourself needing statistics before you need the other research methods training. Why? Because almost all of your assignments in other classes will rely on statistical training, to a much greater extent than they rely on other methodological tools. It’s not common for undergraduate assignments to require you to design your own study from the ground up (in which case you would need to know a lot about research design), but it is common for assignments to ask you to analyse and interpret data that were collected in a study that someone else designed (in which case you need statistics). In that sense, from the perspective of allowing you to do well in all your other classes, the statistics is more urgent. But note that “urgent” is different from “important” – they both matter. We really do want to stress that research design is just as important as data analysis, and this book does spend a fair amount of time on it. However, while statistics has a kind of universality, and provides a set of core tools that are useful for most types of psychological research, the research methods side isn’t quite so universal. There are some general principles that everyone should think about, but a lot of research design is very idiosyncratic, and is specific to the area of research that you want to engage in. To the extent that it’s the details that matter, those details don’t usually show up in an introductory stats and research methods class. References Bickel, P. J., Hammel, E. A., &amp; O’Connell, J. W. (1975). Sex bias in graduate admissions: Data from Berkeley. Science, 187, 398–404. Evans, J. St. B. T., Barston, J. L., &amp; Pollard, P. (1983). On the conflict between logic and belief in syllogistic reasoning. Memory and Cognition, 11, 295–306. Some may argue that natural science experiments still struggle with data quality, noise etc. But there’s no evidence of an electron producing response bias in the lab due to over- or undercompliance, which is our point.↩︎ "],["researchdesign.html", "Chapter 2 Basic concepts 2.1 Introduction to psychological measurement 2.2 Measurement levels 2.3 Independent and dependent variables 2.4 Reliability 2.5 Validity Summary", " Chapter 2 Basic concepts In this chapter, we’ll discuss basic concepts and terminology related to measurement and study design. Since this book focuses on data analysis, it won’t give you enough information to design studies of your own. To do that, you’ll need to take a course in research design and methods. There are a couple of good books on the topic. This chapter relies on Howitt &amp; Cramer (2020) and Stevens (1946) for discussing scales of measurement, and on Boncz (2015), Michalos (2014), and Marks &amp; Yardley (2004) for discussing reliability and validity. 2.1 Introduction to psychological measurement First, data collection can be thought of as a kind of measurement. That is, what we’re trying to do here is measure something about human behaviour or the human mind. What do we mean by “measurement”? Measurement as a concept comes down to finding some way of assigning numbers, labels, or other well-defined descriptions to phenomena. So, any of the following would count as a psychological measurement: Danielle’s age is 33 years. She does not like anchovies. Her chromosomal gender is male. Her self-identified gender is female. In the short list above, the bolded part is “the thing to be measured”, and the italicised part is “the measurement itself”. We can expand on this a little bit by thinking about the set of possible measurements that could have arisen in each case: Age (in years) could have been 1, 2, 3 … years, etc. The upper bound on what the age could be is a bit fuzzy, but in practice, you’d be safe in saying that the largest possible age is 150 since no human has ever lived that long. And age doesn’t really have a true zero, but that is not important just yet. When asked if someone likes anchovies, they might say I do, I do not, I have no opinion, or I sometimes do. Chromosomal gender is almost certainly going to be male (XY) or female (XX), but there are a few other possibilities: with Klinefelter’s syndrome (XXY), it is more similar to male than to female. And there are other possibilities, too. Self-identified gender is also very likely to be male or female, transgender, nonbinary, queer etc. As you can see, for some things, like age, it seems pretty apparent what the set of possible measurements should be, whereas, for other things, it gets a bit tricky. But even regarding someone’s age, it’s a bit more subtle. For instance, if you’re a developmental psychologist, measuring in years is way too crude, and so you often measure age in years and months (if a child is 2 years and 11 months, this is usually written as “2;11”). If you’re interested in newborns, you might want to measure age in days since birth, or maybe even hours since birth. Looking at this a bit more closely, you might also realise that the concept of “age” isn’t all that precise. Generally, when we say “age”, we implicitly mean “the length of time since birth”. But that’s not always the right way to do it. Suppose you’re interested in how newborn babies control their eye movements. If Baby Alice is born 3 weeks premature and Baby Bianca is born 1 week late, would it really make sense to say that they are the “same age” if we encountered them “2 hours after birth”? In a sense, yes. By social convention, we use birth as our reference point for talking about age in everyday life since it defines the amount of time the person has been operating as an independent entity in the world. But from a scientific perspective, that’s not the only thing we care about. You might want to measure age from conception, and voilà, you’re already thinking about all the potential problems with analysis and comparisons. When we think about the biology of human beings, it’s often helpful to think of ourselves as organisms that have been growing and maturing since conception. From that perspective, Alice and Bianca aren’t the same age at all. So you might want to define the concept of “age” in two different ways: the length of time since conception and the length of time since birth. It won’t make much difference when dealing with adults, but when dealing with newborns, it might. In other words, how you specify the allowable measurement values is important. Still, there’s the question of methodology. What specific measurement method will you use to find out someone’s age? There are several options: You could just ask people, “how old are you?” The method of self-report is fast, cheap and easy, but it only works with people old enough to understand the question, and some people lie about their age. You could ask an authority (e.g. a parent), “how old is your child?” This method is fast, and it’s not all that hard when dealing with kids since the parent is almost always around. It doesn’t work as well if you want to know “age since conception” since a lot of parents can’t say for sure when conception took place. You might need a different authority (e.g. an obstetrician). You could look up official records, like birth certificates. This is time-consuming and annoying, but it has its uses (e.g. if the person is now dead). All of the ideas discussed in the previous section relate to the concept of operationalisation. To be a bit more precise about the idea, operationalisation is the process by which we take a meaningful but somewhat vague concept and turn it into an accurate measurement. The method of operationalisation can involve several different things: For instance, does “age” mean “time since birth” or “time since conception” in the context of your research? Will you use self-report to measure age, ask a parent, or look up an official record? If you’re using self-report, how will you phrase the question? Defining the set of allowable values that the measurement can take. Note that these values don’t always have to be numerical, though they often are. When measuring age, the values are numerical, but we still need to think carefully about what numbers are allowed. Do we want age in years, years and months, days, or hours? The values aren’t numerical for other types of measurements (e.g. gender). But, as before, we need to consider what values are allowed. If we’re asking people to self-report their gender, what options do we allow them to choose from? Is it enough to allow only “male” or “female”? Do you need an “other” option? Or should we not give people any specific options and let them answer in their own words? And if you open up the set of possible values to include all verbal responses, how will you interpret their answers? Operationalisation is tricky, and there’s no “one, true way” to do it. How you operationalise the informal concept of “age” or “gender” into a formal measurement depends on what you need to use the measurement for. You’ll often find that the community of scientists who work in your area have some well-established ideas for how to go about it. Tip: when working on your dissertation, consult your supervisor and the literature to see what the community has settled on. In other words, operationalisation needs to be thought through case-by-case. Nevertheless, while there are a lot of issues that are specific to each individual research project, there are some aspects to it that are pretty general. Let’s take a moment to clear up our terminology and, in the process, introduce one more term. Here are four different things that are closely related to each other: A clear construct. This is the concept that you’re trying to measure, like “age”, “gender”, or an “opinion”. A measure. The measure refers to the method or instrument used to make your observations. A question in a survey, a behavioural observation or a brain scan could all count as a measure. Operationalisation. This is the logical connection between the measure and the theoretical construct: a definition of how you assign value to the concept (calculation, range, level of measurement etc.). A variable. Finally, a new term. A variable is the outcome of the measurement process. Example 2.1 (Method) Here’s an example: Construct: attitude towards Prince Harry the Duke of Sussex (the underlying concept) Measure: 5-point Likert scale in a self-report survey (instrument) Operationalisation: survey a sample of UK online newsreaders and ask them to rate their level of agreement on a 5-point Likert scale with the following statement: “I personally find Prince Harry the Duke of Sussex an agreeable person”6. Variable: the numerical value of the response to the question, e.g., 5: “strongly agree”… 2.2 Measurement levels As the previous section indicates, the outcome of a psychological measurement is called a variable. But not all variables are of the same qualitative type, and it’s handy to understand what types there are. A very useful concept for distinguishing between different types of variables is what’s known as scales of measurement, or in CogStat terminology, measurement levels. 2.2.1 Nominal categories Definition 2.1 (Nominal scale variable) A nominal scale variable (also referred to as a categorical variable) is the results of a qualitative measurement, where the number of possible values are limited and fixed; they represent a name, a label, a classification, or non-overlapping categories; and there is no order, hierarchy or ranking between the categories. E.g. eye colour, place of residence, gender. For these kinds of variables, it doesn’t make any sense to say that one of them is “bigger’ or”better” than any other one, and it doesn’t make any sense to average them. The classic example for this is “eye colour”. Eyes can be blue, green and brown, among other possibilities, but none of them is any “better” than any other one. As a result, it would feel bizarre to talk about an “average eye colour”. Similarly, gender is nominal too: male isn’t better or worse than female, neither does it make sense to try to talk about an “average gender”. In short, nominal scale variables are those for which the only thing you can say about the different possibilities is that they are different. That’s it. Note that sometimes nominal variables will have numbers coded to them usually for technical reasons (e.g., in survey data outputs). E.g., 1: male, 2: female, 3: nonbinary… This is a common practice, but the variable is still nominal: the numbers are just a way of representing the categories, and you should never, ever, ever (!) analyse them as if they were numerical/score measurements. Example 2.2 (Nominal scale variable example) Suppose we were researching how people commute to and from work. One variable we would have to measure would be what kind of transportation people use to get to work. This “transport type” variable could have quite a few possible values, including: “train”, “bus”, “car”, “bicycle”, etc. For now, let’s suppose that these four are the only possibilities, and suppose that when we ask 100 people how they got to work today, we get this: Transportation Number of people Train 12 Bus 30 Car 48 Bicycle 10 So, what’s the average transportation type? Obviously, the answer here is that there isn’t one. You can say that travel by car is the most popular method, and travel by train is the least popular method, but that’s about all. That is based on the frequency of the occurence (i.e., count). Similarly, notice that the order in which the options are listed isn’t very exciting. We could have chosen to display the data like this: Transportation Number of people Car 48 Train 12 Bicycle 10 Bus 30 – and nothing really changes. 2.2.2 Ordinal scale and rank Definition 2.2 (Ordinal scale variable) An ordinal scale variable or rank is the results of a measurement, where there is a natural, meaningful way to order or rank the different outcome possibilities. E.g. finishing position in a race, education status. The quantitative difference between the outcomes might be unknown or uneven. E.g. education status: finishing elementary school takes 8 years in Europe, while an undergraduate degree is usually 3 years long; or you can say that the person who finished first was faster than the person who finished second, but you don’t know the exact difference (unless you had a “finished at” timestamp data, which in turn is no longer an ordinal variable anymore). The important thing is that there is a natural, meaningful way to order the outcomes, but we don’t quantify the difference between them. Note that you can have a numeric code assigned to an ordinal variable. However, do not process these numbers as if they were meaningful beyond them representing an order. E.g., if you have a variable that measures the level of education, and you code it as 1: elementary school, 2: high school, 3: undergraduate degree, 4: graduate degree, but the variable still represents an order (i.e., level): you cannot add, subtract, divide or multiply these numbers. Example 2.3 (Ordinal scale variable example) Suppose we’re interested in people’s attitudes to climate change, and we ask them to pick one of these four statements that most closely matches their beliefs: 1 Temperatures are rising because of human activity 2 Temperatures are rising, but we don’t know why 3 Temperatures are rising, but not because of humans 4 Temperatures are not rising Notice that these four statements actually do have a natural ordering in terms of “the extent to which they agree with the current science”. Statement 1 is a close match, statement 2 is a suitable match, statement 3 isn’t a perfect match, and statement 4 strongly opposes science. So, in terms of the thing we’re interested in (the extent to which people endorse the science), we can order the items as 1 &gt; 2 &gt; 3 &gt; 4. Since this ordering exists, it would be peculiar to list the options like this: 3 Temperatures are rising, but not because of humans 1 Temperatures are rising because of human activity 4 Temperatures are not rising 2 Temperatures are rising, but we don’t know why – because it seems to violate the natural “structure” of the question. So, let’s suppose I asked 100 people these questions and got the following answers: Response Number 1 Temperatures are rising because of human activity 51 2 Temperatures are rising, but we don’t know why 20 3 Temperatures are rising, but not because of humans 10 4 Temperatures are not rising 19 When analysing these data, it seems quite reasonable to try to group (1), (2) and (3) together and say that 81 of 100 people were willing to at least partially endorse the science. And it’s also quite reasonable to group (2), (3) and (4) together and say that 49 of 100 people registered at least some disagreement with the dominant scientific view. However, it would be entirely bizarre to try to group (1), (2) and (4) together and say that 90 of 100 people said what? There’s nothing sensible that allows you to group those responses together at all. That said, notice that while we can use the natural ordering of these items to construct sensible groupings, what we can’t do is average them. For instance, in our simple example here, the “average” response to the question is 1.97. We would love to know if someone can tell us what that means. 2.2.3 Interval scale Definition 2.3 (Interval scale variable) An (equal-)interval scale variable is the results of a quantitative measurement, where the difference between the outcomes is meaningful, but no true zero value can be assigned to our variable. E.g. temperature in Celsius or Fahrenheit etc. In contrast to nominal and ordinal scale variables, the differences between the numbers are interpretable: addition and subtraction make sense for interval scale variables. The intervals are same-sized, but a measurement value of 0 does not mean “nothing”/“none at all” on the Celsius scale: 0∘0^\\circ means “the temperature at which water freezes”, it’s a, useful, but arbitrary label, not a true zero. As a consequence, it becomes pointless to try to multiply and divide temperatures. It is wrong to claim that 20∘20^\\circ is negative two times as hot as −10∘-10^\\circ. Example 2.4 (Interval scale variable example) Suppose we’re interested in looking at how the attitudes of first-year university students have changed over time, and we need to capture the year they started. This is an interval scale variable. A student who started in 2003 did arrive 5 years before a student who started in 2008. However, it would be completely insane to divide 2008 by 2003 and say that the second student started “1.0024 times later” than the first one. 2.2.4 Ratio scale Definition 2.4 (Ratio scale variable) A ratio scale variable is the results of a quantitative measurement, where both the difference between the outcomes and the ratio of the outcomes are meaningful, and the variable has a true zero value. E.g. distance in meters, heart rate, mass, temperature on the Kelvin scale etc. The fourth and final type of variable to consider is a ratio scale variable, in which zero really means zero, and it’s okay to multiply and divide on top of addition and subtraction. You can have a heart rate of zero, or in other words, “no heart rate at all” (an absolute zero), but that sadly means that you are likely dead. Kelvin is a ratio scale variable, because it has a true zero (absolute zero), and 100 K means truly twice as much energy as 50 K. Example 2.5 (Ratio scale variable example) A psychological example would be the result of a short-term working memory capacity test7, where we ask respondents to remember a set of 5-letter words and recall them. Let’s make our variable the number of words that they successfully recall. Person A is able to recall 12 words, and Person B can recall 6 words, Person C cannot recall a single word (i.e., 0 words), and Person D can recall 7 words. We can set an order between them: Person A &gt; Person D &gt; Person B &gt; Person C; there is equal distance between the possible units, so subtraction is meaningful (interval); furthermore, there is a true zero (Person C). It also makes sense to say Person B made twice as many errors as Person A. 2.2.5 The special case of the Likert scale The humble Likert scale is all survey designs’ bread and butter tool. You have filled out hundreds, maybe thousands of them, and odds are you’ve even used one yourself. Suppose we have a survey question that looks like this: Which of the following best describes your opinion of the statement that “all pirates are awesome” … and then, the options presented to the participant are these: Strongly disagree Disagree Neither agree nor disagree Agree Strongly agree This set of items is an example of a 5-point Likert scale: people are asked to choose among one of several (in this case, 5) clearly ordered possibilities, generally with a verbal descriptor given in each case. However, it’s not necessary that all items be explicitly described. This is a perfect example of a 5-point Likert scale too: Strongly disagree Strongly agree Likert scales are convenient, if somewhat limited, tools. The question is, what kind of variable are they? They’re obviously discrete since you can’t give a response of 2.5. They’re obviously not nominal scale since the items are ordered, and they’re not ratio scale either since there’s no natural zero8. But are they ordinal scale or interval scale? One argument says that we can’t prove that the difference between “strongly agree” and “agree” is of the same size as the difference between “agree” and “neither agree nor disagree”. In fact, in everyday life, it’s pretty apparent they’re not the same. So this suggests that we ought to treat Likert scales as ordinal variables. On the other hand, we can argue that some participants will take the whole “on a scale from 1 to 5” part seriously, and they tend to act as if the differences between the five response options were equidistant. While theoretically it is not an interval scale, researchers treat it as a quasi-interval scale. 2.2.6 Continuous versus discrete variables There’s a second kind of distinction that you need to be aware of regarding what types of variables you can run into. This is the distinction between continuous and discrete data types. Definition 2.5 (Continuous variables) A continuous variable can take on any value on a spectrum, and it’s logically possible to have a value in between. Example 2.6 (Continuous variable example) Response time is continuous. If Alan takes 3.1 seconds and Ben takes 2.3 seconds to respond to a question, then Cameron’s response time can lie in between by taking 3.0 seconds. And, of course, it would also be possible for David to take 3.031 seconds to respond, meaning that his RT would lie in between Cameron’s and Alan’s. And while in practice, it might be impossible to measure RT that precisely, it’s certainly possible in principle. Because we can always find a new value for RT in between any two other ones, we say that RT is continuous. Definition 2.6 (Discrete variables) A discrete variable can take on a limited number of distinct values; there is no possible value in between. Example 2.7 (Discrete variable example) Nominal scale variables are always discrete: there isn’t a type of transportation that falls “in-between” trains and bicycles, not in the strict mathematical way that 2.3 falls in between 2 and 3. So transportation type is discrete. Similarly, ordinal scale variables are always discrete: although “2nd place” does fall between “1st place” and “3rd place”, there’s nothing that can logically fall in between “1st place” and “2nd place”. Interval scale and ratio scale variables can go either way. Temperature in degrees Celsius (an interval scale variable) is also continuous; however, the year you went to school (an interval scale variable) is discrete. There’s no year between 2002 and 2003. The number of questions you get right on a true-or-false test (a ratio scale variable) is also discrete: since a true-or-false question doesn’t allow you to be “partially correct”, there’s nothing in between 5/10 and 6/10. Note that some people might say “discrete variable” when they mean “nominal scale variable”. While all nominal scale variables are discrete, not all discrete variables are nominal. 2.2.7 A summary guide for levels of measurement Variable types Nominal Ordinal Interval Ratio Data types Discrete ✓\\checkmark ✓\\checkmark ✓\\checkmark ✓\\checkmark gender, birthplace education, finishing position year of enrolment to university number of questions answered correctly Continuous ✓\\checkmark ✓\\checkmark attitude height, weight, heart rate, distance Properties Can be ordered or ranked ✓\\checkmark ✓\\checkmark ✓\\checkmark Equidistant units ✓\\checkmark ✓\\checkmark Has a meaningful, true zero ✓\\checkmark Valid operations ++ addition, −- subtraction ✓\\checkmark ✓\\checkmark ×\\times multiplication, ÷\\div division ✓\\checkmark ✓\\checkmark Central tendency measures Mode ✓\\checkmark ✓\\checkmark ✓\\checkmark ✓\\checkmark Median ✓\\checkmark ✓\\checkmark ✓\\checkmark Mean ✓\\checkmark ✓\\checkmark 2.3 Independent and dependent variables Usually, when we do some research, we end up with lots of different variables. Then, when we analyse our data, we often try to explain some of the variables in terms of the other variables. It’s essential to keep the two roles, “thing doing the explaining” and “thing being explained”, distinct. So let’s be clear about this now. Firstly, we might as well get used to the idea of using mathematical symbols to describe variables since it’s going to happen repeatedly. Let’s denote the “to be explained” variable YY, and the variables “doing the explaining” as X1X_1, X2X_2, etc. Now, when we are doing analysis, we have different names for XX and YY, since they play different roles. The classical names for these roles are independent variable (IV) and dependent variable (DV). The IV is the variable you use to explain (i.e., XX) and the DV is the variable being explained (i.e., YY). The logic behind these names goes like this: if there is a relationship between XX and YY, then we can say that YY depends on XX, and if we have designed our study “properly”, then XX isn’t dependent on anything else. However, those names are horrible: they’re hard to remember, and they’re highly misleading because (a) the IV is never actually “independent of everything else” and (b) if there’s no relationship, then the DV doesn’t actually depend on the IV. And, because we’re not the only people who think that IV and DV are just awful names, there are several alternatives that some find more appealing. The terms used in these notes are predictors and outcomes. The idea here is that you’re trying to use XX (the predictors) to make guesses about YY (the outcomes). This is summarised in Table 2.1. Table 2.1: The terminology used to distinguish between different roles that a variable can play when analysing a data set role of the variable classical name modern name to be explained dependent variable (DV) outcome to do the explaining independent variable (IV) predictor 2.4 Reliability By applying psychological measures we end up with variables, which can come in many different types. But the inevitable question arises: is the measurement any good? We’ll do this in terms of two related ideas: reliability and validity. Definition 2.7 (Reliability) The reliability of a measure is the extent to which it is dependably, consistently, and stably giving the same result when measuring the same observation. Example 2.8 (Reliability example A) You are designing a health psychology experiment to test the effect of psilocybin on mood disorders9. You are trying to find the right bodyweight-adjusted dose. You have a scale in the lab in Room A. You ask a participant to step on and you read 65 kg. For some reason, within a minute (in which they didn’t drink, eat or go to the bathroom), you have to ask them to step back, but this time, the scale shows 74 kg. Disbelief creeps in, rightly. You are confused, and you decide to ask them to step on the scale again. This time, the scale shows 65 kg. Can you trust this 65 kg reading? You borrow a scale from Room B and ask the same participant to step on it – again, within a minute or two, so no weight shift should occur. This time, the scale shows 68 kg after three consecutive readings. But can you trust this 68 kg reading? You have your doubts. So you go into Room C, which has a different type of scale. The participant steps on the scale three times, and it consistently shows 68 kg. Example 2.9 (Reliability example B) You have a patient admitted to a ward, and you and your colleague are asked to evaluate them. You both use the same version of the Questionnaire X, still within the same time of day, but you both end up with different scores and different diagnoses. Can you trust either of your scores? A senior colleague provides you with SCID-5, a structured clinical interview for diagnosing mental disorders based on DSM-5. You use it to evaluate the patient. You both get a diagnosis of major depressive disorder. The examples already hints at different ways of thinking about reliability, but let’s summarise what the different types of reliability might be: Test-retest or temporal reliability. This relates to consistency over time: if we repeat the measurement on the same thing at a later date, do we get the same answer? In Example 2.8, the scale in Room A was not reliable, but the scale in Room B and Room C was. Interrater reliability. This relates to consistency across people: if someone else repeats the measurement, will they produce the same answer? In Example 2.9, the two raters gave different answers with the same Questionnaire X, so clearly it was not reliable in this sense, however the SCID-5 was10. If this fails, the instrument is subjective. Internal consistency reliability or homogeneity. Suppose a measurement is constructed from many different parts that perform similar functions. Inventories and scales use multiple questions to measure a single concept. If the questions are all measuring the same thing, then they should be consistent with each other. Ideally, items relating to the same concept should be highly correlated with each other, i.e., they should be consistent with each other11. Parallel/alternative forms reliability. This relates to consistency across theoretically-equivalent measurements. In Example 2.8, the scales in both Room B and Room C gave the same reading. Two different “versions” of a measurement instrument were used to measure the same concept (human body weight), and they gave the same answer12. Split-half reliability. This is a very specific concept widely used in survey design: divide a test into two halves, and see if the two halves are consistent with each other by calculating the reliability coefficient. Not all measurements need to possess all forms of reliability. Nevertheless, it is important to be aware of reliability as a concept with its forms. CogStat will help you with analysing internal consistency and interrater reliability as of version 2.4+, but we will cover the tutorial once we understand how to compare two groups of data (Chapter 6). 2.5 Validity More than any other thing, a scientist wants their research to be “valid”. The conceptual idea behind validity is simple: can you trust the results of your study? In practice, there aredifferent kinds of validity, each of which raises its own issues, and not all forms of validity are relevant to all studies. While validity is a research methodology subject and not a statistical one, some forms of validity are measured using statistical methods. So let’s talk about different kinds of validity briefly, in a somewhat particular order. Definition 2.8 (Content validity) The content validity is the extent to which an instrument measures the desired concept or construct comprehensively (with no gaps or missing aspects) and accurately (with no irrelevant or misleading domains). Some typical questions would be: Are all important domains of the concept we want to measure covered? Does the selected instrument measure the same concept that we are trying to measure in all its aspects? Are there any items in the instrument that are not relevant to the concept we are trying to measure? What biases might be present in the instrument? Is the instrument culturally sensitive? Is the instrument reliable and consistent across different subgroups of the population? A subjective judgement of content validity is called face validity. Definition 2.9 (Face validity) The face validity of a study is the extent to which the measurement of a variable “looks like” it’s measuring the correct theoretical construct, but it is a subjective judgement. Types of questions that you might ask: Does the instrument look like it’s measuring the right thing? Will the participant recognise the construct that we are trying to measure? (This might lead to cases where the participant fakes the response.) Definition 2.10 (Construct validity) The construct validity is the extent to which the measurement of a variable is consistent with the theoretical construct that it is supposed to measure. Typical questions you might consider: Is the construct defined in a way that is clear and unambiguous? Is the construct defined too broadly or too narrowly? Is the sample and method appropriate for the construct? How does this instrument relate to other instruments designed to measure the same construct? Does the instrument produce the same expected results as other instruments designed to measure the same construct? Does the instrument predict other variables that are theoretically related to the construct? To test for construct validity, we can to test for discriminant validity13 through correlation and factor analysis. Definition 2.11 (Discriminant validity) The discriminant validity assesses the extent to which a measure is capable of accurately distinguishing the construct variable it is intended to measure from an unrelated construct variables. It is the opposite of convergent validity. Question: What is the correlation between the variable we are measuring and other variables that should not be related to it? →\\rightarrow discriminant validity coefficient Definition 2.12 (Convergent validity) The convergent validity is the extent to which the measurement of a variable is consistent with other variables that should be theoretically related to it. Types of questions you might consider: What is the correlation between the variable we are measuring and other variables that should be related to it? →\\rightarrow correlation coefficient Example 2.10 (Constructs and validity) You are researching the relationship between socio-economic status and health outcomes. The health outcome is the construct of interest, it is the dependent variable. The socio-economic status is the independent variable. You are interested in the relationship between the two, and you want to know if socio-economic status is a good predictor of health outcomes. There are a number of related variables that you could use to measure socio-economic status, such as: personal income, household income, education, occupation, and so on. You could use any of these variables to measure socio-economic status, but you want to know which one is the best predictor of health outcomes. You could test for the relationship between each of these variables and health outcomes, and then choose the one that has the highest correlation coefficient. This is a form of convergent validity. There are unrelated variables that have an effect on health outcomes, such as: environment, gender, disability and impairments, minority status, family history of diseases, and so on. If the unrelated variables demonstrate a weak correlation with the socio-economic status variables, then this is a form of discriminant validity. You’ll notice that in this particular example, gender14, disability, and minority status as variables would likely have a stronger than weak correlation with socio-economic status. These are called confounding variables. They are variables that are related to both the independent and dependent variables, and they can affect the results of the study. You’ll need to control for these variables in your study design. Definition 2.13 (Internal validity) The internal validity is the extent to which the results of the study can be attributed to the cause-and-effect relationships between the variables studied, rather than other factors. I.e., any change in the dependent variable (outcome) is a result of the manipulation of the independent variable (predictor), and not due to other factors. Typical questions would be: Is the relationship between the independent and dependent variables causal? Is this cause-and-effect relationship the only one that could explain the results? Are there any confounding variables that could affect the results? Was the design fit for establishing causality? Definition 2.14 (External validity) The external validity of a study is the extent to which the results of the study can be generalised to other people, other situations, and other times. Questions to consider: To what extent can the results of the study be generalised to other people, other situations, and other times? Is the sample representative of the population? Is the sample too narrow? (e.g. only psychology students) Is this study replicable across different settings? Are there any respondent biases that could affect the results? (Hawthorne effect, demand characteristics, etc.) Definition 2.15 (Ecological validity) The ecological validity of a study is the extent to which the entire study set-up closely approximates the real-world scenario being investigated. Some typical questions would be: Is the lab-based study set-up similar to the real-world scenario? Would the study scenario occur naturally in the real world or in other non-controlled environment? Are there any environmental or systemic factors that could affect the replicability of results in the real world? Definition 2.16 (Criterion validity) The criterion validity of an instrument is the extent to which the score results are consistent with other measures of the same construct. Typical questions would be: Does the instrument produce the same expected results as other instruments designed to measure the same construct? Is the correlation between the instrument and other instruments designed to measure the same construct high enough? Definition 2.17 (Concurrent validity) The concurrent validity of an instrument is the extent to which the score results are consistent with other criterion measures (where the criterion is measured at the same time as the instrument is administered). Question: What is the correlation between the instrument and other instruments designed to measure the same construct at the same time on the same sample? →\\rightarrow concurrent validity coefficient Definition 2.18 (Predictive validity) The predictive validity of an instrument is the extent to which the results can be used to make inferences about future criterion outcomes (where the criterion is measured after the instrument is administered). Definition 2.19 (Postdictive validity) The postdictive validity or retrospective validity of an instrument is the extent to which the results can be used to make inferences about past criterion outcomes (where the criterion is measured before the instrument is administered). Modern Validity Theory Terminology The American Educational Research Association (AERA), the American Psychological Association (APA), and the National Council on Measurement in Education (NCME) prepared their Standards for Educational and Psychological Testing (2014). This standard uses different terminology to describe the different types of validity. It does not apply validity to the research instrument but rather the interpretation of it; it is a continuum and not a dichotomy (“valid” or “not valid”) (Edwards et al., 2018). So in this mindset, we no longer have types of validity but rather types of validity evidence: Evidence based on test content Evidence based on response processes Evidence based on internal structure Evidence based on relations to other variables However, still many statistics and research methodology textbooks used today, particularly the ones that are used to create this chapter, use the historical terminology. Summary This chapter isn’t really meant to provide a comprehensive discussion of psychological research methods: it would require another volume just as long as this one does justice to the topic. However, in real life, statistics and study design are tightly intertwined, so discussing some key topics is convenient. In this chapter, we’ve briefly discussed the following: Measurement. What does it mean to operationalise a theoretical construct? What does it mean to have variables and take measurements? Scales of measurement and variable types. Remember that there are two different distinctions here: there’s the difference between discrete and continuous data, and there’s the difference between the four different scale types (nominal, ordinal, interval and ratio). Terminology: predictors and outcomes. What roles do variables play in an analysis? Can you remember the difference between predictors and outcomes? Dependent and independent variables? Etc. Reliability. Can you trust your results? How do you know that your measurements are consistent? Validity. Does your study measure what you want it to? References American Educational Research Association, American Psychological Association, &amp; National Council on Measurement in Education. (2014). Standards for Educational and Psychological Testing. American Educational Research Association. Boncz, I. (2015). Research methodology basics [Kutatásmódszertani alapismeretek]. Pécsi Tudományegyetem. Brodey, B. B., First, M., Linthicum, J., Haman, K., Sasiela, J. W., &amp; Ayer, D. (2016). Validation of the NetSCID: An automated web-based adaptive version of the SCID. Comprehensive Psychiatry, 66, 67–70. https://doi.org/10.1016/j.comppsych.2015.10.005 Cowan, N. (2015). George Miller’s magical number of immediate memory in retrospect: Observations on the faltering progression of science. Psychological Review, 122(3), 536–541. https://doi.org/10.1037/a0039035 Edwards, M. C., Slagle, A., Rubright, J. D., &amp; Wirth, R. J. (2018). Fit for purpose and modern validity theory in clinical outcomes assessment. Quality of Life Research, 27(7), 1711–1720. https://doi.org/10.1007/s11136-017-1644-z Garcia-Romeu, A., Barrett, F. S., Carbonaro, T. M., Johnson, M. W., &amp; Griffiths, R. R. (2021). Optimal dosing for psilocybin pharmacotherapy: Considering weight-adjusted and fixed dosing approaches. Journal of Psychopharmacology, 35(4), 353–361. https://doi.org/10.1177/0269881121991822 Howitt, D., &amp; Cramer, D. (2020). Understanding statistics in psychology with SPSS (Eighth edition). Pearson. Hubley, A. M. (2014). Divergent Validity. In A. C. Michalos (Ed.), Encyclopedia of Quality of Life and Well-Being Research (pp. 1675–1676). Springer Netherlands. https://doi.org/10.1007/978-94-007-0753-5_766 Marks, D., &amp; Yardley, L. (Eds.). (2004). Research methods for clinical and health psychology. SAGE. Michalos, A. C. (Ed.). (2014). Encyclopedia of quality of life and well-being research. Springer. Miller, G. A. (1956). The magical number seven, plus or minus two: Some limits on our capacity for processing information. Psychological Review, 63(2), 81–97. https://doi.org/10.1037/h0043158 Stevens, S. S. (1946). On the theory of scales of measurement. Science, 103, 677–680. Taylor, S. E., &amp; Stanton, A. L. (2021). Health Psychology (Eleventh). McGraw-Hill. Is this most relevant sentence that accurately represents the concept you want to measure?↩︎ One of the most famous ones is a digit span test (Miller, 1956), but the original article is not without its faults (Cowan, 2015).↩︎ And you can’t cheat. You can code your Likert scale from 0 to 4 instead of 1 to 5, but these are arbitrary, just like deciding that the freezing temperature is labelled as 0.↩︎ Read up on actual research on dosing, if interested. At the time of writing, this is an excellent starting point: Garcia-Romeu et al. (2021)↩︎ SCID-5 is a golden standard, but it is not fully void of inter-rater reliability issues, particularly among recently trained clinicians (Brodey et al., 2016), however, there are always new tools or versions to help tackle this.↩︎ Of course if some items are too highly correlated, one or two of them might even be redundant to be dropped while keeping the overall consistency high. However, we won’t cover in detail survey design in this book.↩︎ Making different versions of the same test, e.g. by switching up the order of items is one possible way to test for reliability.↩︎ Sometimes referred to as divergent validity. This, however, is not a universally accepted terminology (Hubley, 2014).↩︎ E.g. research suggests that there are a number of reasons why women tend to live longer than men beyond socio-economic status (with which the relationship is negative), like biological protective factors and differences in risk aversion between men and women (Taylor &amp; Stanton, 2021).↩︎ "],["autostat.html", "Chapter 3 Automatic statistical analysis", " Chapter 3 Automatic statistical analysis To produce strong research results, it is important to have good data analysis, which can make or break a research project. In psychological research, this includes: identifying and selecting a good design from many alternative design options, sampling participants appropriately, observing ethical standards in data collection and documentation, controlling for confounding variables, selecting appropriate statistics and replications of analyses, analysing data with appropriate software, assessing the effect sizes of results based on their inferential characteristics, reporting findings accurately in papers – just to name a few. Some of these tasks can be automated to ensure that the appropriate protocol is followed, which is why we have CogStat, and why you are reading this book. Neglecting early protocols can lead to errors. For example, using a tool designed for normally distributed data on a highly skewed data set will be inappropriate. In this book, we will cover why this characteristic of our data set matters. Ignoring the foundations of hypothesis testing tools will harm the reliability of the research and, in turn, the reliability and prestige of psychology as a science. There are several manual statistical programs, such as SPSS, SAS, and Stata, and some programming languages used for data analysis, such as R and Python. These tools can be time-consuming and require multiple steps for simple tasks like creating tables and graphs, not to mention the time spent on learning how to use them. One benefit of automatic statistical software is that it is programmed to follow all necessary steps as part of its protocol. A good automatic statistical software will apply the most appropriate tools based on current statistical consensus. In this book, you will learn what it means to do normality and heteroscedasticity checks, calculate effect sizes, and performing hypothesis tests etc. We focus on making sure you understand what they are, why they matter, and how to interpret them. We will indulge in presenting mathematical formulas as well, but you won’t have to do any of the calculations. To be fair, you don’t have to manually calculate the respective metrics in a manual statistical program either, but deciding which tool to pick up first, or which step to take next might be a challenge if statistics is not in your veins. Beyond the anxiety of how to even get started with manual statistical programs, applying a single tool can take up to tens of steps. In comparison, producing the full analysis with multiple tools with supporting charts and graphs may only take three steps in CogStat. There is a high pressure on researchers to produce a large volume of work with statistically positive results (Krajcsi, 2021), and they often have too little time for rigorous data analysis and interpretation. At the same time, journals set somewhat arbitrary standards (e.g. specific pp-values are demanded whether or not they avoid Type I errors – this is one of the topics in this book), so some researchers might just use those as rules of thumb without going deeper into data analysis. In recent years, the reliability of psychological science has been questioned (Open Science Collaboration, 2015) due to the overstated use of certain statistical measures (e.g., pp-values, effect sizes), and the overall lower-than-expected replicability. While automatic analysis cannot solve all of the systematic issues, it does enable researchers to shift their focus to the quality of content. Time spent on data analysis can be redirected towards understanding the implications of the test results for the research question. For more about the merits of automatic statistical analysis, here are some further reads from Attila Krajcsi, the creator of CogStat: Methodological considerations behind CogStat Reducing the replication crisis References Krajcsi, A. (2021). Advancing best practices in data analysis with automatic and optimized output data analysis software [Preprint]. PsyArXiv. https://doi.org/10.31234/osf.io/hnmsq Open Science Collaboration. (2015). Estimating the reproducibility of psychological science. Science, 349(6251), aac4716. https://doi.org/10.1126/science.aac4716 "],["cogstatintro.html", "Chapter 4 Introduction to CogStat", " Chapter 4 Introduction to CogStat CogStat is a statistical analysis program designed for psychology research, particularly in cognitive science. It is user-friendly and automatic, yet powerful enough to handle a variety of statistical analyses. CogStat is free to download from the CogStat website and runs on Windows, macOS, and Linux. The main feature of CogStat is its automatic analysis of source data and automatic selection of hypothesis tests, which can be very useful after learning about statistical theory and hypothesis testing. The program will automatically choose the most appropriate statistical test for your data, making it a useful tool for researchers who want to save time on test selection or are unsure of the best fit for their purposes. CogStat automatically analyzes data based on its scale type, runs necessary pre-checks (such as for normality and heteroscedasticity), and performs the appropriate hypothesis test. The results are presented in a clear format following APA7 guidelines, and the program also generates graphical representations of the results. To install CogStat, simply download the latest version from the CogStat website. The installation is easy and straightforward, and should only take a few minutes. For help with installation, please visit our GitHub page. To quickly test CogStat without using your own data, you can use the demo data provided in the program. From the Data &gt; Open demo data file... menu, choose a folder and data file, then click Open. To use your own data with CogStat, prepare it in spreadsheet software like Excel, Google Spreadsheet, or LibreOffice Calc, or in statistical software like jamovi, JASP, SPSS, STATA, or SAS. CogStat does not handle data editing tasks, as there are more efficient solutions available. To import your data into CogStat, you can either copy and paste it from your spreadsheet software, or import it as a saved file (.xlsx, .ods, .csv, .jasp, .omv, .rdata etc.). You can also drag and drop the file into the CogStat window. If your data comes from a spreadsheet software or is a text file, like .csv, make sure of the following: The first row of your data should include the variable names without accent characters (áâő…). The second row should include the measurement levels: int for interval and ratio scales, ord for ordinal variables, and nom for nominal variables. More on measurement levels (scales) in Chapter 2.2. The remaining rows should include the values of the variables. To learn more about using CogStat, including how to prepare and load data, refer to the GitHub Wiki page. "],["exploringavariable.html", "Chapter 5 Exploring a single variable 5.1 Measures of central tendency 5.2 Measures of variability 5.3 Skewness and kurtosis 5.4 Standard scores (zz-score) Summary", " Chapter 5 Exploring a single variable Any time you get a new data set to look at, one of the first things you might want to do is find ways of summarising the data in a compact, easily understood fashion. This is what descriptive statistics (as opposed to inferential statistics) is all about. In fact, to many people, the term “statistics” is synonymous with descriptive statistics. The first dataset we’ll be looking at is real data relating to the Australian Football League (AFL)15. To do this, let us load the aflsmall.csv file. Figure 5.1: Loading aflsmall.csv CogStat will help you get familiar with some essential aspects of your variable, like: measures of central tendency (mean, median) measures of variability (range, minimum, maximum, standard deviation, quartiles) measures of “distortion” (skewness, kurtosis). These measures will help you contextualise the results so the conclusions drawn from the variable will be valid. To start understanding a variable in CogStat, select Explore variable so a pop-up appears. Move the name of the data you wish to analyse (in this case: aflmargins) from Available variables to Selected variables, then click OK (Figure 5.2). Figure 5.2: Explore variable dialogue. Figure 5.3: Explore variable results for the aflsmall.csv data set. This is the first chart you will see exploring the raw shape of the data. The first piece of information here is NN, which we will use to refer to the number of observations we’re analysing. CogStat (or any other software for that matter) will only use valid data for calculations. Sometimes, when working with survey data, you will have missing data points, the number of which you might have to mention in your report. CogStat will quote these for you: N of valid cases: 176 N of missing cases: 0 In the rest of this chapter, we will explore what these measures mean and what they indicate. 5.1 Measures of central tendency In most situations, the first thing that you’ll want to calculate is a measure of central tendency. That is, you’d like to know something about the “average” or “middle” of your data lies. Figure 5.4: Density plot with mean, median and mode. 5.1.1 The mean The first measure of central tendency is the mean, or arithmetic average. It is calculated by adding up all of the values in the data set and then divide the sum by the total number (count) of values. Definition 5.1 (Mean) The mean of a set of observations is the sum of the observations divided by the number of observations. X‾=∑i=1NXiN \\bar{X} = \\frac{\\sum_{i=1}^N X_i}{N} Of course, this definition of the mean isn’t news to anyone: averages (i.e., means) are used so often in everyday life that this is quite familiar. By tradition, we use X‾\\bar{X} as the notation for the mean, ∑\\scriptstyle\\sum for the idea of summation (see callout on notation), XiX_i for the iith observation, and NN for the total number of observations. We use subscripts to indicate which observation we’re talking about. That is, we’ll use X1X_1 to refer to the first observation, X2X_2 to refer to the second observation, and so on, all the way up to XNX_N for the last one. Example 5.1 (Mean) The first five AFL margins were 56, 31, 56, 8 and 32 (which CogStat will display when loading the data, see Figure 5.1), so the mean of these observations is just: 56+31+56+8+325=1835=36.60 \\frac{56 + 31 + 56 + 8 + 32}{5} = \\frac{183}{5} = 36.60 The following table lists the 5 observations in the afl.margins variable, along with the mathematical symbol used to refer to it, and the actual value that the observation corresponds to: Observation Symbol Observed value winning margin, game 1 X1X_1 56 points winning margin, game 2 X2X_2 31 points winning margin, game 3 X3X_3 56 points winning margin, game 4 X4X_4 8 points winning margin, game 5 X5X_5 32 points CogStat calculates the mean automatically when exploring a variable using all valid data points, not just the first five. It will be part of the Descriptives for the variable section, as seen in Figure 5.5. The result for our variable is: afl.margins Mean 35.3 Figure 5.5: Descriptive statistics and histogram for the aflsmall.csv data set. Scrolling down, you’ll see CogStat reporting all the descriptive measures while showing you a histogram to understand the shape of your data better. Drawing pictures of the data is an excellent way to convey the gist of what the data is trying to tell you; it’s often instrumental to try to condense the data into a few simple summary statistics. Summation symbol: ∑ and Product symbol: ∏ notations The summation symbol ∑\\scriptstyle\\sum is used to denote the operation of adding up a sequence of numbers. It is used to write out formulas in a concise way, and is used extensively in mathematics. ∑i=1nXi=X1+X2+...+Xn−1+Xn \\sum_{i=1}^n X_i = X_1 + X_2 + ... + X_{n-1} + X_n where ii is the index of the observation, which means that the index starts out at the given number, so in this case, at the first observation (X𝟏X_\\mathbf{1}). The index is incremented by 1 for each observation (even if i&gt;1i&gt;1), so the next observation is X𝟐X_\\mathbf{2}, and so on, until the last observation, which is X𝐧X_\\mathbf{n}, as denoted above the symbol. The choice to use Σ\\Sigma to denote summation isn’t arbitrary: it’s the Greek upper case letter sigma, which is the analogue of the letter S in that alphabet. Similarly, there’s an equivalent symbol used to denote the multiplication of lots of numbers: because multiplications are also called “products”, we use the Π\\Pi symbol for this; the Greek upper case pi, which is the analogue of the letter P. 5.1.2 The median The second measure of central tendency people use a lot is the median16, and it’s even easier to describe than the mean. Definition 5.2 (Median) The median is the middle value in a set of observations that has been arranged in ascending or descending order. Example 5.2 (Median) As before, let’s imagine we were interested only in the first 5 AFL winning margins: 56, 31, 56, 8 and 32. To figure out the median, we sort these numbers into ascending order. From inspection, it’s evident that the median value of these five observations is 32 since that’s the middle one in the sorted list. 8,31,𝟑𝟐,56,56 8, 31, \\mathbf{32}, 56, 56 But what should we do if we were interested in the first six games rather than the first 5? Since the sixth game in the season had a winning margin of 14 points, our sorted list is now: 8,14,𝟑𝟏,𝟑𝟐,56,56 8, 14, \\mathbf{31}, \\mathbf{32}, 56, 56 and there are two middle numbers, 3131 and 3232. The median is defined as the average of those two numbers, which is 31.531.5. In the data set we loaded to CogStat, there were 176 valid cases, so we ought to have two middle numbers. The result in this case is (as seen in Figure 5.5): afl.margins Median 30.5 5.1.3 Mean or median? What’s the difference? Figure 5.6: An illustration of the difference between how the mean and the median should be interpreted. The mean is basically the “centre of gravity” of the data set: if you imagine that the histogram of the data is a solid object, then the point on which you could balance it (as if on a see-saw) is the mean. In contrast, the median is the middle observation. Half of the observations are smaller, and half of the observations are larger. Knowing how to calculate means and medians is only a part of the story. You also need to understand what each one is saying about the data, what that implies, and which one to choose. This is illustrated in Figure 5.6; the mean is kind of like the “centre of gravity” of the data set, whereas the median is where you’d cut it in half. What this implies about which one you should use depends a little on what type of data you’ve got and what you’re trying to achieve. As a rough guide: If your data are nominal scale, you shouldn’t be using either the mean or the median. Both the mean and the median rely on the idea that the numbers assigned to values are meaningful (i.e., 1 means 1 of a unit of measure, and not simply a technical coding for “1: men, 2: women, 3: nonbinary …”). If the numbering scheme is arbitrary, then use the mode (Section 5.1.5) instead. If your data are ordinal scale, you can to use the median but not the mean. The median only uses the order information in your data (i.e., which numbers are larger) which is the purpose of an ordinal scale. The mean makes use of the precise numeric values assigned to the observations beyond their order info, so it’s not appropriate for ordinal data. For interval and ratio scale data, either one is generally acceptable. Which one you pick depends a bit on what you’re trying to achieve. The mean has the advantage of using all the information in the data (which is useful when you don’t have a lot of data), but it’s very susceptible to extreme values, as we’ll see in Chapter 5.1.4. Let’s expand on that last part a little. One consequence is that there are systematic differences between the mean and the median when the histogram is asymmetric (skewed; see Chapter 5.3). This is illustrated in Figure 5.6 notice that the median (right hand side) is located closer to the “body” of the histogram, whereas the mean (left hand side) gets dragged towards the “tail” (where the extreme values are). Example 5.3 (Mean or median) Suppose Bob (income $50,000), Kate (income $60,000) and Jane (income $65,000) are sitting at a table: the average income at the table is $58,333 and the median income is $60,000. Then Bill sits down with them (income $100,000,000). The average income has now jumped to $25,043,750 but the median rises only to $62,500. If you’re interested in looking at the overall income at the table, the mean might be the right answer; but if you’re interested in what counts as a typical income at the table, the median would be a better choice here. 5.1.4 Trimmed mean Example 5.4 (Outliers) Consider this rather strange-looking data set: −100,2,3,4,5,6,7,8,9,10 -100,2,3,4,5,6,7,8,9,10 If you were to observe this in a real-life data set, you’d probably suspect that there is something odd about the −100-100 value. It’s probably an outlier, a value that doesn’t belong with the others. You might consider removing it from the data set entirely. In this particular case, it might be the right call. However, you don’t always get such cut-and-dried examples. For instance, you might get this instead: −15,2,3,4,5,6,7,8,9,12 -15,2,3,4,5,6,7,8,9,12 The −15-15 looks suspicious, but not as much as that −100-100 did. In this case, it’s a little trickier. It might be a legitimate observation; it might not. When faced with a situation where some of the most extreme-valued observations might not be quite trustworthy, the mean is not necessarily a good measure of central tendency. It is highly sensitive to one or two extreme values and might not be a robust measure in all cases. One remedy is to use the median. An alternative solution is to use a trimmed mean. Definition 5.3 (Trimmed mean) A trimmed mean is a measure of central tendency, a type of average, that is calculated by discarding a certain percentage of the largest and smallest observations from the data, and then calculating the arithmetic average of the remaining observations. The goal is to preserve the best characteristics of the mean and the median: just like a median, you aren’t highly influenced by extreme outliers. Generally, we describe a trimmed mean in terms of the percentage of observations on either side that are discarded. So, for instance, a 10% trimmed mean discards the largest 10% of the observations and the smallest 10% of the observations and then takes the mean of the remaining 80% of the observations. Not surprisingly, the 0% trimmed mean is just the regular mean, and the 50% trimmed mean is the median. In that sense, trimmed means provide a whole family of central tendency measures that span the range from the mean to the median. Example 5.5 For our toy example above, we have 10 observations. So a 10% trimmed mean is calculated by ignoring the largest value (i.e. 1212) and the smallest value (i.e. −15-15) and taking the mean of the remaining values. Mean: 4.1 Median: 5.5 That’s a fairly substantial difference. But the mean is being influenced too much by the extreme values at either end of the data set, especially the −15-15 one. If we take a 10% trimmed mean, we’ll drop the extreme values on either side and take the mean of the rest: Mean: 5.5 Which, in this case, gives exactly the same answer as the median. Currently, there is no direct way for you to do that in CogStat, but you can certainly trim those outlying data points in your source file and re-load the data. 5.1.5 Mode Definition 5.4 (Mode) The mode is a measure of central tendency that indicates the value that occurs most frequently in the data set. Example 5.6 (Mode) Consider the following data set: 0, 1, 1, 2, 3, 5, 8, 13, 21 The mode would be 1, as it’s the value the occurs most frequently. A frequency table helps you identify the mode in more complex datasets even if it’s not calculated automatically. Value: Frequency (Relative frequency) 0: 1 (11.1%) 1: 2 (22.2%) 2: 1 (11.1%) 3: 1 (11.1%) 5: 1 (11.1%) 8: 1 (11.1%) 13: 1 (11.1%) 21: 1 (11.1%) In CogStat, you will see a frequency table (Figure 5.7) of the values in your data if you have Frequencies ticked in the Explore variable dialogue. Figure 5.7: The frequency table sorts non-nominal values from lowest to highest. While it’s generally true that the mode is most often calculated when you have nominal scale data – because means and medians are useless for those sorts of variables –, there are some situations in which you do want to know the mode of an ordinal, interval or ratio scale variable. Example 5.7 (Mode for ordinal, interval and ratio scale) Let’s look at our afl.margins variable we loaded into CogStat. This variable is clearly ratio scale, and so in most situations the mean or the median is the measure of central tendency that you want. But consider that a friend of yours is offering a bet. They pick a football game at random, and without knowing who is playing you have to guess the exact margin. If you guess correctly, you win $50. If you don’t, you lose $1. There are no consolation prizes for “almost” getting the right answer. You have to guess exactly the right margin17 For this bet, the mean and the median are completely useless to you. It is the mode that you should bet on. So, we look at the frequency table offered by the result set: the data suggest you should bet on a 3.03.0 point margin, and since this was observed in 8 of the 176 games (4.5% of games – the relative frequency), the odds are firmly in your favour. Bimodal distributions A data set which has only one mode (or in other terms, a density distribution with only one local maximum) is called unimodal, regardless if the peak is in the middle or at either end. A perfect example of a unimodal distribution is the normal distribution (the bell-curve). This is the one that we use when explaining the theory in this book. However, a distribution can have more than one modes or more than one local maxima, and some simplistic rules of thumb don’t necessarily work. Distributions with more than one modes are called bimodal (i.e., two peaks) or multimodal (i.e., multiple peaks) distributions. The graph shows a bimodal distribution with two local maximums (the peak at the left and the right), of which there is a global maximum (the peak at the left). This distribution plot’s yy values infer the frequency of each observation xx, so the higher the yy value, the more observations there are of that xx value. The mode is the xx value with the highest frequency (yy value). In this specific case there is only one mode, because there is only one global maximum (absolute highest frequency), but since there are two local maximums with identifiable, distinct clusters of data, the distribution is considered bimodal. You will likely encounter bimodal distributions in your data when you have multiple groups in one dataset. For example, when you measure an attitude towards a politically divisive subject with a Likert scale. When you graph the response on that item, you’ll likely see a bimodal distribution, but if you split the data by group (based on a binary demographic item measuring political affilition, for example), you’ll likely see two unimodal distributions with different skewness. 5.2 Measures of variability The statistics that we’ve discussed so far all relate to central tendency. They all talk about which values are “in the middle” or “popular” in the data. However, central tendency is not the only type of summary statistic that we want to calculate. The second thing that we really want is a measure of the variability (or, dispersion) of the data. That is, how “spread out” are the data? How “far” away from the mean or median do the observed values tend to be? Figure 5.8: Data sets with equal measures of central tendency but different variability. For now, let’s assume that the data are interval or ratio scale, so we’ll continue to use the afl.margins data. We’ll use this data to discuss several different measures of spread, each with different strengths and weaknesses. 5.2.1 Range Definition 5.5 (Range) As a measure of variability, the range of a variable is the difference between the largest and smallest observation in the data set. Range=max(x)−min(x) \\text{Range}=\\max(x)-\\min(x) Example 5.8 (Range) For the AFL winning margins data, the maximum value is 116116, and the minimum is 00, so the range is: 116−0=𝟏𝟏𝟔116-0=\\mathbf{116} CogStat automatically calculates all these values (see Figure 5.5), so there is nothing we need to do about this, only to understand what it implies. Although the range is the simplest way to quantify the notion of variability, it’s not a fit-for-all tool. Recall from our discussion of the mean that we want our summary measure to be robust. If the data set has one or two extremely “bad” values in it (i.e., outliers), we’d like our statistics not to be unduly influenced by these cases. Example 5.9 (Range with outliers present) Let us look once again at our toy example of a data set containing very extreme outliers: −100,2,3,4,5,6,7,8,9,10 -100,2,3,4,5,6,7,8,9,10 It is clear that the range is not robust since this has a range of 110110, but if the outlier was removed, we would have a range of only 88. Quantiles Quantiles are cut points that divide an ordered data set into equal-sized groups of observations when the data is continuous. Or more generally, they cut a probability distribution to equally probable intervals. For example, a data set of 40 observations can be divided into 4 equal-sized groups of 10 observations each. This is called a quartile (i.e., 1/4). If we wanted to define in percentages, this would be able to define 25th, 50th and 75th percentiles of a data set. The 25th percentile (1st quartile or lower quartile) holds the value in a distribution that is greater than 25% of the values and less than 75% of the values. The 50th percentile (2nd quartile) is the median, and the 75th percentile (3rd quartile or upper quartile) is the value that is greater than 75% of the values and less than 25% of the values. The data can be divided into other quantiles as well: e.g. a distribution cut in 5 equal-sized groups are called quintiles, and a distribution cut in 10 equal-sized groups are called deciles, and so on. There are different methods to cutting discrete data into quantiles, but we’re not going to discuss them here. 5.2.2 Interquartile range The interquartile range (IQR) is similar to the range in terms of measuring variability, but instead of calculating the difference between the largest and smallest value, it calculates the difference between the 25th and 75th quantile, hence, somewhat minimising the effect of a few outliers. Definition 5.6 (Interquartile range) The interquartile range (IQR) is the difference between the 25th and 75th quantile of a data set. It is a measure of variability that is less sensitive to outliers than the range. CogStat provides you with both the 25th (Lower quartile) and 75th quantiles (Upper quartile) automatically: Upper quartile: 50.5 Lower quartile: 12.8 Example 5.10 (Interquartile range) We can see that the interquartile range for the 2010 AFL winning margins data is: 50.5−12.8=37.7 50.5 - 12.8 = \\mathbf{37.7} While it’s obvious how to interpret the range, it’s a little less obvious how to interpret the IQR. The simplest way to think about it is like this: the interquartile range is the range spanned by the “middle half” of the data, ignoring any data between −∞-\\infty and Q1Q_1, and between Q3Q_3 and +∞+\\infty. That is, one quarter of the data falls below the 25th percentile, one quarter of the data is above the 75th percentile, leaving the “middle half” of the data lying in between the two. And the IQR is the range covered by this middle half. Boxplots Boxplots (or “box and whiskers” plots) are a standardised method to display the distribution of a data set based on a five-number summary: the minimum and maximum (i.e., range), first quartile and third quartile (i.e., IQR), and the median. Like histograms, they’re most suited for interval or ratio scale data. Some boxplots separate out those observations that are “suspiciously” distant from the rest of the data, i.e., the outliers. These are usually displayed with a circle or a dot. 5.2.3 Mean absolute deviation (average absolute deviation) The two measures we’ve looked at so far, the range and the interquartile range, both rely on the idea that we can measure the spread of the data by looking at quantiles. However, this isn’t the only way to think about the problem. A different approach is to select some meaningful reference point (usually the mean or the median) and then report the “typical” deviations from that. In practice, this leads to two different measures, the “mean absolute deviation” (from the mean) and the “median absolute deviation” (from the median). Irritatingly, “mean absolute deviation” and “median absolute deviation” have the same acronym (i.e., MAD), which leads to a certain amount of ambiguity. What we’ll do is use AAD (average absolute deviation) for mean absolute deviation, while MAD will stand for median absolute deviation. Definition 5.7 (Average absolute deviation) The average absolute deviation (AAD) is a measure of variability calculated as the average of the absolute difference between each observation and the mean of the data set. AAD=1n∑i=1n|Xi−X‾| \\text{AAD} = \\frac{1}{n} \\sum_{i=1}^n |X_i - \\bar{X}| where nn is the number of observations, XiX_i is the iith observation, and X‾\\bar{X} is the mean of the data set. Example 5.11 (Average absolute deviation) Let’s think about our AFL winning margins data, and once again we’ll start by pretending that there’s only 5 games in total, with winning margins of 56, 31, 56, 8 and 32. Our calculations rely on an examination of the deviation from some reference point, in this case, the mean. The first thing we need to look up is the mean, X‾\\bar{X}. For these five observations, our mean is X‾=36.6\\bar{X} = 36.6. The next step is to convert each of our observations XiX_i into a deviation score. We do this by calculating the difference between the observation XiX_i and the mean X‾\\bar{X} (i.e., the deviation score: Xi−X‾X_i - \\bar{X}). Then we convert these deviations to absolute deviations. Mathematically, we would denote the absolute value of −3-3 as |−3||-3|, and so we say that |−3|=3|-3| = 3. We use the absolute value function here because we don’t care whether the value is higher than the mean or lower than the mean; we’re just interested in how close it is to the mean. To help make this process as obvious as possible, the table below shows these calculations for all five observations: Observation Symbol Observed value Deviation score Xi−X‾X_i - \\bar{X} Absolute d.s. |Xi−X‾||X_i - \\bar{X}| winning margin, game 1 X1X_1 56 points 56 - 36.6 = 19.4 19.4 winning margin, game 2 X2X_2 31 points 31 - 36.6 = -5.6 5.6 winning margin, game 3 X3X_3 56 points 56 - 36.6 = 19.4 19.4 winning margin, game 4 X4X_4 8 points 8 - 36.6 = -28.6 28.6 winning margin, game 5 X5X_5 32 points 32 - 36.6 = -4.6 4.6 Now that we have calculated the absolute deviation score for every observation in the data set, we only have to calculate the mean of these scores. Let’s do that: 19.4+5.6+19.4+28.6+4.65=15.52 \\frac{19.4 + 5.6 + 19.4 + 28.6 + 4.6}{5} = 15.52 And we’re done. The mean absolute deviation for these five scores is 15.52. Currently, AAD is not calculated in CogStat, but you can calculate this with other statistics software. When this is added, we’ll update this section. 5.2.4 Median absolute deviation The basic idea behind median absolute deviation (MAD) is identical to the one behind the mean absolute deviation (Section 5.2.3). The difference is that you use the median. This has a straightforward interpretation: every observation in the data set lies some distance away from the typical value (the median). So the MAD is an attempt to describe a typical deviation from a typical value in the data set. Definition 5.8 (Median absolute deviation) The median absolute deviation (MAD) is a measure of variability calculated as the average of the absolute difference between each observation and the median of the data set. MAD=1n∑i=1n|Xi−median(X)| \\text{MAD} = \\frac{1}{n} \\sum_{i=1}^n |X_i - \\text{median}(X)| where nn is the number of observations, XiX_i is the iith observation, and median(X)\\text{median}(X) is the median of the data set. Example 5.12 (Median absolute deviation) Let’s think about our AFL winning margins data, and once again we’ll start by pretending that there’s only 5 games in total, with winning margins of 56, 31, 56, 8 and 32. Our calculations rely on an examination of the deviation from some reference point, in this case, the median. The median for these five observations is median(X)=32\\text{median}(X) = 32. We’ll repeat the same steps as before with the mean absolute deviation, and we’ll have the following result: MAD=15(|56−32|+|31−32|+|56−32|+|8−32|+|32−32|)=19.5 \\text{MAD} = \\frac{1}{5} \\left( |56 - 32| + |31 - 32| + |56 - 32| + |8 - 32| + |32 - 32| \\right) = 19.5 5.2.5 Variance Variance isn’t all too different from the mean absolute deviation. The main difference is that we use squared deviations instead of absolute deviations. With squared deviations, we obtain a measure called variance. Definition 5.9 (Variance) Variance is a measure of variability calculated as the average of the squared difference between each observation and the mean of the data set. Var(X)=1n∑i=1n(Xi−X‾)2 \\mbox{Var}(X) = \\frac{1}{n} \\sum_{i=1}^n (X_i - \\bar{X})^2 where nn is the number of observations, XiX_i is the iith observation, and X‾\\bar{X} is the mean of the data set. Variances are additive. Suppose we have two variables (XX and YY), whose variances are Var(X)\\mbox{Var}(X) and Var(Y)\\mbox{Var}(Y) respectively. Now imagine we want to define a new variable ZZ that is the sum of the two, Z=X+YZ = X+Y. As it turns out, the variance of ZZ is equal to Var(X)+Var(Y)\\mbox{Var}(X) + \\mbox{Var}(Y). Example 5.13 (Additive property of the variance) Let’s use the first five AFL games as our data. If we follow the same approach that we took last time, we end up with the following table: Which game Value Deviation from mean Absolute squared deviation ii XiX_i Xi−X‾X_i - \\bar{X} (Xi−X‾)2(X_i - \\bar{X})^2 1 56 19.4 376.36 2 31 -5.6 31.36 3 56 19.4 376.36 4 8 -28.6 817.96 5 32 -4.6 21.16 That last column contains all of our squared deviations, so all we have to do is average them. (376.36+31.36+376.36+817.96+21.16)5=324.64 \\frac{( 376.36 + 31.36 + 376.36 + 817.96 + 21.16 )}{5} = 324.64 Let’s tackle the burning question you’re probably thinking: how do you interpret the variance? Unfortunately, the reason why we haven’t given you the human-friendly interpretation of the variance is that there really isn’t one. It does have some elegant mathematical properties that suggest that it really is a fundamental quantity for expressing variation and spread. The reason for the difficulty is that all the numbers have been squared, and they don’t necessarily mean anything in the original units. For example, if you’re running an analysis on vitamin D levels in a study about mood disorders, you’ll have a base unit of measure of nmol/L or ng/mL. If you square these numbers, you’ll end up with a variance in nmol/L-squared or ng/mL-squared. This is a meaningless unit of measure on its own. However, variance is still a good measure to indicate a spread of data, and it’s a good measure to use when comparing variances between different groups. CogStat will not attempt to interpret the variance nor will it give you the raw value. Population variance versus variance estimate If you are extremely lucky and have a data set that contains the entire population, then you can calculate the variance as given in Definition 5.9. This is called population variance. In this case the variance is denoted σ2\\sigma^2, the mean is denoted as μ\\mu. σ2=1n∑i=1n(Xi−μ)2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (X_i - \\mu)^2 In research, however, you are most likely to have gathered data for merely a sample of the population. There is an alternative formula for this case. This is called variance estimate, or estimated variance, or sample variance, or estimated population variance, and is denoted s2s^2. The formula for the variance estimate is: s2=1n−1∑i=1n(Xi−X‾)2 s^2 = \\frac{1}{n-1} \\sum_{i=1}^n (X_i - \\bar{X})^2 where nn is the number of observations in the sample, XiX_i is the iith observation, and X‾\\bar{X} is the mean of the sample. You’ll notice the difference is the denominator using n−1n-1 instead of nn. 5.2.6 Standard deviation Suppose you would like to have a measure expressed in the same units as the data itself (i.e. nmol/L, not nmol/L-squared). What should you do? The solution to the problem is obvious: take the square root of the variance, known as the standard deviation (usually shortened as SD or Std dev.), also called the root mean squared deviation, or RMSD. This solves our problem with variance fairly neatly: it’s much easier to understand “a standard deviation of 18.01 nmol/L” since it’s expressed in the original units. Definition 5.10 (Standard deviation) Standard deviation is the square root of the average of the squared difference between each observation and the mean of the data set. SD=1n∑i=1n(Xi−X‾)2 \\mbox{SD} = \\sqrt{ \\frac{1}{n} \\sum_{i=1}^n \\left( X_i - \\bar{X} \\right)^2 } So how do we interpret standard deviation? Standard deviation has the same unit of measure as the observations, e.g., nmol/L, but just like variance, it doesn’t have a simple interpretation either. The interpretation is based on the scale of the measurement. E.g. 3.5 can be big or small depending on the scale of measurement. For example, a 3.5 nmol/L SD value for vitamin D level suggests a fairly consistent measurement, considering 50-75 nmol/L is adequate, &gt;75 is optimum, and &lt;25 is deficient according to NHS UK guidelines18 in 2023. But an SD of 3.5 for a 5-level Likert scale is massive, indicating a less consistent data point and high variability. There are different ways to standardise the SD. One way is to divide the SD by the mean, which gives you the coefficient of variation (CV). Another way is by utilizing zz-scores which assumes the data are normally distributed, which is an important concept discussed in Chapter 7. We’ll discuss z-scores shortly in Chapter 5.4. Population SD versus estimated SD Similarly to variance, we can differentiate between a population-based standard deviation and a sample-based standard deviation. The population SD is denoted σ\\sigma, the mean is denoted as μ\\mu. σ=1n∑i=1n(Xi−μ)2 \\sigma = \\sqrt{ \\frac{1}{n} \\sum_{i=1}^n \\left( X_i - \\mu \\right)^2 } For calculating a population estimate based on sample data, we use the estimated standard deviation (ss) formula. s=1n−1∑i=1n(Xi−X‾)2 s = \\sqrt{ \\frac{1}{n-1} \\sum_{i=1}^n \\left( X_i - \\bar{X} \\right)^2 } where nn is the number of observations in the sample, XiX_i is the iith observation, and X‾\\bar{X} is the mean of the sample. The denominator is n−1n-1 instead of nn. 5.2.7 Which measure to use? We’ve discussed quite a few measures of spread and hinted at their strengths and weaknesses. Here’s a quick summary: Range. Gives you the full spread of the data. It’s very vulnerable to outliers, and as a consequence, it isn’t often used unless you have good reasons to care about the extremes in the data. Interquartile range. Tells you where the “middle half” of the data sits. It’s pretty robust and complements the median nicely. This is used a lot. Average absolute deviation. Tells you how far “on average” the observations are from the mean. It’s very interpretable but has a few minor issues that make it less attractive to statisticians than the standard deviation. Used sometimes, but not often. Median absolute deviation. The typical deviation from the median value. Variance. Tells you the average squared deviation from the mean. It’s mathematically elegant and is probably the “right” way to describe variation around the mean, but it’s completely uninterpretable because it doesn’t use the same units as the data. Almost never used except as a mathematical tool, but it’s buried “under the hood” of a very large number of statistical tools. Standard deviation. This is the square root of the variance. It’s fairly elegant mathematically, and it’s expressed in the same units as the data, so it can be interpreted pretty well. In situations where the mean is the measure of central tendency, this is the default. This is by far the most popular measure of variation. In short, the IQR and the standard deviation are easily the two most common measures used to report the variability of the data. Still, there are situations in which range or other measures are used. 5.3 Skewness and kurtosis There are two more descriptive statistics that you will likely see reported in the psychological literature, known as skewness and kurtosis. These are measures of the shape of the distribution of the data. Figure 5.9: An illustration of skewness. Definition 5.11 (Skewness) Skewness is a measure of assymetry of a distribution. In case of unimodal distributions, a negative skew means the median and mean are smaller than the mode, resulting in a long tail on the left; and a positive skew means the median and mean are larger than the mode, resulting in a long tail on the right. A skewness of 0 means the median and mean are equal to the mode, resulting in a symmetrical distribution. The formula for sample skewness is: skewness(X)=1Nσ̂3∑i=1N(Xi−X‾)3 \\mbox{skewness}(X) = \\frac{1}{N \\hat\\sigma^3} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^3 where NN is the number of observations in the sample, XiX_i is the iith observation, X‾\\bar{X} is the mean of the sample, and σ̂\\hat\\sigma is the sample standard deviation. As Figure 5.9 illustrates, if the data tend to have a lot of extreme small values (i.e., the lower tail is “longer” than the upper tail) and not so many extremely large values (left panel), then we say that the data are negatively skewed. On the other hand, if there are more extremely large values than extremely small ones (right panel) we say that the data are positively skewed. Not surprisingly, it turns out that the AFL winning margins data is fairly skewed: 0.80.8 (see Figure 5.5 depicting the analysis results from CogStat). Definition 5.12 (Kurtosis) Kurtosis describes the degree of steepness of a distribution. A steep distribution is leptokurtic (positive kurtosis) distribution, a flat distribution is platykurtic (negative kurtosis), and the normal distribution is mesokurtic (kurtosis is 0). kurtosis(X)=1Nσ̂4∑i=1N(Xi−X‾)4−3 \\mbox{kurtosis}(X) = \\frac{1}{N \\hat\\sigma^4} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^4 - 3 where NN is the number of observations, X‾\\bar{X} is the sample mean, and σ̂\\hat{\\sigma} is the standard deviation (the “divide by N−1N-1” version, that is). Kurtosis, put simply, is a measure of the “pointiness” of a data set, as illustrated in Figure 5.10. Figure 5.10: An illustration of kurtosis. When reading the automatically calculated kurtosis value from our CogStat result set, we discover that the AFL winning margins data is just pointy enough: 0.10.1. 5.4 Standard scores (zz-score) Suppose a friend is creating a new questionnaire to measure “grumpiness”. The survey has 50 questions, which you can answer in a grumpy way or not. Across a big sample (hypothetically, let’s imagine a million people or so!), the data are fairly normally distributed, with the mean grumpiness score being 17 out of 50 questions answered in a grumpy way and the standard deviation is 5. In contrast, when we take the questionnaire, we answer 35 out of 50 questions in a grumpy way. So, how grumpy are we? One way to think about it would be to say that we have a grumpiness of 35/50, so you might say that we’re 70% grumpy. But that’s a bit weird when you think about it. Suppose our friend had phrased her questions a bit differently. In that case, people might have answered them differently, so the overall distribution of answers could easily move up or down depending on the precise way the questions were asked. So, we’re only 70% grumpy with respect to this set of survey questions. Even if it’s an excellent questionnaire, this isn’t a very informative statement. A simpler way around this is to describe our grumpiness by comparing us to other people. Shockingly, out of a sample of 1,000,000 people, only 159 people were as grumpy as us, suggesting that we’re in the top 0.016% of people for grumpiness. This makes much more sense than trying to interpret the raw data. This idea – that we should describe our grumpiness in terms of the overall distribution of the grumpiness of humans – is the qualitative idea that standardisation attempts to get at. One way to do this is to describe everything in terms of percentiles. However, the problem with doing this is that “it’s lonely at the top”. Suppose that our friend had only collected a sample of 1000 people, and this time got a mean of 16 out of 50 with a standard deviation of 5. The problem is that, almost certainly, not a single person in that sample would be as grumpy as us. However, all is not lost. A different approach is to convert our grumpiness score into a standard score, also referred to as a zz-score. The standard score is defined as the number of standard deviations above the mean that my grumpiness score lies. To phrase it in “pseudo-maths”, the standard score is calculated like this: standard score=raw score−meanstandard deviation \\mbox{standard score} = \\frac{\\mbox{raw score} - \\mbox{mean}}{\\mbox{standard deviation}} In actual maths, the equation for the zz-score is zi=Xi−X‾σ̂ z_i = \\frac{X_i - \\bar{X}}{\\hat\\sigma} So, going back to the grumpiness data, we can now transform our raw grumpiness into a standardised grumpiness score. If the mean is 17 and the standard deviation is 5 then my standardised grumpiness score would be (in a bit simplistic way, since we haven’t discussed estimations yet): z=35−175=3.6 z = \\frac{35 - 17}{5} = 3.6 To interpret this value, recall the rough heuristic from Chapter 5.2.6: 99.7% of values are expected to lie within 3 standard deviations of the mean. So the fact that our grumpiness corresponds to a zz score of 3.6 indicates that we’re very grumpy indeed. A theoretical percentile rank for grumpiness, would be 0.99984090.9998409.19 In addition to allowing you to interpret a raw score in relation to a larger population (and thereby allowing you to make sense of variables that lie on arbitrary scales), standard scores serve a second useful function. Standard scores can be compared to one another in situations where the raw scores can’t. Suppose our friend also had another questionnaire that measured extraversion using a 24 items questionnaire. The overall mean for this measure turns out to be 13 with a standard deviation 4; and we scored a 2. As you can imagine, it doesn’t make a lot of sense to compare this raw score of 2 on the extraversion questionnaire to our raw score of 35 on the grumpiness questionnaire. The raw scores for the two variables are “about” fundamentally different things, so this would be like comparing apples to oranges. What about the standard scores? Well, this is a little different. If we calculate the standard scores, we get z=(35−17)/5=3.6z = (35-17)/5 = 3.6 for grumpiness and z=(2−13)/4=−2.75z = (2-13)/4 = -2.75 for extraversion. These two numbers can be compared to each other.20 We’d be much less extraverted than most people (z=−2.75z = -2.75) and much grumpier than most people (z=3.6z = 3.6): but the extent of our unusualness is much more extreme for grumpiness (since 3.6 is a bigger number than 2.75). Because each standardised score is a statement about where an observation falls relative to its own population, it is possible to compare standardised scores across completely different variables. Summary We have covered some key aspects of how to summarise what we have learned about the data. As a summary, the following table lists the measures that CogStat will calculate for you, with a brief explanation of what they are and how they are used. Table 5.1: Descriptives for the variable afl.margins Meaning Mean 35.3 Average – the “centre of gravity” of the data Standard deviation 26.0 How clustered is the data around the mean (smaller figure means more clustered, larger figure closer to interquartile range means more spread out) Skewness 0.8 The assymetry of the data compared to a normal distribution (bell curve) Kurtosis 0.1 Pointiness of the data. Smaller figure means more pointy, larger figure means less pointy Range 116.0 The spread of the data set between the maximum and minimum values Maximum 116.0 The highest value in the data set Upper quartile 50.5 25% of the data points reside at and above this value Median 30.5 This is the value of the data point in the middle (or the average of the two middle points in case of even number of data points). 50-50% of data points reside at above and below this value Lower quartile 12.8 25% of the data points reside at and below this value Minimum 0.0 The lowest value in the data set We also discussed zz-scores as very specific alternatives to percentiles in some cases, which will come in handy later on. Note for non-Australians: the AFL is an Australian rules football competition. You don’t need to know anything about Australian rules in order to follow this section.↩︎ medianus is Latin for “the one in the middle”, originating from the word medius, meaning “the middle”.↩︎ This is called a “0-1 loss function”, meaning that you either win (1) or you lose (0), with no middle ground.↩︎ https://www.southtees.nhs.uk/services/pathology/tests/vitamin-d/↩︎ Note that this is true given a normal distribution. More on that later.↩︎ Though some caution is usually warranted. It’s not always the case that one standard deviation on variable A corresponds to the same “kind” of thing as one standard deviation on variable B. Use common sense when trying to determine whether or not the zz scores of two variables can be meaningfully compared.↩︎ "],["correl.html", "Chapter 6 Exploring a variable pair 6.1 The strength and direction of a relationship 6.2 The correlation coefficient 6.3 Interpreting a correlation 6.4 Spearman’s rank correlations 6.5 Missing values in pairwise calculations Summary", " Chapter 6 Exploring a variable pair Up to this point, we have focused entirely on how to construct descriptive statistics for a single variable. What we have not done is talk about how to describe the relationships between variables in the data. To do that, we want to talk mainly about the correlation between variables. But first, we need some data. After watching the AFL data, let’s turn to a topic close to every parent’s heart: sleep. The following data set (parenthood.csv) is fictitious but based on real events. Suppose we’re curious to determine how much a baby’s sleeping habits affect the parent’s mood. Let’s say we can rate parent grumpiness very precisely on a scale from 0 (not at all grumpy) to 100 (very, very grumpy). And let’s also assume that we’ve been measuring parent grumpiness, parent sleeping patterns, and the baby’s sleeping patterns for 100 days. Figure 6.1: This is what you would see after loading the parenthood.csv dataset. As described in Chapter 5, we can get all the necessary descriptive statistics for all the variables: parentsleep, babysleep and grumpiness. Let’s summarise all these into a neat little table (Table 6.1). Table 6.1: Descriptive statistics for the parenthood data. Parent grumpiness Parent’s hours slept Baby’s hours slept parentgrump parentsleep babysleep Mean 63.7 6.965 8.049 Standard deviation 10 1.011 2.064 Skewness 0.4 -0.296 -0.024 Kurtosis 0 -0.649 -0.613 Range 50 4.16 8.82 Maximum 91 9 12.07 Upper quartile 71 7.74 9.635 Median 62 7.03 7.95 Lower quartile 57 6.292 6.425 Minimum 41 4.84 3.25 To start understanding the relationship between a pair of variables, select Explore relation of variable pair so a pop-up appears. Move the name of the two variables you wish to analyse from Available variables to Selected variables, then click OK. In CogStat, we can run analysis on multiple variables at once by selecting them in the variable list. This will display all analysis results after each other sequentially. We’ll be looking at sections called Sample properties from the result sets. 6.1 The strength and direction of a relationship We can draw scatterplots to give us a general sense of how closely related two variables are. Ideally, though, we might want to say a bit more about it than that. For instance, let’s compare the relationship between parentsleep and parentgrump with that between babysleep and parentgrump (Figure 6.2). Figure 6.2: Scatterplot drawn by CogStat showing the relationship between parentsleep and parentgrump and between babysleep and parentgrump When looking at these two plots side by side, it’s clear that the relationship is qualitatively the same in both cases: more sleep equals less grump! However, it’s also obvious that the relationship between parentsleep and parentgrump is stronger than between babysleep and parentgrump. The plot on the left is “neater” than on the right. It feels like if you want to predict the parent’s mood, it will help you a little bit to know how many hours the baby slept, but it’d be more helpful to know how many hours the parent slept. Scatterplots On a scatterplot graph, each observation is represented by one dot in a coordinate system. The horizontal location of the dot plots the value of the observation on one variable, and the vertical location displays its value on the other variable. Scatterplots are used often: to visualise the relationship between two variables, to identify trends, which can be further explored with regression analysis (see Chapter 14), and to detect outliers. Scatterplots can only be used with continuous variables. If you have a discrete variable, you can use a boxplot instead. Figure 6.3: Scatterplot drawn by CogStat showing the relationship between babysleep and parentsleep In contrast, let’s consider Figure 6.2 vs. Figure 6.3. If we compare the scatterplot of “babysleep v parentgrump” to the scatterplot of “`babysleep v parentsleep”, the overall strength of the relationship is the same, but the direction is different. If the baby sleeps more, the parent gets more sleep (positive relationship, but if the baby sleeps more, then the parent gets less grumpy (negative relationship). 6.2 The correlation coefficient We can make these ideas a bit more explicit by introducing the idea of a correlation coefficient (or, more specifically, Pearson’s correlation coefficient), which is traditionally denoted by rr. The correlation coefficient between two variables XX and YY (sometimes denoted rXYr_{XY}), which we’ll define more precisely shortly, is a measure that varies from −1-1 to 11. When r=−1r = -1, it means that we have a perfect negative relationship, and when r=1r = 1, it means we have a perfect positive relationship. When r=0r = 0, there’s no relationship at all. If you look at Figure 6.4, you can see several plots showing what different correlations visually look like. Figure 6.4: Illustration of the effect of varying the strength and direction of a correlation The Pearson’s correlation coefficient formula can be written in several ways. The simplest way to write down the formula is to break it into two steps. Firstly, let’s introduce the idea of a covariance. The covariance between two variables XX and YY is a generalisation of the notion of the variance. It is a mathematically simple way of describing the relationship between two variables that isn’t terribly informative to humans: Cov(X,Y)=1N−1∑i=1N(Xi−X‾)(Yi−Y‾) \\mbox{Cov}(X,Y) = \\frac{1}{N-1} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right) \\left( Y_i - \\bar{Y} \\right) Because we’re multiplying (i.e., taking the “product” of) a quantity that depends on XX by a quantity that depends on YY and then averaging21, you can think of the formula for the covariance as an “average cross product” between XX and YY. The covariance has the nice property that, if XX and YY are entirely unrelated, the covariance is exactly zero. If the relationship between them is positive (in the sense shown in Figure 6.4), then the covariance is also positive. If the relationship is negative, then the covariance is also negative. In other words, the covariance captures the basic qualitative idea of correlation. Unfortunately, the raw magnitude of the covariance isn’t easy to interpret: it depends on the units in which XX and YY are expressed, and worse yet, the actual units in which the covariance is expressed are really weird. For instance, if XX refers to the parentsleep variable (units: hours) and YY refers to the parentgrump variable (units: grumps), then the units for their covariance are “hours ×\\times grumps”. And I have no freaking idea what that would even mean. The Pearson correlation coefficient rr fixes this interpretation problem by standardising the covariance in the same way that the zz-score standardises a raw score: dividing by the standard deviation. However, because we have two variables that contribute to the covariance, the standardisation only works if we divide by both standard deviations.22 In other words, the correlation between XX and YY can be written as follows: rXY=Cov(X,Y)σ̂Xσ̂Y r_{XY} = \\frac{\\mbox{Cov}(X,Y)}{ \\hat{\\sigma}_X \\ \\hat{\\sigma}_Y} By doing this standardisation, we keep all of the nice properties of the covariance discussed earlier, and the actual values of rr are on a meaningful scale: r=1r= 1 implies a perfect positive relationship, and r=−1r = -1 implies a perfect negative relationship. 6.3 Interpreting a correlation Naturally, in real life, you don’t see many correlations of 1. So how should you interpret a correlation of, say r=.4r= .4? The honest answer is that it really depends on what you want to use the data for, and on how strong the correlations in your field tend to be. A friend of Danielle’s in engineering once argued that any correlation less than .95.95 is completely useless (he may have been exaggerating, even for engineering). On the other hand, there are real cases – even in psychology – where you should expect strong correlations. For instance, one of the benchmark data sets used to test theories of how people judge similarities is so clean that any theory that can’t achieve a correlation of at least .9.9 isn’t deemed successful. However, when looking for (say) elementary intelligence correlates (e.g., inspection time, response time), if you get a correlation above .3.3 you’re doing very well. In short, the interpretation of a correlation depends a lot on the context. That said, the rough guide in Table 6.2 is fairly typical. Table 6.2: Rough guide to interpreting correlations Correlation Strength Direction -1.0 to -0.9 Very strong Negative -0.9 to -0.7 Strong Negative -0.7 to -0.4 Moderate Negative -0.4 to -0.2 Weak Negative -0.2 to 0 Negligible Negative 0 to 0.2 Negligible Positive 0.2 to 0.4 Weak Positive 0.4 to 0.7 Moderate Positive 0.7 to 0.9 Strong Positive 0.9 to 1.0 Very strong Positive However, something that can never be stressed enough is that you should always look at the scatterplot before attaching any interpretation to the data. A correlation might not mean what you think it means. The classic illustration of this is “Anscombe’s Quartet” (Anscombe, 1973), which is a collection of four data sets. Each data set has two variables, an XX and a YY. For all four data sets, the mean value for XX is 9, and the mean for YY is 7.5. The standard deviations for all XX variables are almost identical, as are the standard deviations for the YY variables. And in each case the correlation between XX and YY is r=0.816r = 0.816. You’d think that these four data sets would look pretty similar to one another. They do not. If we draw scatterplots of XX against YY for all four variables, as shown in Figure 6.5 we see that all four of these are spectacularly different to each other. Figure 6.5: Anscombe’s quartet. All four of these data sets have a Pearson correlation of r=.816r = .816, but they are qualitatively different from one another. The lesson here, which so very many people seem to forget in real life, is “always graph your raw data”. 6.4 Spearman’s rank correlations Figure 6.6: The relationship between hours worked and grade received for a toy data set consisting of only 10 students (each circle corresponds to one student). The dashed line through the middle shows the linear relationship between the two variables. This produces a strong Pearson correlation of r=.91r = .91. However, the interesting thing to note here is that there’s actually a perfect monotonic relationship between the two variables: in this toy example, at least, increasing the hours worked always increases the grade received, as illustrated by the solid line. This is reflected in a Spearman correlation of rho=1rho = 1. With such a small data set, however, it’s an open question as to which version better describes the actual relationship involved. The Pearson correlation coefficient is useful for many things, but it has shortcomings. One particular issue stands out: what it actually measures is the strength of the linear relationship between two variables. In other words, it gives you a measure of the extent to which the data all tend to fall on a single, perfectly straight line. Often, this is a pretty good approximation to what we mean when we say “relationship”, and so the Pearson correlation is a good thing to calculate. Sometimes, it isn’t. One very common situation where the Pearson correlation isn’t quite the right thing to use arises when an increase in one variable XX really is reflected in an increase in another variable YY. However, the nature of the relationship isn’t necessarily linear. An example of this might be the relationship between effort and reward when studying for an exam. If you put zero effort (XX) into learning a subject, you should expect a grade of 0% (YY). However, a little bit of effort will cause a massive improvement: just turning up to lectures means that you learn a fair bit and if you just turn up to classes and scribble a few things down so your grade might rise to 35%, all without a lot of effort. However, you just don’t get the same effect at the other end of the scale. As everyone knows, it takes a lot more effort to get a grade of 90% than it takes to get a grade of 55%. This means that if I’ve got data looking at study effort and grades, there’s a good chance that Pearson correlations will be misleading. To illustrate, consider the data plotted in Figure 6.6, showing the relationship between hours worked and grade received for 10 students taking some classes. The curious thing about this – highly fictitious – data set is that increasing your effort always increases your grade. It might be by a lot or by a little, but increasing the effort will never decrease your grade. The data are stored in effort.csv. CogStat will calculate a standard Pearson correlation first23. It shows a strong relationship between hours worked and grade received: r=0.909r = 0.909. But this doesn’t actually capture the observation that increasing hours worked always increases the grade. There’s a sense here in which we want to say that the correlation is perfect but for a somewhat different notion of a “relationship”. What we’re looking for is something that captures the fact that there is a perfect ordinal relationship here. That is, if student 1 works more hours than student 2, then we can guarantee that student 1 will get a better grade. That’s not what a correlation of r=0.91r = 0.91 says at all. How should we address this? Actually, it’s really easy: if we’re looking for ordinal relationships, all we have to do is treat the data as if it were an ordinal scale! So, instead of measuring effort in terms of “hours worked”, let us rank all 10 of our students in order of hours worked. That is, student 1 did the least work out of anyone (2 hours), so they got the lowest rank (rank = 1). Student 4 was the next laziest, putting in only 6 hours of work over the whole semester, so they got the next lowest rank (rank = 2). Notice that we’re using “rank = 1” to mean “low rank”. Sometimes in everyday language, we talk about “rank = 1” to mean “top rank” rather than “bottom rank”. So be careful: you can rank “from smallest value to largest value” (i.e., small equals rank 1), or you can rank “from largest value to smallest value” (i.e., large equals rank 1). In this case, we’re ranking from smallest to largest. But in real life, it’s really easy to forget which way you set things up, so you have to put a bit of effort into remembering! Okay, so let’s have a look at our students when we rank them from worst to best in terms of effort and reward: Student Rank (hours worked) Rank (grade received) student 1 1 1 student 2 10 10 student 3 6 6 student 4 2 2 student 5 3 3 student 6 5 5 student 7 4 4 student 8 8 8 student 9 7 7 student 10 9 9 Hm. These are identical. The student who put in the most effort got the best grade, the student with the least effort got the worst grade, etc. We can rank students by hours worked, then rank students by grade received, and these two rankings would be identical. So if we now correlate them, we get a perfect relationship: 11. We’ve just re-invented the Spearman’s rank order correlation, usually denoted ρ\\rho (pronounced: rho) to distinguish it from the Pearson correlation rr. CogStat will use rSr_{S} to denote rank order correlation. CogStat will automatically calculate both Pearson’s correlation and Spearman’s rank order correlation for you if your measurement is not set in your source data (Figure 6.7). If you set the measurement type to “ordinal” in your source file, it will omit to calculate Pearson’s correlation due to the above reasons. Figure 6.7: This is what you would see in CogStat after loading the effort.csv dataset. 6.5 Missing values in pairwise calculations To illustrate the issues, let’s open up a data set with missing values, parenthood_missing.csv. This file contains the same data as the original parenthood data but with some values deleted. While the original source could contain an empty value or NA, CogStat will display NaN for these missing values (Figure 6.8). Figure 6.8: This is what you would see in CogStat after loading the adjusted dataset. Let’s calculate descriptive statistics using the Explore variable function (See Chapter: 5): Table 6.3: Descriptive statistics for the parenthood data with missing values. We can observe the slight difference in our statistics when we have missing values. Parent grumpiness Parent’s hours slept Baby’s hours slept parentgrump parentsleep babysleep Mean 63.2 6.977 8.114 Standard deviation 9.8 1.015 2.035 Skewness 0.4 -0.346 -0.096 Kurtosis -0.2 -0.647 -0.5 Range 48 4.16 8.82 Maximum 89 9 12.07 Upper quartile 70.2 7.785 9.61 Median 61 7.03 8.2 Lower quartile 56 6.285 6.46 Minimum 41 4.84 3.25 We can see that there are 9 missing values for parentsleep (N of missing cases: 9), 11 missing values for babysleep (N of missing cases: 11), and 8 missing values for parentgrump (N of missing cases: 8). Whichever pair you’d like to run (e.g., parentsleep vs. parentgrump), CogStat will automatically exclude the missing values from the calculation: Figure 6.9: 17 missing pairs when comparing parentsleep and parentgrump Figure 6.10: 18 missing pairs when comparing babysleep and parentgrump Figure 6.11: 20 missing pairs when comparing babysleep and parentsleep Summary In this chapter, we discussed how to measure the strength of the relationship between two variables. We introduced the concept of correlation and how to calculate it using CogStat. We also discussed the difference between Pearson’s correlation (Chapter 6.2) and Spearman’s rank order correlation (Chapter 6.4), and how CogStat will calculate it for you. Finally, we discussed how CogStat handles missing values (Chapter 6.5) in pairwise calculations. You might have been tempted to look at the regression coefficient, the linear regression formula etc. when exploring the results from CogStat. Don’t worry, you’ll have a chance to learn about these in Chapter 14. References Anscombe, F. J. (1973). Graphs in statistical analysis. American Statistician, 27, 17–21. Just like we saw with the variance and the standard deviation, in practice, we divide by N−1N-1 rather than NN.↩︎ This is an oversimplification.↩︎ Unless, of course, you set your measurement level in the second row of the CSV as \"ord\" (ordinal), because then you already tell the software that Pearson’s rr does not make sense to look at.↩︎ "],["probability.html", "Chapter 7 Probability and distributions 7.1 How are probability and statistics different? 7.2 What does probability mean? 7.3 Basic probability theory 7.4 Distributions 7.5 Summary", " Chapter 7 Probability and distributions A valuable part of statistics provides tools that let you make inferences about data. Once you start thinking about statistics in these terms – that statistics are there to help us draw inferences from data – you start seeing examples everywhere. For instance, here’s a small extract from a newspaper article in the Sydney Morning Herald (30 Oct 2010): “I have a tough job,” the Premier said in response to a poll which found her government is now the most unpopular Labor administration in polling history, with a primary vote of just 23 per cent. This kind of remark is unremarkable in the papers or in everyday life, but let’s consider what it entails. A polling company has conducted an extensive survey because they can afford it. Let’s imagine that they called 1000 NSW voters at random, and 230 (23%) of those claimed that they intended to vote for the ALP. For the 2010 Federal election, the Australian Electoral Commission reported 4,610,795 enrolled voters in NSW, so the opinions of the remaining 4,609,795 voters (about 99.98% of voters) remain unknown to us. Even assuming that no one lied to the polling company, we can only say with 100% confidence that the actual ALP primary vote is somewhere between 230/4610795 (about 0.005%) and 4610025/4610795 (about 99.83%). So, on what basis is it legitimate for the polling company, the newspaper, and the readership to conclude that the ALP primary vote is only about 23%? The answer to the question is pretty obvious: if we call 1000 people at random, and 230 of them say they intend to vote for the ALP, then it seems very unlikely that these are the only 230 people out of the entire voting public who actually intend to do so. In other words, we assume that the data collected by the polling company is pretty representative of the population at large. But how representative? Would we be surprised to discover that the true ALP primary vote is actually 24%? 29%? 37%? At this point, everyday intuition starts to break down a bit. No one would be surprised by 24%, and everybody would be surprised by 37%, but it’s hard to say whether 29% is plausible. We need more powerful tools than just looking at the numbers and guessing. Inferential statistics provides the tools we need to answer these questions. Since these questions lie at the heart of the scientific enterprise, they take up the lion’s share of every introductory course on statistics and research methods. However, the theory of statistical inference is built on top of probability theory. And it is to probability theory that we must now turn. This discussion of probability theory is basically background: there’s not a lot of statistics per se in this chapter, and you don’t need to understand this material in as much depth as in the other chapters in this part of the book. Nevertheless, because probability theory does underpin so much of statistics, it’s worth covering some of the basics. 7.1 How are probability and statistics different? Before discussing probability theory, it’s helpful to consider the relationship between probability and statistics. The two disciplines are closely related, but they’re not identical. Probability theory is “the doctrine of chances”. It’s a branch of mathematics that tells you how often different events will happen. For example, all of these questions are things you can answer using probability theory: What are the chances of a fair coin coming up heads 10 times in a row? If we roll two six-sided dice, how likely is it that we’ll roll two sixes? How likely is it that five cards drawn from a perfectly shuffled deck will all be hearts? What are the chances that we’ll win the lottery? Notice that all of these questions have something in common. In each case the “truth of the world” is known, and my question relates to the “what kind of events” will happen. In the first question, we know that the coin is fair, so there’s a 50% chance that any individual coin flip will come up heads. In the second question, we know that the chance of rolling a 6 on a single die is 1 in 6. In the third question, we know that the deck is shuffled properly. And in the fourth question, we know that the lottery follows specific rules. You get the idea. The critical point is that probabilistic questions start with a known model of the world, and we use that model to do some calculations. The underlying model can be quite simple. For instance, in the coin flipping example, we can write down the model like this: P(heads)=0.5 P(\\mbox{heads}) = 0.5 which you can read as “the probability of heads is 0.5”. As we’ll see later, in the same way, percentages are numbers that range from 0% to 100%, and probabilities are just numbers that range from 0 to 1. When using this probability model to answer the first question, we don’t know exactly what will happen. Maybe we’ll get 10 heads like the question says. But perhaps we’ll get three heads. That’s the key thing: in probability theory, the model is known, but the data are not. So that’s probability. What about statistics? Statistical questions work the other way around. In statistics, we do not know the truth about the world. All we have is the data from which we want to learn the truth about the world. Statistical questions tend to look more like these: If a friend flips a coin 10 times and gets 10 heads, are they playing a trick? If five cards off the top of the deck are all hearts, how likely is it that the deck was shuffled? If the lottery commissioner’s spouse wins the lottery, how likely is it that the lottery was rigged? This time around, the only thing we have are data. What we know is that we saw a friend flip the coin 10 times, and it came up heads every time. And what we want to infer is whether or not we should conclude that what we just saw was actually a fair coin being flipped 10 times in a row, or whether we should suspect that the friend is playing a trick on us. The data we have look like this: H H H H H H H H H H H and what we’re trying to do is work out which “model of the world” we should put my trust in. If the coin is fair, then the model we should adopt is one that says that the probability of heads is 0.5; that is, P(heads)=0.5P(\\mbox{heads}) = 0.5. If the coin is not fair, then we should conclude that the probability of heads is not 0.5, which we would write as P(heads)≠0.5P(\\mbox{heads}) \\neq 0.5. In other words, the statistical inference problem is to figure out which of these probability models is right. Clearly, the statistical question isn’t the same as the probability question, but they’re deeply connected to one another. Because of this, a good introduction to statistical theory will start with a discussion of what probability is and how it works. 7.2 What does probability mean? Let’s start with the first of these questions. What is “probability”? It might seem surprising to you, but while statisticians and mathematicians (mostly) agree on what the rules of probability are, there’s much less of a consensus on what the word really means. It seems weird because we’re all very comfortable using words like “chance”, “likely”, “possible”, and “probable”, and it doesn’t seem like it should be a complicated question to answer. If you had to explain “probability” to a five-year-old, you could do a pretty good job. But if you’ve ever had that experience in real life, you might walk away from the conversation feeling like you didn’t quite get it right and that (like many everyday concepts) it turns out that you don’t really know what it’s all about. Let’s suppose we want to bet on a soccer game between two teams of robots, Arduino Arsenal and C Milan. After thinking about it, we decide that there is an 80% probability that Arduino Arsenal winning. What do we mean by that? Here are three possibilities: They’re robot teams, so we can make them play over and over again, and if we did that, Arduino Arsenal would win 8 out of every 10 games on average. For any given game, we would only agree that betting on this game is only “fair” if a $1 bet on C Milan gives a $5 payoff (i.e. we get $1 back plus a $4 reward for being correct), as would a $4 bet on Arduino Arsenal (i.e., $4 bet plus a $1 reward). Our subjective “belief” or “confidence” in an Arduino Arsenal victory is four times as strong as our belief in a C Milan victory. Each of these seems sensible. However, they’re not identical, and not every statistician would endorse all of them. The reason is that there are different statistical ideologies (yes, really!) and depending on which one you subscribe to, you might say that some of those statements are meaningless or irrelevant. In this section, we give a brief introduction to the two main approaches that exist in the literature. These are by no means the only approaches, but they’re the two big ones. 7.2.1 The frequentist view The first of the two major approaches to probability, and the more dominant one in statistics, is referred to as the frequentist view, which defines probability as a long-run frequency. Suppose we were to try flipping a fair coin over and over again. By definition, this is a coin that has P(H)=0.5P(H) = 0.5. What might we observe? One possibility is that the first 20 flips might look like this: T,H,H,H,H,T,T,H,H,H,H,T,H,H,T,T,T,T,T,H In this case, 11 of these 20 coin flips (55%) came up heads. Now suppose that we’d been keeping a running tally of the number of heads (which we’ll call NHN_H) that we’ve seen, across the first NN flips, and calculate the proportion of heads NH/NN_H / N every time. Here’s what we’d get: Number of flips Number of heads Proportion of heads 1 0 0.00 2 1 0.50 3 2 0.67 4 3 0.75 5 4 0.80 6 4 0.67 7 4 0.57 8 5 0.63 9 6 0.67 10 7 0.70 11 8 0.73 12 8 0.67 13 9 0.69 14 10 0.71 15 10 0.67 16 10 0.63 17 10 0.59 18 10 0.56 19 10 0.53 20 11 0.55 Notice that at the start of the sequence, the proportion of heads fluctuates wildly, starting at .00 and rising as high as .80. Later on, one gets the impression that it dampens out a bit, with more and more of the values actually being pretty close to the “right” answer of .50. This is the frequentist definition of probability in a nutshell: flip a fair coin over and over again, and as NN grows large (approaches infinity, denoted N→∞N\\rightarrow \\infty), the proportion of heads will converge to 50%. There are some subtle technicalities that mathematicians care about, but qualitatively speaking, that’s how the frequentists define probability. Unfortunately, we don’t have an infinite number of coins, or the infinite patience required to flip a coin an infinite number of times. However, we do have a computer, and computers excel at mindless repetitive tasks. So let’s ask a computer to simulate flipping a coin 1000 times, and then draw a picture of what happens to the proportion NH/NN_H / N as NN increases. The results are shown in Figure 7.1. As you can see, the proportion of observed heads eventually stops fluctuating, and settles down; when it does, the number at which it finally settles is the true probability of heads. Figure 7.1: An illustration of how frequentist probability works. If you flip a fair coin over and over again, the proportion of heads that you’ve seen eventually settles down, and converges to the true probability of 0.5. Each panel shows four different simulated experiments: in each case, we pretend we flipped a coin 1000 times, and kept track of the proportion of flips that were heads as we went along. Although none of these sequences actually ended up with an exact value of .5, if we’d extended the experiment for an infinite number of coin flips they would have. The frequentist definition of probability has some desirable characteristics. Firstly, it is objective: the probability of an event is necessarily grounded in the world. The only way that probability statements can make sense is if they refer to (a sequence of) events that occur in the physical universe.24 Secondly, it is unambiguous: any two people watching the same sequence of events unfold, trying to calculate the probability of an event, must inevitably come up with the same answer. However, it also has undesirable characteristics. Firstly, infinite sequences don’t exist in the physical world. Suppose you picked up a coin from your pocket and started to flip it. Every time it lands, it impacts the ground. Each impact wears the coin down a bit; eventually, the coin will be destroyed. So, one might ask whether it really makes sense to pretend that an “infinite” sequence of coin flips is even a meaningful concept or an objective one. We can’t say that an “infinite sequence” of events is a real thing in the physical universe because the physical universe doesn’t allow infinite anything. More seriously, the frequentist definition has a narrow scope. There are many things out there that human beings are happy to assign a probability to in everyday language but cannot (even in theory) be mapped onto a hypothetical sequence of events. For instance, if a meteorologist comes on TV and says, “the probability of rain in Adelaide on 2 November 2048 is 60%”, we humans are happy to accept this. But it’s not clear how to define this in frequentist terms. There’s only one city of Adelaide, and only 2 November 2048. There’s no infinite sequence of events here, just a once-off thing. Frequentist probability genuinely forbids us from making probability statements about a single event. From the frequentist perspective, it will either rain tomorrow or not; there is no “probability” that attaches to a single non-repeatable event. Now, it should be said that there are some very clever tricks that frequentists can use to get around this. One possibility is that what the meteorologist means is something like this: “There is a category of days for which we predict a 60% chance of rain; if we look only across those days for which we make this prediction, then on 60% of those days it will actually rain”. It’s very weird and counterintuitive to think of it this way, but you do see frequentists do this sometimes. And it will come up later in this book (see Chapter 8.5). 7.2.2 The Bayesian view The Bayesian view of probability is often called the subjectivist view, and it is a minority view among statisticians but one that has been steadily gaining traction for the last several decades. There are many flavours of Bayesianism, making it hard to say what “the” Bayesian view is. The most common way of thinking about subjective probability is to define the probability of an event as the degree of belief that an intelligent and rational agent assigns to the truth of that event. From that perspective, probabilities don’t exist in the world but rather in the thoughts and assumptions of people and other intelligent beings. However, for this approach to work, we need some way of operationalising the “degree of belief”. One way you can do this is to formalise it in terms of “rational gambling”, though there are many other ways. Suppose that we believe that there’s a 60% probability of rain tomorrow. If someone offers us a bet: if it rains tomorrow, then we win $5, but if it doesn’t rain, then we lose $5. Clearly, from our perspective, this is a pretty good bet. On the other hand, if we think the probability of rain is only 40%, then it’s a bad bet. Thus, we can operationalise the notion of a “subjective probability” in terms of what bets we’re willing to accept. What are the advantages and disadvantages of the Bayesian approach? The main advantage is that it allows you to assign probabilities to any event you want to. You don’t need to be limited to those events that are repeatable. The main disadvantage (to many people) is that we can’t be purely objective – specifying a probability requires us to specify an entity with the relevant degree of belief. This entity might be a human, an alien, a robot, or even a statistician, but there has to be an intelligent agent out there that believes in things. To many people, this is uncomfortable: it seems to make probability arbitrary. While the Bayesian approach does require that the agent in question be rational (i.e., obey the rules of probability), it does allow everyone to have their own beliefs; I can believe the coin is fair, and you don’t have to, even though we’re both rational. The frequentist view doesn’t allow any two observers to attribute different probabilities to the same event: when that happens, then at least one of them must be wrong. The Bayesian view does not prevent this from occurring. Two observers with different background knowledge can legitimately hold different beliefs about the same event. In short, where the frequentist view is sometimes considered to be too narrow (forbids lots of things that that we want to assign probabilities to), the Bayesian view is sometimes thought to be too broad (allows too many differences between observers). 7.2.3 What’s the difference? And who is right? Now that you’ve seen these two views independently, it’s useful to make sure you can compare them. Go back to the hypothetical robot soccer game at the start of the section. What would a frequentist and a Bayesian say about these three statements? Which statement would a frequentist say is the correct definition of probability? Which one would a Bayesian do? Would some of these statements be meaningless to a frequentist or a Bayesian? If you’ve understood the two perspectives, you should have some sense of how to answer those questions. Okay, assuming you understand the difference, you might be wondering which of them is right? Honestly, we don’t know that there is a right answer. As far as we can tell, there’s nothing mathematically incorrect about the way frequentists think about sequences of events, and there’s nothing mathematically incorrect about the way that Bayesians define the beliefs of a rational agent. In fact, when you dig down into the details, Bayesians and frequentists actually agree about a lot of things. Many frequentist methods lead to decisions that Bayesians agree a rational agent would make. Many Bayesian methods have very good frequentist properties. Consider Sir Ronald Fisher, one of the towering figures of 20th-century statistics and a vehement opponent of all things Bayesian, whose paper on the mathematical foundations of statistics referred to Bayesian probability as “an impenetrable jungle [that] arrests progress towards precision of statistical concepts” Fisher (1922b). Or the psychologist Paul Meehl, who suggests that relying on frequentist methods could turn you into “a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring” Meehl (1967). The history of statistics, as you might gather, is not devoid of entertainment. In any case, while Danielle personally prefers the Bayesian view, the majority of statistical analyses are based on the frequentist approach. My reasoning is pragmatic: the goal of this book is to cover roughly the same territory as a typical undergraduate stats class in psychology, and if you want to understand the statistical tools used by most psychologists, you’ll need a good grasp of frequentist methods. We promise you that this isn’t a wasted effort. Even if you end up wanting to switch to the Bayesian perspective, you really should read through at least one book on the “orthodox” frequentist view. Every now and then, we’ll add some commentary from a Bayesian point of view, and we’ll revisit the topic in more depth in Chapter 15. 7.3 Basic probability theory Although there are ideological arguments between Bayesians and frequentists, it turns out that people mostly agree on the rules that probabilities should obey. There are lots of different ways of arriving at these rules. The most commonly used approach is based on the work of Andrey Kolmogorov, one of the great Soviet mathematicians of the 20th century. Without going into a lot of detail, we’ll try to give you a sense of how it works. Let’s assume we own five pairs of pants: three pairs of jeans, the bottom half of a suit, and a pair of tracksuit pants. Let’s call them X1X_1, X2X_2, X3X_3, X4X_4 and X5X_5. Now, on any given day, we pick out exactly one pair of pants. If we were to describe this situation using the language of probability theory, we would refer to each pair of pants (i.e., each XX) as an elementary event. The key characteristic of elementary events is that every time we make an observation (e.g., every time we put on a pair of pants), then the outcome will be one and only one of these events. As said, we only wear exactly one pair of pants, so it satisfies this constraint. Similarly, the set of all possible events is called a sample space. Okay, now that we have a sample space (a wardrobe) built from lots of possible elementary events (pants), we want to assign a probability of one of these elementary events. For an event XX, the probability of that event P(X)P(X) is a number that lies between 0 and 1. The bigger the value of P(X)P(X), the more likely the event will occur. So, for example, if P(X)=0P(X) = 0, it means the event XX is impossible (i.e., we never wear those pants). On the other hand, if P(X)=1P(X) = 1 it means that event XX is certain to occur (i.e., we always wear those pants). For probability values in the middle, it means that we sometimes wear those pants. For instance, if P(X)=0.5P(X) = 0.5, it means that we wear those pants half of the time. At this point, we’re almost done. The last thing we need to recognise is that “something always happens”. Every time we put on pants, we really do end up wearing pants (crazy, right?). What this somewhat trite statement means, in probabilistic terms, is that the probabilities of the elementary events need to add up to 1. This is known as the law of total probability. More importantly, if these requirements are satisfied, then we have a probability distribution. For example, this is an example of a probability distribution: Blue jeans Grey jeans Black jeans Black suit Blue tracksuit Label X1X_1 X2X_2 X3X_3 X4X_4 X5X_5 Probability P(X1)=.5P(X_1) = .5 P(X2)=.3P(X_2) = .3 P(X3)=.1P(X_3) = .1 P(X4)=0P(X_4) = 0 P(X5)=.1P(X_5) = .1 Each of the events has a probability that lies between 0 and 1, and if we add up the probability of all events, they sum to 1, as shown in Figure 7.2. And at this point, we’ve all achieved something. You’ve learned what probability distribution is. Figure 7.2: A visual depiction of the “pants” probability distribution. There are five “elementary events”, corresponding to the five pairs of pants. Each event has some probability of occurring: this probability is a number between 0 to 1. The sum of these probabilities is 1. The only other thing that needs pointing out is that probability theory allows you to talk about non-elementary events as well as elementary ones. The easiest way to illustrate the concept is with an example. In the pants example, it’s legitimate to refer to the probability that we wear jeans. In this scenario, the “We wear jeans” event is said to have happened as long as the elementary event that actually did occur is one of the appropriate ones; in this case “blue jeans”, “black jeans”, or “grey jeans”. In mathematical terms, we defined the “jeans” event EE to correspond to the set of elementary events (X1,X2,X3)(X_1, X_2, X_3). If any of these elementary events occurs, then EE is also said to have occurred. Having decided to write down the definition of the EE this way, it’s pretty straightforward to state what the probability P(E)P(E) is: we just add everything up. In this particular case P(E)=P(X1)+P(X2)+P(X3) P(E) = P(X_1) + P(X_2) + P(X_3) and, since the probabilities of blue, grey and black jeans respectively are .5, .3 and .1, the probability that we wear jeans is equal to .9. At this point, you might be thinking that this is all terribly obvious and simple, and you’d be right. All we’ve done is wrap some basic mathematics around a few common sense intuitions. However, from these simple beginnings, it’s possible to construct some extremely powerful mathematical tools. Without going into the details in this book, we list – in Table 7.1 – some of the other rules that probabilities satisfy. These rules can be derived from the simple assumptions that we’ve outlined above. Table 7.1: Some basic rules that probabilities must satisfy. You don’t really need to know these rules in order to understand the analyses that we’ll talk about later in the book, but they are important if you want to understand probability theory a bit more deeply. English Notation Formula Not AA P(¬A)P(\\neg A) = 1−P(A)1-P(A) AA or BB P(A∪B)P(A \\cup B) = P(A)+P(B)−P(A∩B)P(A) + P(B) - P(A \\cap B) AA and BB P(A∩B)P(A \\cap B) = P(A|B)P(B)P(A|B) P(B) 7.4 Distributions As you might imagine, probability distributions vary enormously, and there’s an enormous range of distributions. However, they aren’t all equally important. In fact, the vast majority of the content in this book relies on one of five distributions: the binomial distribution, the normal distribution, the tt distribution, the χ2\\chi^2 (“chi-square”) distribution and the FF distribution. Given this, the next few sections will briefly introduce all five of these, paying special attention to the binomial and the normal. 7.4.1 The binomial distribution The theory of probability originated in an attempt to describe how games of chance work. Hence, it seems fitting that our discussion of the binomial distribution should involve a discussion of rolling dice and flipping coins. Let’s imagine a simple “experiment”: we’re holding 20 identical six-sided dice. There’s a picture of a skull on one face of each die; the other five faces are all blank. If we roll all 20 dice, what’s the probability of getting exactly 4 skulls? Assuming that the dice are fair, we know that the chance of any one die coming up skulls is 1 in 6; to say this another way, the skull probability for a single die is approximately 0.1670.167. This is enough information to answer our question, so let’s have a look at how it’s done. As usual, we’ll want to introduce some names and some notation. We’ll let NN denote the number of dice rolls in our experiment, which is often referred to as the size parameter of our binomial distribution. We’ll also use θ\\theta to refer to the probability that a single die comes up skulls, a quantity that is usually called the success probability of the binomial.25 Finally, we’ll use XX to refer to the results of our experiment, namely the number of skulls we get when rolling the dice. Since the actual value of XX is due to chance, we refer to it as a random variable. In any case, now that we have all this terminology and notation, we can use it to state the problem a little more precisely. The quantity that we want to calculate is the probability that X=4X = 4 given that we know that θ=.167\\theta = .167 and N=20N=20. The general “form” of the thing could be written as P(X|θ,N) P(X \\ | \\ \\theta, N) and we’re interested in the special case where X=4X=4, θ=0.167\\theta = 0.167 and N=20N=20. There’s only one more piece of notation. If we want to say that XX is generated randomly from a binomial distribution with parameters θ\\theta and NN, the notation is as follows: X∼Binomial(θ,N) X \\sim \\mbox{Binomial}(\\theta, N) Yeah, yeah. I know what you’re thinking: notation, notation, notation. Really, who cares? Very few readers of this book are here for the notation, so we should probably move on and talk about how to use the binomial distribution. We’ve included the formula for the binomial distribution in Table 7.2, since some readers may want to play with it themselves, but since most people probably don’t care that much and because we don’t need the formula in this book, let’s not talk about it in any detail. Instead, let’s just see what the binomial distribution looks like. To that end, Figure 7.3 plots the binomial probabilities for all possible values of XX for our dice rolling experiment, from X=0X=0 (no skulls) all the way up to X=20X=20 (all skulls). Note that this is basically a bar chart, and is no different to the “pants probability” plot in Figure 7.2. On the horizontal axis we have all the possible events, and on the vertical axis we can read off the probability of each of those events. So, the probability of rolling 4 skulls out of 20 times is about 0.20 (the actual answer is 0.2022036). In other words, you’d expect that to happen about 20% of the times you repeated this experiment. Table 7.2: Formulas for the binomial and normal distributions. We don’t use these formulas for anything in this book, but they’re pretty important for more advanced work. In the equation for the binomial, X!X! is the factorial function (i.e., multiply all whole numbers from 1 to XX), and for the normal distribution “exp” refers to the exponential function, which we discussed in the Chapter on Data Handling. If these equations don’t make a lot of sense to you, don’t worry too much about them. Binomial Normal P(X|θ,N)=N!X!(N−X)!θX(1−θ)N−XP(X | \\theta, N) = \\displaystyle\\frac{N!}{X! (N-X)!} \\theta^X (1-\\theta)^{N-X} p(X|μ,σ)=12πσexp(−(X−μ)22σ2)p(X | \\mu, \\sigma) = \\displaystyle\\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp \\left( -\\frac{(X - \\mu)^2}{2\\sigma^2} \\right) Figure 7.3: The binomial distribution with size parameter of N=20N=20 and an underlying success probability of theta=1/6theta = 1/6. Each vertical bar depicts the probability of one specific outcome (i.e., one possible value of XX). Because this is a probability distribution, each of the probabilities must be a number between 0 and 1, and the heights of the bars must sum to 1 as well. 7.4.2 The normal distribution While the binomial distribution is conceptually the simplest distribution to understand, it’s not the most important one. That particular honour goes to the normal distribution, which is also referred to as “the bell curve” or “Gaussian distribution”. A normal distribution is described using two parameters, the mean of the distribution μ\\mu and the standard deviation of the distribution σ\\sigma. The notation that we sometimes use to say that a variable XX is normally distributed is as follows: X∼Normal(μ,σ) X \\sim \\mbox{Normal}(\\mu,\\sigma) Of course, that’s just notation. It doesn’t tell us anything relevant about the normal distribution itself. As was the case with the binomial distribution, the formula for the normal distribution in this book is tucked away in Table 7.2. Instead of focusing on the maths, let’s try to understand what it means for a variable to be normally distributed. To that end, have a look at Figure 7.4, which plots a normal distribution with mean μ=0\\mu = 0 and standard deviation σ=1\\sigma = 1. You can see where the name “bell curve” comes from: it looks a bit like a bell. Notice that, unlike the plots to illustrate the binomial distribution, the picture of the normal distribution in Figure 7.4 shows a smooth curve instead of “histogram-like” bars. This isn’t an arbitrary choice: the normal distribution is continuous, whereas the binomial is discrete. For instance, in the die rolling example from the last section, it was possible to get 3 skulls or 4 skulls, but impossible to get 3.9 skulls. The figures in the previous section reflected this fact: in Figure 7.3, for instance, there’s a bar located at X=3X=3 and another one at X=4X=4, but there’s nothing in between. Continuous quantities don’t have this constraint. For instance, suppose we’re talking about the weather. The temperature on a pleasant Spring day could be 23 degrees, 24 degrees, 23.9 degrees, or anything in between since temperature is a continuous variable, and so a normal distribution might be quite appropriate for describing Spring temperatures.26 Figure 7.4: The normal distribution with mean mu=0mu = 0 and standard deviation sigma=1sigma = 1. The xx-axis corresponds to the value of some variable, and the yy-axis tells us something about how likely we are to observe that value. However, notice that the yy-axis is labelled “Probability Density” and not “Probability”. There is a subtle and somewhat frustrating characteristic of continuous distributions that makes the yy axis behave a bit oddly: the height of the curve here isn’t actually the probability of observing a particular xx value. On the other hand, it is true that the heights of the curve tells you which xx values are more likely (the higher ones!). With this in mind, let’s see if we can get an intuition for how the normal distribution works. Firstly, let’s have a look at what happens when we play around with the parameters of the distribution. To that end, Figure 7.5 plots normal distributions that have different means, but have the same standard deviation. As you might expect, all of these distributions have the same “width”. The only difference between them is that they’ve been shifted to the left or to the right. In every other respect, they’re identical. In contrast, if we increase the standard deviation while keeping the mean constant, the peak of the distribution stays in the same place, but the distribution gets wider, as you can see in Figure 7.6. Notice, though, that when we widen the distribution, the height of the peak shrinks. This has to happen: in the same way that the heights of the bars that we used to draw a discrete binomial distribution have to sum to 1, the total area under the curve for the normal distribution must equal 1. Figure 7.5: An illustration of what happens when you change the mean of a normal distribution. The solid line depicts a normal distribution with a mean of mu=4mu=4. The dashed line shows a normal distribution with a mean of mu=7mu=7. In both cases, the standard deviation is sigma=1sigma=1. Not surprisingly, the two distributions have the same shape, but the dashed line is shifted to the right. Figure 7.6: An illustration of what happens when you change the the standard deviation of a normal distribution. Both distributions plotted in this figure have a mean of mu=5mu = 5, but they have different standard deviations. The solid line plots a distribution with standard deviation sigma=1sigma=1, and the dashed line shows a distribution with standard deviation sigma=2sigma = 2. As a consequence, both distributions are “centred” on the same spot, but the dashed line is wider than the solid one. Before moving on, there is one important characteristic of the normal distribution to point out. Irrespective of the actual mean and standard deviation, 68.3% of the area falls within 1 standard deviation of the mean. Similarly, 95.4% of the distribution falls within 2 standard deviations of the mean, and 99.7% of the distribution is within 3 standard deviations. This idea is illustrated in Figures 7.7 and 7.8. Figure 7.7: The area under the curve tells you the probability that an observation falls within a particular range. The solid lines plot normal distributions with mean mu=0mu=0 and standard deviation sigma=1sigma=1. The shaded areas illustrate areas under the curve for two important cases. On the left, we can see that there is a 68.3% chance that an observation will fall within one standard deviation of the mean. On the right, we see that there is a 95.4% chance that an observation will fall within two standard deviations of the mean Figure 7.8: Two more examples of the area under the curve idea. There is a 15.9% chance that an observation is one standard deviation below the mean or smaller (left), and a 34.1% chance that the observation is greater than one standard deviation below the mean but still below the mean (right). Notice that if you add these two numbers together you get 15.9% + 34.1% = 50%. For normally distributed data, there is a 50% chance that an observation falls below the mean. And of course that also implies that there is a 50% chance that it falls above the mean. 7.4.3 Probability density There’s something we missed throughout the discussion of the normal distribution, something that some introductory textbooks omit completely. Fortunately, it’s not something that you need to understand at a deep level in order to do basic statistics: rather, it’s something that starts to become important later on when you move beyond the basics. So, if it doesn’t make complete sense, don’t worry: try to make sure that you follow the gist of it. There have been one or two things that don’t quite make sense. Perhaps you noticed that the yy-axis in these figures is labelled “Probability Density” rather than density. Maybe you noticed that we used p(X)p(X) instead of P(X)P(X) when giving the formula for the normal distribution. Let us spend a little time thinking about what it really means to say that XX is a continuous variable. Let’s say we’re talking about the temperature outside. The thermometer tells me it’s 23 degrees, but we know that’s not really true. It’s not exactly 23 degrees. Maybe it’s 23.1 degrees. But we know that that’s not really true either, because it might actually be 23.09 degrees. But, we know that… well, you get the idea. The tricky thing with genuinely continuous quantities is that you never really know exactly what they are. Now think about what this implies when we talk about probabilities. Suppose that tomorrow’s maximum temperature is sampled from a normal distribution with mean 23 and standard deviation 1. What’s the probability that the temperature will be exactly 23 degrees? The answer is “zero”, or possibly, “a number so close to zero that it might as well be zero”. Why is this? It’s like trying to throw a dart at an infinitely small dart board: no matter how good your aim, you’ll never hit it. In real life, you’ll never get a value of exactly 23. It’ll always be something like 23.1 or 22.99998 or something. In other words, it’s completely meaningless to talk about the probability that the temperature is exactly 23 degrees. However, in everyday language, if we say that it was 23 degrees outside and turned out to be 22.9998 degrees, you probably wouldn’t make a fuss. Because in everyday language, “23 degrees” usually means something like “somewhere between 22.5 and 23.5 degrees”. And while it doesn’t feel very meaningful to ask about the probability that the temperature is exactly 23 degrees, it does seem sensible to ask about the probability that the temperature lies between 22.5 and 23.5, or between 20 and 30, or any other range of temperatures. The point of this discussion is to make clear that, when we’re talking about continuous distributions, it’s not meaningful to talk about the probability of a specific value. However, what we can talk about is the probability that the value lies within a particular range of values. To find out the probability associated with a particular range, what you need to do is calculate the “area under the curve”. We’ve seen this concept already: in Figure 7.7, the shaded areas shown depict genuine probabilities (e.g., in the left-hand panel of Figure 7.7, it shows the probability of observing a value that falls within 1 standard deviation of the mean). Okay, so that explains part of the story. We’ve explained a little bit about how continuous probability distributions should be interpreted (i.e., the area under the curve is the key thing), but we haven’t actually explained what the formula for p(x)p(x) actually means. Obviously, p(x)p(x) doesn’t describe a probability, but what is it? The name for this quantity p(x)p(x) is a probability density, and in terms of the plots we’ve been drawing, it corresponds to the height of the curve. The densities themselves aren’t meaningful in and of themselves: but they’re “rigged” to ensure that the area under the curve is always interpretable as genuine probabilities. To be honest, that’s about as much as you really need to know for now. For those readers who know a little calculus, let’s give a slightly more precise explanation. In the same way that probabilities are non-negative numbers that must sum to 1, probability densities are non-negative numbers that must integrate to 1 (where the integral is taken across all possible values of XX). To calculate the probability that XX falls between aa and bb we calculate the definite integral of the density function over the corresponding range, ∫abp(x)dx\\int_a^b p(x) \\ dx. If you don’t remember or never learned calculus, don’t worry about this. It’s not needed for this book. 7.4.4 Other useful distributions The normal distribution is the distribution that statistics makes the most use of (for reasons to be discussed shortly), and the binomial distribution is handy for many purposes. But the world of statistics is filled with probability distributions, some of which we’ll run into in passing. In particular, the three that will appear in this book are the tt distribution, the χ2\\chi^2 distribution and the FF distribution. We won’t give formulas for any of these or talk about them in too much detail, but we will show you some pictures. The tt distribution is a continuous distribution that looks very similar to a normal distribution but has heavier tails: see Figure 7.9. This distribution tends to arise in situations where you think that the data actually follow a normal distribution, but you don’t know the mean or standard deviation. We’ll run into this distribution again in Chapter 11. Figure 7.9: A tt distribution with 3 degrees of freedom (solid line). It looks similar to a normal distribution, but it’s not quite the same. For comparison purposes, we’ve plotted a standard normal distribution as the dashed line. Note that the “tails” of the tt distribution are “heavier” (i.e., extend further outwards) than the tails of the normal distribution? That’s the important difference between the two. The χ2\\chi^2 distribution is another distribution that turns up in lots of different places. The situation in which we’ll see it is when doing categorical data analysis (Chapter 10), but it’s one of those things that actually pops up all over the place. When you dig into the maths (and who doesn’t love doing that?), it turns out that the main reason why the χ2\\chi^2 distribution turns up all over the place is that if you have a bunch of variables that are normally distributed, square their values and then add them up (a procedure referred to as taking a “sum of squares”), this sum has a χ2\\chi^2 distribution. You’d be amazed how often this fact turns out to be useful. Anyway, here’s what a χ2\\chi^2 distribution looks like: Figure 7.10. Figure 7.10: A chi2chi^2 distribution with 3 degrees of freedom. Notice that the observed values must always be greater than zero, and that the distribution is pretty skewed. These are the key features of a chi-square distribution. The FF distribution looks a bit like a χ2\\chi^2 distribution, and it arises whenever you need to compare two χ2\\chi^2 distributions to one another. Admittedly, this doesn’t exactly sound like something that any sane person would want to do, but it turns out to be very important in real-world data analysis. Remember when we said that χ2\\chi^2 turns out to be the key distribution when we’re taking a “sum of squares”? Well, what that means is if you want to compare two different “sums of squares”, you’re probably talking about something that has an FF distribution. Of course, we still haven’t given you an example of anything involving a sum of squares, but we will in Chapter 12. And that’s where we’ll run into the FF distribution. Oh, and here’s a picture: Figure 7.11. Figure 7.11: An FF distribution with 3 and 5 degrees of freedom. Qualitatively speaking, it looks pretty similar to a chi-square distribution, but they’re not quite the same in general. They’re all continuous distributions, and they’re all closely related to the normal distribution. The key thing for our purposes, however, is not that you have a deep understanding of all these different distributions, nor that you remember the precise relationships between them. The main thing is that you grasp the basic idea that these distributions are all deeply related to one another and to the normal distribution. Later on, we’re going to run into data that are normally distributed or at least assumed to be normally distributed. What you have to understand right now is that if you make the assumption that your data are normally distributed, you shouldn’t be surprised to see χ2\\chi^2, tt and FF distributions popping up all over the place when you start trying to do your data analysis. 7.5 Summary In this chapter we’ve talked about probability. We’ve talked about what probability means, and why statisticians can’t agree on what it means. We talked about the rules that probabilities have to obey. And we introduced the idea of a probability distribution, and we spent a good portion of the chapter talking about some of the more important probability distributions that statisticians work with. The section by section breakdown looks like this: Probability theory versus statistics (Section 7.1) Frequentist versus Bayesian views of probability (Section 7.2) Basics of probability theory (Section 7.3) Binomial distribution (Section 7.4.1), normal distribution (Section 7.4.2), and others (Section 7.4.4) Many undergraduate psychology classes on statistics skim over this content very quickly, and even the more advanced courses will often “forget” to revisit the basic foundations of the field. Most academic psychologists would not know the difference between probability and density; until recently, very few would have been aware of the difference between Bayesian and frequentist probability. However, it’s essential to understand these things before moving on to the applications. For example, there are a lot of rules about what you’re “allowed” to say when making statistical inferences, and many of these can seem arbitrary and weird. However, they start to make sense if you understand this Bayesian/frequentist distinction. Similarly, in Chapter 11 we’re going to talk about something called the tt-test, and if you really want to have a grasp of the mechanics of the tt-test it really helps to have a sense of what a tt-distribution actually looks like. You get the idea. References Fisher, R. A. (1922b). On the mathematical foundation of theoretical statistics. Philosophical Transactions of the Royal Society A, 222, 309–368. Meehl, P. H. (1967). Theory testing in psychology and physics: A methodological paradox. Philosophy of Science, 34, 103–115. This doesn’t mean that frequentists can’t make hypothetical statements, of course; it’s just that if you want to make a statement about probability, then it must be possible to redescribe that statement in terms of a sequence of potentially observable events, and the relative frequencies of different outcomes that appear within that sequence.↩︎ Note that the term “success” is pretty arbitrary and doesn’t actually imply that the outcome is something to be desired. If θ\\theta referred to the probability that any one passenger gets injured in a bus crash, it is still called the success probability.↩︎ In practice, the normal distribution is so handy that people tend to use it even when the variable isn’t actually continuous. As long as there are enough categories (e.g., Likert scale responses to a questionnaire), it’s pretty standard practice to use the normal distribution as an approximation. This works out much better in practice than you’d think.↩︎ "],["estimation.html", "Chapter 8 Population, sampling, estimation 8.1 Samples, populations and sampling 8.2 The law of large numbers 8.3 Sampling distributions and the central limit theorem 8.4 Estimating population parameters 8.5 Estimating a confidence interval 8.6 Population parameter estimations in CogStat 8.7 Summary", " Chapter 8 Population, sampling, estimation As discussed in Chapter 5, the role of descriptive statistics is to concisely summarise what we do know. In contrast, inferential statistics aims to “learn what we do not know from what we do”. Now that we have a foundation in probability theory, we are in a good position to think about the problem of statistical inference. What kinds of things would we like to learn about? And how do we learn them? These questions lie at the heart of inferential statistics and are traditionally divided into two “big ideas”: estimation and hypothesis testing. The goal of this chapter is to introduce sampling theory first because, later on, estimation theory doesn’t make sense until you understand sampling. 8.1 Samples, populations and sampling All learning requires you to make assumptions. Accepting this is true, our first task is to come up with some fairly general assumptions about data that make sense. If probability theory is the foundation upon which all statistical theory builds, sampling theory is the frame around which you can build the rest of the house. It plays a massive role in specifying the assumptions upon which your statistical inferences rely. And to talk about “making inferences” the way statisticians think about it, we need to be a bit more explicit about what it is that we’re drawing inferences from (the sample) and what it is that we’re drawing inferences about (the population). In almost every situation of interest, we have a sample of data available to us as researchers. We might have run an experiment with some number of participants; a polling company might have phoned some number of people to ask questions about voting intentions; etc. Regardless: the data set available to us is finite and incomplete. We can’t possibly get every person in the world to do our experiment; a polling company doesn’t have the time or the money to ring up every voter in the country etc. In our earlier discussion of descriptive statistics (Chapter 5, this sample was the only thing we were interested in. Our only goal was to find ways of describing, summarising and graphing that sample. This is about to change. 8.1.1 Defining a population A sample is a tangible thing. You can open up a data file, and there you have data from your sample. A population, on the other hand, is a more abstract idea. It refers to the set of all possible people, or all possible observations, that you want to draw conclusions about and is generally much bigger than the sample. In an ideal world, the researcher would begin the study with a clear idea of what the population of interest is since the process of designing a study and testing hypotheses about the data that it produces does depend on the population about which you want to make statements. However, that doesn’t always happen in practice: usually, the researcher has a relatively vague idea of what the population is and designs the study as best they can on that basis. Sometimes it’s easy to state the population of interest. For instance, in the “polling company” example that opened the chapter, the population consisted of all voters enrolled at the time of the study – millions of people. The sample was a set of 1000 people belonging to that population. In most cases, the situation is much less simple. Determining the population of interest in a typical psychological experiment is a bit more complicated. Suppose we run an experiment using 100 undergraduate students as our participants. Our goal, as cognitive scientists, is to try to learn something about how the mind works. So, which of the following would count as “the population”: All of the undergraduate psychology students at the University of Adelaide? Undergraduate psychology students in general, anywhere in the world? Australians currently living? Australians of similar ages to my sample? Anyone currently alive? Any human being, past, present or future? Any biological organism with sufficient intelligence operating in a terrestrial environment? Any intelligent being? Each of these defines a real group of mind-possessing entities, all of which might be of interest, and it’s not clear which one should be the true population of interest. 8.1.2 Simple random samples Figure 8.1: Simple random sampling without replacement from a finite population Irrespective of how we define the population, the critical point is that the sample is a subset of the population. Our goal is to use our knowledge of the sample to draw inferences about the properties of the population. The relationship between the two depends on the procedure by which the sample was selected. This procedure is referred to as a sampling method, and it is important to understand why it matters. To keep things simple, let’s imagine that we have a bag containing 10 chips. Each chip has a unique letter printed on it, so we can distinguish between the 10 chips. The chips come in two colours, black and white. This set of chips is the population of interest, and it is depicted graphically on the left of Figure 8.1. As you can see from looking at the picture, there are 4 black chips and 6 white chips, but of course, in real life, we wouldn’t know that unless we looked in the bag. Now imagine you run the following “experiment”: you shake up the bag, close your eyes, and pull out 4 chips without putting any of them back into the bag. First out comes the aa chip (black), then the cc chip (white), then jj (white) and then finally bb (black). If you wanted, you could then put all the chips back in the bag and repeat the experiment, as depicted on the right-hand side of Figure 8.1. Each time you get different results, but the procedure is identical in each case. The fact that the same procedure can lead to different results each time, we refer to it as a random process.27 However, because we shook the bag before pulling any chips out, it seems reasonable to think that every chip has the same chance of being selected. A procedure in which every member of the population has the same chance of being selected is called a simple random sample. The fact that we did not put the chips back in the bag after pulling them out means that you can’t observe the same thing twice, and in such cases, the observations are said to have been sampled without replacement. To help make sure you understand the importance of the sampling procedure, consider an alternative way the experiment could have been run. Suppose a 5-year-old had opened the bag and decided to pull out four black chips without putting any of them back in the bag. This biased sampling scheme is depicted in Figure 8.2. Now consider the evidentiary value of seeing 4 black chips and 0 white chips. Clearly, it depends on the sampling scheme. If you know that the sampling scheme is biased to select only black chips, then a sample that consists of only black chips doesn’t tell you very much about the population! For this reason, statisticians really like it when a data set can be considered a simple random sample, because it makes the data analysis much easier. Figure 8.2: Biased sampling without replacement from a finite population Figure 8.3: Simple random sampling with replacement from a finite population A third procedure is worth mentioning. We close our eyes, shake the bag, and pull out a chip this time. This time, however, we record the observation and then put the chip back in the bag. Again we close our eyes, shake the bag, and pull out a chip. We then repeat this procedure until we have 4 chips. Data sets generated in this way are still simple random samples, but because we put the chips back in the bag immediately after drawing them, it is referred to as a sample with replacement. The difference between this situation and the first one is that it is possible to observe the same population member multiple times, as illustrated in Figure 8.3. Most psychology experiments tend to be sampling without replacement because the same person is not allowed to participate in the experiment twice. However, most statistical theories are based on the assumption that the data arise from a simple random sample with replacement. In real life, this very rarely matters. If the population of interest is large (e.g., has much more than 10 entities!), the difference between sampling with and without replacement is too small to be concerned with. The difference between simple random samples and biased samples, on the other hand, is not such an easy thing to dismiss. 8.1.3 Most samples are not simple random samples As you can see from the list of possible populations above, it is almost impossible to obtain a simple random sample from most populations of interest. A thorough discussion of other types of sampling schemes is beyond the scope of this book, but to give you a sense of what’s out there, here’s a list of a few of the more important ones: Stratified sampling. Suppose your population can be divided into several subpopulations, or strata. Perhaps you’re running a study at different sites, for example. Instead of trying to sample randomly from the population as a whole, you try to collect a separate random sample from each stratum. Stratified sampling is sometimes easier to do than simple random sampling, especially when the population is already divided into distinct strata. It can also be more efficient than simple random sampling, especially when some subpopulations are rare. For instance, when studying schizophrenia, it would be much better to divide the population into two28 strata (schizophrenic and not-schizophrenic), and then sample an equal number of people from each group. If you selected people randomly, you would get so few schizophrenic people in the sample that your study would be useless. This specific kind of stratified sampling is called oversampling because it deliberately attempts to over-represent rare groups. Snowball sampling is a technique that is especially useful when sampling from a “hidden” or hard-to-access population and is widespread in social sciences. For instance, suppose the researchers want to conduct an opinion poll among transgender people. The research team might only have contact details for a few trans folks, so the survey starts by asking them to participate (stage 1). At the end of the survey, the participants are asked to provide contact details for other people who might want to participate. In stage 2, those new contacts are surveyed. The process continues until the researchers have sufficient data. The advantage of snowball sampling is that it lets access data in situations that might otherwise be impossible to get any. On the statistical side, the main disadvantage is that the sample is highly non-random. On the real-life side, the disadvantage is that the procedure can be unethical if not handled well because hidden populations are often hidden for a reason. I chose transgender people as an example here to highlight this. If you weren’t careful, you might end up outing people who don’t want to be outed (very, very bad form), and even if you don’t make that mistake, it can still be intrusive to use people’s social networks to study them. It’s undoubtedly tough to get people’s informed consent before contacting them, yet in many cases, the simple act of contacting them and saying, “hi, we want to study you”, can be hurtful. Social networks are complex, and just because you can use them to get data doesn’t always mean you should. Convenience sampling is more or less what it sounds. The samples are chosen in a way that is convenient to the researcher, and not selected at random from the population of interest. Snowball sampling is one type of convenience sampling, but there are many others. A common example in psychology are studies that rely on undergraduate psychology students. These samples are generally non-random in two respects: firstly, reliance on undergraduate psychology students automatically means that your data are restricted to a single subpopulation. Secondly, the students usually get to pick which studies they participate in, so the sample is a self-selected subset of psychology students, not a randomly selected subset. In real life, most studies are convenience samples of one form or another. This is sometimes a severe limitation, but not always. 8.1.4 How much does it matter if you don’t have a simple random sample? Okay, so real-world data collection tends not to involve nice simple random samples. Does that matter? A little thought should make it clear to you that it can matter if your data are not a simple random sample: think about the difference between Figures 8.1 and 8.2. However, it’s not quite as bad as it sounds. Some types of biased samples are entirely unproblematic. For instance, when using a stratified sampling technique, you know what the bias is because you created it deliberately, often to increase the effectiveness of your study. So in those situations, it’s not a problem. Also, there are statistical techniques that you can use to adjust for the biases you’ve introduced, but they are not covered in this book. More generally, it’s important to remember that random sampling is a means to an end, not the end itself. Let’s assume you’ve relied on a convenience sample; as such, you can assume it’s biased. A bias in your sampling method is only a problem if it causes you to draw the wrong conclusions. When viewed from that perspective, I’d argue that we don’t need the sample to be randomly generated in every respect: we only need it to be random for the psychologically-relevant phenomenon of interest. Suppose we’re doing a study looking at working memory capacity. In study 1, we can sample randomly from all human beings currently alive, with one exception: we can only sample people born on a Monday. In study 2, we are able to sample randomly from the Australian population. We want to generalise my results to the population of all living humans. Which study is better? The answer, obviously, is study 1. Why? Because we have no reason to think that being “born on a Monday” has any interesting relationship to working memory capacity. In contrast, we can think of several reasons why “being Australian” might matter. Australia is a wealthy, industrialised country with a very well-developed education system. People growing up in that system will have had life experiences much more similar to the experiences of the people who designed the tests for working memory capacity. This shared experience might easily translate into similar beliefs about how to “take a test”, a shared assumption about how psychological experimentation works, and so on. These things might actually matter. For instance, the “test-taking” style might have taught the Australian participants how to direct their attention exclusively on somewhat abstract test materials relative to people who haven’t grown up in a similar environment, leading to a misleading picture of working memory capacity. There are two points hidden in this discussion. Firstly, when designing your studies, you must consider what population you care about and try hard to sample in a way appropriate to that population. In practice, you’re usually forced to put up with a “sample of convenience” (e.g., psychology lecturers sample psychology students because that’s the least expensive way to collect data, and our coffers aren’t exactly overflowing with gold). But you should at least spend some time thinking about the dangers of this practice. Secondly, if you’re criticising someone else’s study because they’ve used a sample of convenience rather than laboriously sampling randomly from the entire human population, at least have the courtesy to offer a specific theory as to how this might have distorted the results. Remember, everyone in science knows this issue and does what they can to alleviate it. Merely pointing out that “the study only included people from group BLAH” is entirely unhelpful and borders on insulting the researchers, who are, of course, aware of the issue. They just don’t happen to own the infinite supply of time and money required to construct the perfect sample. In short, if you want to offer a responsible critique of the sampling process, then be helpful. 8.1.5 Population parameters and sample statistics Let’s consider a slightly different case by setting aside the thorny methodological issues associated with obtaining a random sample and my rather unfortunate tendency to rant about lazy methodological criticism. Up to this point, we have been talking about populations the way a scientist might: a population might be a group of people to a psychologist; to an ecologist, a population might be a group of bears. In most cases, the populations that scientists care about are tangible things that exist in the real world. Statisticians are interested in real-world data and actual science the same way scientists are. On the other hand, they also operate in the realm of pure abstraction as mathematicians do. Consequently, statistical theory tends to be a bit abstract in how a population is defined. In much the same way that psychological researchers operationalise our abstract theoretical ideas in terms of concrete measurements (Section 2.1, statisticians operationalise the concept of a “population” in terms of mathematical objects that they know how to work with. You’ve already come across these objects in Chapter 7: they’re called probability distributions. The idea is quite simple. Let’s say we’re talking about IQ scores. To a psychologist, the population of interest is a group of actual humans with IQ scores. A statistician “simplifies” this by operationally defining the population as the probability distribution depicted in Figure 8.4. IQ tests are designed so that the average IQ is 100, the standard deviation of IQ scores is 15, and the distribution of IQ scores is normal. These values are referred to as the population parameters because they are characteristics of the entire population. That is, we say that the population mean μ\\mu is 100, and the population standard deviation σ\\sigma is 15. Figure 8.4: The population distribution of IQ scores. Now let us run an experiment. We select 100 people at random and administer an IQ test, giving us a simple random sample from the population. The sample would consist of a collection of numbers like this: 106 101 98 80 74 ... 107 72 100 Figure 8.5: A sample of 100 observations drawn from the population distribution of IQ scores. Each IQ score is sampled from a normal distribution with a mean of 100 and a standard deviation of 15. So if we plot a histogram of the sample, we get something like the one shown in Figure 8.5. As you can see, the histogram is roughly the proper shape, but it’s a very crude approximation to the actual population distribution shown in Figure 8.4. When calculating the mean of the sample, we get a number that is relatively close to the population mean of 100 but not identical. In this case, it turns out that the people in the sample have a mean IQ of 98.5, and the standard deviation of their IQ scores is 15.9. These sample statistics are properties of our data set, and although they are reasonably similar to the actual population values, they are not the same. In general, sample statistics are the things you can calculate from your data set, and the population parameters are the things you want to learn about. 8.2 The law of large numbers In the previous section, we discussed the results of one fictitious IQ experiment with a sample size of N=100N=100. The results were somewhat encouraging: the true population mean was 100, and the sample mean of 98.5 was a reasonable approximation. In many scientific studies, that level of precision is perfectly acceptable, but in other situations, you need to be much more precise. If we want our sample statistics to be much closer to the population parameters, what can we do about it? The obvious answer is to collect more data. Suppose that we ran a much larger experiment, this time measuring the IQs of 10,000 people. For an experiment with a sample size of n = 10000, and a population with mean = 100 and sd = 15, we get the following distribution: Figure 8.6: A sample of 10,000 observations drawn from the population distribution of IQ scores. Large samples generally give you better information. It feels silly saying it because it’s so bloody obvious that it shouldn’t need to be said. It’s such an obvious point that when Jacob Bernoulli – one of the founders of probability theory – formalised this idea back in 1713, he was kind of a jerk about it. Here’s how he described the fact that we all share this intuition: For even the most stupid of men, by some instinct of nature, by himself and without any instruction (which is a remarkable thing), is convinced that the more observations have been made, the less danger there is of wandering from one’s goal. Stigler (1986) Okay, so the passage comes across as a bit condescending (not to mention sexist), but his main point is correct: it really does feel evident that more data will give you better answers. The question is, why is this so? Not surprisingly, this intuition we all share is correct, and statisticians refer to it as the law of large numbers. The law of large numbers is a mathematical law that applies to many different sample statistics, but the simplest way to think about it is as a law about averages. The sample mean is the most obvious example of a statistic that relies on averaging (because that’s what the mean is – an average), so let’s look at that. When applied to the sample mean, the law of large numbers states that as the sample gets larger, the sample mean tends to get closer to the true population mean. Or, to say it a little bit more precisely, as the sample size “approaches” infinity (written as N→∞N \\rightarrow \\infty) the sample mean approaches the population mean (X‾→μ\\bar{X} \\rightarrow \\mu).29 You won’t be subject to proof that the law of large numbers is true, but it’s one of the most important tools for statistical theory. The law of large numbers is the thing we can use to justify our belief that collecting more and more data will eventually lead us to the truth. For any particular data set, the sample statistics that we calculate from it will be wrong, but the law of large numbers tells us that if we keep collecting more data, those sample statistics will tend to get closer and closer to the true population parameters. 8.3 Sampling distributions and the central limit theorem The law of large numbers is a potent tool, but it will not be good enough to answer all our questions. Among other things, it gives us a “long-run guarantee”. In the long run, if we could collect an infinite amount of data, then the law of large numbers guarantees that our sample statistics will be correct. But as John Maynard Keynes famously argued in economics, a long-run guarantee is of little use in real life: [The] long run is a misleading guide to current affairs. In the long run we are all dead. Economists set themselves too easy, too useless a task, if in tempestuous seasons they can only tell us, that when the storm is long past, the ocean is flat again. Keynes (1923) As in economics, so too in psychology and statistics. It is not enough to know that we will eventually arrive at the right answer when calculating the sample mean. Knowing that an infinitely large data set will tell me the exact value of the population mean is cold comfort when my actual data set has a sample size of N=100N=100. In real life, then, we must know something about the behaviour of the sample mean when it is calculated from a more modest data set! 8.3.1 Sampling distribution of the mean With this in mind, let’s abandon the idea that our studies will have sample sizes of 10000 and consider a very modest experiment indeed. This time around, we’ll sample N=5N=5 people and measure their IQ scores. 90 82 94 99 110 The mean IQ in this sample turns out to be exactly 95. Not surprisingly, this is much less accurate than the previous experiment. Now imagine that we decided to replicate the experiment. That is, we repeat the procedure as closely as possible: randomly sample 5 new people and measure their IQ. 78 88 111 111 117 This time around, the mean IQ in the sample is 101. If we repeat the experiment 10 times, we obtain the results shown in Table 8.1, and as you can see, the sample mean varies from one replication to the next. Table 8.1: Ten replications of the IQ experiment, each with a sample size of N=5N=5. Replication Person 1 Person 2 Person 3 Person 4 Person 5 Sample Mean Replication 1 90 82 94 99 110 95.0 Replication 2 78 88 111 111 117 101.0 Replication 3 111 122 91 98 86 101.6 Replication 4 98 96 119 99 107 103.8 Replication 5 105 113 103 103 98 104.4 Replication 6 81 89 93 85 114 92.4 Replication 7 100 93 108 98 133 106.4 Replication 8 107 100 105 117 85 102.8 Replication 9 86 119 108 73 116 100.4 Replication 10 95 126 112 120 76 105.8 Suppose we decided to keep going in this fashion, replicating this “five IQ scores” experiment repeatedly. Every time we replicate the experiment, we write down the sample mean. Over time, we should be amassing a new data set in which every experiment generates a single data point. The first 10 observations from the data set are the sample means listed in Table 8.1, so our data set starts out like this: 95.0 101.0 101.6 103.8 104.4 ... What if we should continue like this for 10,000 replications and then draw a histogram? As Figure 8.7 illustrates, the average of 5 IQ scores is usually between 90 and 110. But more importantly, what it highlights is that if we replicate an experiment over and over again, what we end up with is a distribution of sample means! This distribution has a particular name in statistics: the sampling distribution of the mean. Sampling distributions are another important theoretical idea in statistics, and they’re crucial for understanding the behaviour of small samples. For instance, when we ran the very first “five IQ scores” experiment, the sample mean turned out to be 95. What the sampling distribution in Figure 8.7 tells us, though, is that the “five IQ scores” experiment is not very accurate. If we repeat the experiment, the sampling distribution tells me that we can expect to see a sample mean anywhere between 80 and 120. Figure 8.7: The sampling distribution of the mean for the “five IQ scores experiment”. If you sample 5 people at random and calculate their average IQ, you’ll almost certainly get a number between 80 and 120, even though there are quite a lot of individuals who have IQs above 120 or below 80. For comparison, the black line plots the population distribution of IQ scores. 8.3.2 Sampling distributions exist for any sample statistic! One thing to remember when thinking about sampling distributions is that any sample statistic you might care to calculate has a sampling distribution. For example, suppose that each time we replicated the “five IQ scores” experiment, we wrote down the largest IQ score in the experiment. This would give us a data set that started out like this: 110 117 122 119 113 ... Doing this over and over again would give a very different sampling distribution, namely the sampling distribution of the maximum. The sampling distribution of the maximum of 5 IQ scores is shown in Figure 8.8. Not surprisingly, if you pick 5 people at random and then find the person with the highest IQ score, they’re going to have an above-average IQ. Most of the time, you’ll end up with someone whose IQ is measured in the 100 to 140 range. Figure 8.8: The sampling distribution of the maximum for the “five IQ scores experiment”. If you sample 5 people at random and select the one with the highest IQ score, you’ll probably see someone with an IQ between 100 and 140. 8.3.3 The central limit theorem Here’s an illustration of how the sampling distribution of the mean depends on the sample size. In each panel, there are 10,000 generated samples of IQ data and the mean IQ observed within each set. The histograms in these plots show the distribution of these means (i.e. the sampling distribution of the mean). Each individual IQ score was drawn from a normal distribution with mean 100 and standard deviation 15, which is shown as the solid black line). Figure 8.9: Each data set contained only a single observation, so the mean of each sample is just one person’s IQ score. As a consequence, the sampling distribution of the mean is of course identical to the population distribution of IQ scores. Figure 8.10: When we raise the sample size to 2, the mean of any one sample tends to be closer to the population mean than a one person’s IQ score, and so the histogram (i.e., the sampling distribution) is a bit narrower than the population distribution. Figure 8.11: By the time we raise the sample size to 10, we can see that the distribution of sample means tend to be fairly tightly clustered around the true population mean. At this point, you have a pretty good sense of what sampling distributions are, particularly the sampling distribution of the mean. In this section, let us talk about how the sampling distribution of the mean changes as a function of sample size. Intuitively, you already know part of the answer: if you only have a few observations, the sample mean is likely to be quite inaccurate: if you replicate a small experiment and recalculate the mean, you’ll get a very different answer. In other words, the sampling distribution is quite broad. If you replicate a large experiment and recalculate the sample mean, you’ll probably get the same answer you got last time, so the sampling distribution will narrow. You can see this visually in Figures 8.9, 8.10 and 8.11: the bigger the sample size, the narrower the sampling distribution gets. We can quantify this effect by calculating the standard deviation of the sampling distribution, which is referred to as the standard error. The standard error of a statistic is often denoted SE, and since we’re usually interested in the standard error of the sample mean, we often use the acronym SEM. As you can see just by looking at the picture, as the sample size NN increases, the SEM decreases. However, there’s something we’ve been glossing over so far. All examples up to this point have been based on the “IQ scores” experiments. And because IQ scores are roughly normally distributed, we’ve assumed that the population distribution is normal. What if it isn’t normal? What happens to the sampling distribution of the mean? The remarkable thing is this: no matter what shape your population distribution is, as NN increases the sampling distribution of the mean starts to look more like a normal distribution. To give you a sense of this, let’s run some simulations. We start with the “ramped” distribution shown in the histogram in Figure 8.12. As you can see by comparing the triangular-shaped histogram to the bell curve plotted by the black line, the population distribution doesn’t look very much like a normal distribution at all. Next, let us simulate the results of a large number of experiments. In each experiment, we draw N=2N=2 samples from this distribution and then calculate the sample mean. Figure 8.12 panel b plots the histogram of these sample means (i.e. the sampling distribution of the mean for N=2N=2). This time, the histogram produces a ∩\\cap-shaped distribution: it’s still not normal, but it’s a lot closer to the black line than the population distribution in Figure 8.12 panel a. When we increase the sample size to N=4N=4, the sampling distribution of the mean is very close to normal (Figure 8.12 panel c), and by the time we reach a sample size of N=8N=8 it’s almost perfectly normal. In other words, as long as your sample size isn’t tiny, the sampling distribution of the mean will be approximately normal no matter what your population distribution looks like! Figure 8.12: A demonstration of the central limit theorem. In the top-left panel, we have a non-normal population distribution; and the consecutive panels show the sampling distribution of the mean for samples of size 2, 4 and 8, for data drawn from the distribution in panel a. As you can see, even though the original population distribution is non-normal, the sampling distribution of the mean becomes pretty close to normal by the time you have a sample of even 4 observations. Based on these figures, it seems like we have evidence for all of the following claims about the sampling distribution of the mean: The mean of the sampling distribution is the same as the mean of the population The standard deviation of the sampling distribution (i.e., the standard error) gets smaller as the sample size increases The shape of the sampling distribution becomes normal as the sample size increases As it happens, not only are all of these statements true, there is a very famous theorem in statistics that proves all three of them, known as the central limit theorem. Among other things, the central limit theorem tells us that if the population distribution has mean μ\\mu and standard deviation σ\\sigma, then the sampling distribution of the mean also has mean μ\\mu, and the standard error of the mean is SEM=σN \\mbox{SEM} = \\frac{\\sigma}{ \\sqrt{N} } Because we divide the population standard devation σ\\sigma by the square root of the sample size NN, the SEM gets smaller as the sample size increases. It also tells us that the shape of the sampling distribution becomes normal.30 This result is useful for all sorts of things. It tells us why large experiments are more reliable than small ones, and because it gives us an explicit formula for the standard error, it tells us how much more reliable a large experiment is. It tells us why the normal distribution is, well, normal. In real experiments, many of the things that we want to measure are averages of lots of different quantities (e.g. arguably, “general” intelligence as measured by IQ is an average of a large number of “specific” skills and abilities), and when that happens, the averaged quantity should follow a normal distribution. Because of this mathematical law, the normal distribution pops up over and over again in real data. 8.4 Estimating population parameters In all the IQ examples in the previous sections, we knew the population parameters ahead of time. As every undergraduate gets taught in their first lecture on the measurement of intelligence, IQ scores are defined to have mean 100 and standard deviation 15. However, this is a bit of a lie. How do we know that IQ scores have a true population mean of 100? Well, we know this because the people who designed the tests have administered them to very large samples, and have then “rigged” the scoring rules so that their sample has mean 100. That’s not a bad thing of course: it’s an important part of designing a psychological measurement. However, it’s important to keep in mind that this theoretical mean of 100 only attaches to the population that the test designers used to design the tests. Good test designers will actually go to some lengths to provide “test norms” that can apply to lots of different populations (e.g., different age groups, nationalities etc.). This is very handy, but of course, almost every research project of interest involves looking at a different population of people to those used in the test norms. For instance, suppose you wanted to measure the effect of low-level lead poisoning on cognitive functioning in Port Pirie, a South Australian industrial town with a lead smelter. Perhaps you decide that you want to compare IQ scores among people in Port Pirie to a comparable sample in Whyalla, a South Australian industrial town with a steel refinery.31 Regardless of which town you’re thinking about, it doesn’t make a lot of sense simply to assume that the true population mean IQ is 100. No one has produced sensible norming data that can automatically be applied to South Australian industrial towns. We’re going to have to estimate the population parameters from a sample of data. So how do we do this? 8.4.1 Estimating the population mean Suppose we go to Port Pirie and 100 of the locals are kind enough to sit through an IQ test. The average IQ score among these people turns out to be X‾=98.5\\bar{X}=98.5. So what is the true mean IQ for the entire population of Port Pirie? Obviously, we don’t know the answer to that question. It could be 97.297.2, but if could also be 103.5103.5. Our sampling isn’t exhaustive so we cannot give a definitive answer. Nevertheless if I was forced at gunpoint to give a “best guess” I’d have to say 98.598.5. That’s the essence of statistical estimation: giving a best guess. In this example, estimating the unknown poulation parameter is straightforward. We calculate the sample mean, and we use that as the estimate of the population mean. It’s pretty simple, and in the next section we’ll explain the statistical justification for this intuitive answer. However, for the moment what we want to do is make sure you recognise that the sample statistic and the estimate of the population parameter are conceptually different things. A sample statistic is a description of your data, whereas the estimate is a guess about the population. While some statistics softwares don’t make this distinction, CogStat does. In the result sets, you’ll see different sections detailing measures for the sample and the population. Statisticians often different notation to refer to them. For instance, if true population mean is denoted μ\\mu, then we would use μ̂\\hat\\mu to refer to our estimate of the population mean. In contrast, the sample mean is denoted X‾\\bar{X} or sometimes mm. However, in simple random samples, the estimate of the population mean is identical to the sample mean: if we observe a sample mean of X‾=98.5\\bar{X} = 98.5, then our estimate of the population mean is also μ̂=98.5\\hat\\mu = 98.5. To help keep the notation clear, here’s a handy table: Table 8.2: Notation for sample statistics and estimates of population parameters. Symbol What is it Do we know what it is X‾\\bar{X} Sample mean Yes calculated from the raw data μ\\mu True population mean Almost never known for sure μ̂\\hat{\\mu} Estimate of the population mean Yes identical to the sample mean 8.4.2 Estimating the population standard deviation So far, estimation seems pretty simple, and you might wonder why you must read through all that stuff about sampling theory. In the case of the mean, our estimate of the population parameter (i.e. μ̂\\hat\\mu) turned out to be identical to the corresponding sample statistic (i.e. X‾\\bar{X}). However, that’s not always true. To see this, let’s construct an estimate of the population standard deviation, which we’ll denote σ̂\\hat\\sigma. What shall we use as our estimate in this case? Your first thought might be that we could do the same thing we did when estimating the mean and just use the sample statistic as our estimate. That’s almost the right thing to do, but not quite. Here’s why: Suppose we have a sample that contains a single observation. For this example, it helps to consider a sample where you have no intuitions about the true population values, so let’s use something completely fictitious. Suppose the observation in question measures the cromulence32 of a shoe. It turns out that this shoe has a cromulence of 20. So here’s our sample: 20 This is a legitimate sample, even if it has a sample size of N=1N=1. It has a sample mean of 20, and because every observation in this sample is equal to the sample mean (obviously!), it has a sample standard deviation of 0. As a description of the sample this seems quite right: the sample contains a single observation, and therefore there is no variation observed within the sample. A sample standard deviation of s=0s = 0 is the right answer here. But as an estimate of the population standard deviation, it feels completely insane, right? Admittedly, we don’t know anything at all about what “cromulence” is, but we know something about data: the only reason that we don’t see any variability in the sample is that the sample is too small to display any variation! So, if you have a sample size of N=1N=1, it feels like the right answer is just to say “no idea at all”. Notice that you don’t have the same intuition regarding the sample mean and the population mean. If forced to make the best guess about the population mean, it doesn’t feel completely insane to guess that the population mean is 20. Sure, you probably wouldn’t feel very confident in that guess because you have only one observation to work with, but it’s still the best guess you can make. Let’s extend this example a little. Suppose we now make a second observation. The data set now has N=2N=2 observations of the cromulence of shoes, and the complete sample now looks like this: 20 22 This time around, our sample is just large enough for us to observe some variability: two observations is the bare minimum number needed for any variability to be observed! For our new data set, the sample mean is X‾=21\\bar{X}=21, and the sample standard deviation is s=1s=1. What intuitions do we have about the population? Again, as far as the population mean goes, the best guess we can possibly make is the sample mean: if forced to guess, we’d probably say that the population mean cromulence is 21. What about the standard deviation? This is a little more complicated. The sample standard deviation is only based on two observations, and if you’re at all like me you probably have the intuition that, with only two observations, we haven’t given the population “enough of a chance” to reveal its true variability to us. It’s not just that we suspect that the estimate is wrong: after all, with only two observations, we expect it to be wrong to some degree. The worry is that the error is systematic. Specifically, we suspect that the sample standard deviation is likely to be smaller than the population standard deviation. Figure 8.13: The sampling distribution of the sample standard deviation for a “two IQ scores” experiment. The true population standard deviation is 15 (dashed line), but as you can see from the histogram, the vast majority of experiments will produce a much smaller sample standard deviation than this. On average, this experiment would produce a sample standard deviation of only 8.5, well below the true value! In other words, the sample standard deviation is a biased estimate of the population standard deviation. This intuition feels right, but it would be nice to demonstrate this somehow. There are, in fact, mathematical proofs that confirm this intuition, but unless you have the right mathematical background, they don’t help very much. With that in mind, let’s return to our IQ studies. Suppose the actual population mean IQ is 100 and the standard deviation is 15. Let’s measure N=2N=2 IQ scores and calculate the sample standard deviation. If we do this repeatedly and plot a histogram of these sample standard deviations, we have the sampling distribution of the standard deviation (Figure 8.13). Even though the true population standard deviation is 15, the average of the sample standard deviations is only 8.5. Notice that this is a very different result from what we found in Figure 8.10 when we plotted the sampling distribution of the mean. If you look at that sampling distribution, what you see is that the population mean is 100, and the average of the sample means is also 100. Now let’s extend the simulation. Instead of restricting ourselves to the situation where we have a sample size of N=2N=2, let’s repeat the exercise for sample sizes from 1 to 10. If we plot the average sample mean and average sample standard deviation as a function of sample size, you get the results shown in Figure 8.14. On the left side (panel a), you see the average sample mean, and on the right (panel b), the average standard deviation. The two plots are quite different: on average, the average sample mean is equal to the population mean. It is an unbiased estimator, which is essentially why your best estimate for the population mean is the sample mean.33 The plot on the right is quite different: on average, the sample standard deviation ss is smaller than the population standard deviation σ\\sigma. It is a biased estimator. In other words, if we want to make a “best guess” σ̂\\hat\\sigma about the value of the population standard deviation σ\\sigma, we should make sure our guess is a little bit larger than the sample standard deviation ss. Figure 8.14: An illustration of the fact that the sample mean is an unbiased estimator of the population mean (panel a). Still, the sample standard deviation is a biased estimator of the population standard deviation (panel b). To generate the figure, we have 10,000 simulated data sets with 1 observation each, 10,000 more with 2 observations, and so on up to a sample size of 10. Each data set consisted of fake IQ data: the data were normally distributed with a true population mean of 100 and standard deviation 15. On average, the sample means turn out to be 100, regardless of sample size (panel a). However, the sample standard deviations turn out to be systematically too small (panel b), especially for small sample sizes. The fix to this systematic bias turns out to be very simple. Here’s how it works. Before tackling the standard deviation, let’s look at the variance. If you recall from Chapter 5.2, the sample variance is defined as the average squared deviations from the sample mean. That is: s2=1N∑i=1N(Xi−X‾)2 s^2 = \\frac{1}{N} \\sum_{i=1}^N (X_i - \\bar{X})^2 The sample variance s2s^2 is a biased estimator of the population variance σ2\\sigma^2. But as it turns out, we only need to make a tiny tweak to transform this into an unbiased estimator. All we have to do is divide by N−1N-1 rather than by NN. If we do that, we obtain the following formula: σ̂2=1N−1∑i=1N(Xi−X‾)2 \\hat\\sigma^2 = \\frac{1}{N-1} \\sum_{i=1}^N (X_i - \\bar{X})^2 This is an unbiased estimator of the population variance σ\\sigma, and why statistics software functions prefer σ̂2\\hat\\sigma^2, not s2s^2 when calculating variance. A similar story applies to the standard deviation. If we divide by N−1N-1 rather than NN, our estimate of the population standard deviation becomes: σ̂=1N−1∑i=1N(Xi−X‾)2 \\hat\\sigma = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (X_i - \\bar{X})^2} and when using statistics software, they calculate σ̂\\hat\\sigma, not ss.34 One final point: in practice, many people refer to σ̂\\hat{\\sigma} (i.e. the formula where we divide by N−1N-1) as the sample standard deviation. Technically, this is incorrect: the sample standard deviation should be equal to ss (i.e. the formula where we divide by NN). These aren’t the same thing, either conceptually or numerically. One is a property of the sample, and the other is an estimated characteristic of the population. However, in almost every real-life application, what we care about is the estimate of the population parameter, and so people always report σ̂\\hat\\sigma rather than ss. This is the right number to report, of course. People tend to get a little bit imprecise about terminology when they write it up because “sample standard deviation” is shorter than “estimated population standard deviation”. It’s no big deal, and in practice, many do the same thing everyone else does. Nevertheless, it’s important to keep the two concepts separate: it’s never a good idea to confuse “known properties of your sample” with “guesses about the population from which it came”. The moment you start thinking that ss and σ̂\\hat\\sigma are the same things, you start doing exactly that. To finish this section off, here’s another couple of tables to help keep things clear: Symbol What is it? Do we know what it is? ss Sample standard deviation Yes - calculated from the raw data σ\\sigma Population standard deviation Almost never known for sure σ̂\\hat{\\sigma} Estimate of the population standard deviation Yes - but not the same as the sample standard deviation s2s^2 Sample variance Yes - calculated from the raw data σ2\\sigma^2 Population variance Almost never known for sure σ̂2\\hat{\\sigma}^2 Estimate of the population variance Yes - but not the same as the sample variance 8.5 Estimating a confidence interval Up to this point in this chapter, we’ve outlined the basics of sampling theory which statisticians rely on to make guesses about population parameters based on a sample of data. As this discussion illustrates, one of the reasons we need all this sampling theory is that every data set leaves us with some uncertainty, so our estimates are never going to be perfectly accurate. The thing missing from this discussion is an attempt to quantify the amount of uncertainty that attaches to our estimate. It’s not enough to guess that the mean IQ of undergraduate psychology students is, say, 115. We also want to be able to say something that expresses the degree of certainty that we have in our guess. For example, it would be nice to say that there is a 95% chance that the true mean lies between 109 and 121. The name for this is a confidence interval for the mean. Armed with an understanding of sampling distributions, constructing a confidence interval for the mean is quite easy. Suppose the true population mean is μ\\mu and the standard deviation is σ\\sigma. Our study has NN participants whose mean IQ is X‾\\bar{X}. We know from our discussion of the central limit theorem (Section 8.3.3) that the sampling distribution of the mean is approximately normal. We also know from our discussion of the normal distribution (Section 7.4.2) that there is a 95% chance that a normally-distributed quantity will fall within two standard deviations of the true mean. To be more precise, between −1.959964-1.959964 and 1.9599641.959964, meaning the 2.5th and 97.5th percentiles of the normal distribution. So the more correct answer is that there is a 95% chance that a normally-distributed quantity will fall within 1.96 standard deviations of the true mean. Next, recall that the standard deviation of the sampling distribution is referred to as the standard error, and the standard error of the mean is written as SEM. When we put all these pieces together, we learn that there is a 95% probability that the sample mean X‾\\bar{X} that we have actually observed lies within 1.96 standard errors of the population mean. Mathematically, we write this as: μ−(1.96×SEM)≤X‾≤μ+(1.96×SEM) \\mu - \\left( 1.96 \\times \\mbox{SEM} \\right) \\ \\leq \\ \\bar{X}\\ \\leq \\ \\mu + \\left( 1.96 \\times \\mbox{SEM} \\right) where the SEM is equal to σ/N\\sigma / \\sqrt{N}, and we can be 95% confident that this is true. However, that’s not answering the question that we’re actually interested in. The equation above tells us what we should expect about the sample mean, given that we know the population parameters. What we want is to have this work the other way around: we want to know what we should believe about the population parameters, given that we have observed a particular sample. However, it’s not too difficult to do this. Using a little high school algebra, a sneaky way to rewrite our equation is like this: X‾−(1.96×SEM)≤μ≤X‾+(1.96×SEM) \\bar{X} - \\left( 1.96 \\times \\mbox{SEM} \\right) \\ \\leq \\ \\mu \\ \\leq \\ \\bar{X} + \\left( 1.96 \\times \\mbox{SEM}\\right) What this is telling is that the range of values has a 95% probability of containing the population mean μ\\mu. We refer to this range as a 95% confidence interval, denoted CI95\\mbox{CI}_{95}. In short, as long as NN is sufficiently large – large enough for us to believe that the sampling distribution of the mean is normal – then we can write this as our formula for the 95% confidence interval: CI95=X‾±(1.96×σN) \\mbox{CI}_{95} = \\bar{X} \\pm \\left( 1.96 \\times \\frac{\\sigma}{\\sqrt{N}} \\right) Of course, there’s nothing special about the number 1.96: it just happens to be the multiplier you need to use if you want a 95% confidence interval. If I’d wanted a 70% confidence interval, you have to calculate the 15th and 85th quantiles of the normal distribution, which are −1.036433-1.036433 and 1.0364331.036433. So the formula for CI70\\mbox{CI}_{70} would be the same as the formula for CI95\\mbox{CI}_{95} except that we’d use 1.04 as our magic number rather than 1.96. 8.5.1 A slight mistake in the formula The formula above for the 95% confidence interval is approximately correct, but we glossed over an important detail in the discussion. Notice that it requires you to use the standard error of the mean, SEM, which in turn requires you to use the true population standard deviation σ\\sigma. Yet, in Chapter 8.4, we stressed the fact that we don’t actually know the true population parameters. Because we don’t know the true value of σ\\sigma, we have to use an estimate of the population standard deviation σ̂\\hat{\\sigma} instead. This is pretty straightforward to do, but this has the consequence that we need to use the quantiles of the tt-distribution rather than the normal distribution to calculate our magic number. And the answer depends on the sample size. When NN is very large, we get roughly the same value using tt-distribution that we would if we used a normal distribution. But when NN is small, we get a much bigger number when we use the tt distribution. Table 8.3: 97.5th percentile. Sample size Normal distribution tt-distribution N=10000N=10000 1.9599641.959964 1.9602011.960201 N=10N=10 1.9599641.959964 2.2621572.262157 There’s nothing too mysterious about what’s happening here. Bigger values mean that the confidence interval is wider, indicating that we’re more uncertain about the true value of μ\\mu. When we use the tt-distribution instead of the normal distribution, we get bigger numbers, indicating that we have more uncertainty. And why do we have that extra uncertainty? Well, because our estimate of the population standard deviation σ̂\\hat\\sigma might be wrong. And if it is wrong, it implies that we are a bit less sure about what our sampling distribution of the mean actually looks like. This uncertainty ends up getting reflected in a wider confidence interval. 8.5.2 Interpreting a confidence interval The hardest thing about confidence intervals is understanding what they mean. Whenever people first encounter confidence intervals, the first instinct is almost always to say that “there is a 95% probability that the true mean lies inside the confidence interval”. It’s simple, and it seems to capture the common sense idea of what it means to say that I am “95% confident”. Unfortunately, it’s not quite right. The intuitive definition relies very heavily on your personal beliefs about the value of the population mean. “I am 95% confident because those are my beliefs.” In everyday life, that’s perfectly okay, but if you remember back to Chapter 7.2, you’ll notice that talking about personal belief and confidence is a Bayesian idea. Speaking as a Bayesian, there is no problem with the idea that the phrase “95% probability” is allowed to refer to a personal belief. However, confidence intervals are not Bayesian tools. Like everything else in this chapter, confidence intervals are frequentist tools. And if you use frequentist methods, then it’s not appropriate to attach a Bayesian interpretation to them. If you use frequentist methods, you must adopt frequentist interpretations. Figure 8.15: 95% confidence intervals. The top (panel a) shows 50 simulated replications of an experiment in which we measure the IQs of 10 people. The dot marks the location of the sample mean, and the line shows the 95% confidence interval. In total 47 of the 50 confidence intervals do contain the true mean (i.e., 100), but the three intervals marked with asterisks do not. The lower graph (panel b) shows a similar simulation, but this time we simulate replications of an experiment that measures the IQs of 25 people. The critical difference here is that the Bayesian claim makes a probability statement about the population mean (i.e. it refers to our uncertainty about the population mean), which is not allowed under the frequentist interpretation of probability because you can’t “replicate” a population. In the frequentist claim, the population mean is fixed, and no probabilistic claims can be made about it. Confidence intervals, however, are repeatable, so we can replicate experiments. Therefore a frequentist is allowed to talk about the probability that the confidence interval (a random variable) contains the true mean; but is not allowed to talk about the probability that the true population mean (not a repeatable event) falls within the confidence interval. This might seem a little pedantic, but it does matter. It matters because the difference in interpretation leads to a difference in mathematics. There is a Bayesian alternative to confidence intervals, known as credible intervals. In most situations, credible intervals are quite similar to confidence intervals, but in other cases, they are drastically different. We’ll talk more about the Bayesian perspective in Chapter 15. 8.6 Population parameter estimations in CogStat With CogStat, you don’t have to worry about calculating confidence intervals by hand. The program does it for you. In the following example, we’ll use the same data sets as in the previous sections. But this time, we’ll see how CogStat calculates the 95% confidence interval parameters for both the mean and the standard deviation. So, for example, let us load the afl24.csv file and explore the attendance variable with the Explore variable tool. Figure 8.16: Sample properties for attendance CogStat gives you the sample properties as discussed in Chapter 5, but it also gives the population parameter estimations. The estimates for the population mean and standard deviation are calculated automatically at 95% confidence interval level. Figure 8.17: Population parameter estimates for attendance 8.7 Summary In this chapter, we’ve covered two main topics. The first half of the chapter talks about sampling theory, and the second half talks about how we can use sampling theory to construct estimates of the population parameters. The section breakdown looks like this: Basic ideas about samples, sampling and populations (Section 8.1) Statistical theory of sampling: the law of large numbers (Section 8.2), sampling distributions and the central limit theorem (Section 8.3). Estimating means and standard deviations (Section 8.4) Estimating a confidence interval (Section 8.5) As always, there are a lot of topics related to sampling and estimation that aren’t covered in this book, but for an introductory psychology class, this is fairly comprehensive. For most applied researchers, you won’t need much more theory than this. One big question we haven’t discussed in this chapter is what you do when you don’t have a simple random sample. There is a lot of statistical theory you can draw on to handle this situation, but it’s well beyond the scope of this book. References Keynes, J. M. (1923). A tract on monetary reform. Macmillan; Company. Merriam-Webster. (2022). Petrichor, cromulent, and other words the internet loves. https://www.merriam-webster.com/words-at-play/internets-favorite-words Stigler, S. M. (1986). The history of statistics. Harvard University Press. The proper mathematical definition of randomness is extraordinarily technical and way beyond the scope of this book. We’ll be non-technical here and say that a process has an element of randomness to it whenever it is possible to repeat it and get different answers each time.↩︎ Nothing in life is that simple: there’s not an obvious division of people into binary categories like “schizophrenic” and “not schizophrenic”. But this isn’t a clinical psychology text, so please forgive a few simplifications here and there.↩︎ Technically, the law of large numbers pertains to any sample statistic that can be described as an average of independent quantities. That’s certainly true for the sample mean. However, it’s also possible to write many other sample statistics as averages of one form or another. The variance of a sample, for instance, can be rewritten as an average and so is subject to the law of large numbers. The minimum value of a sample, however, cannot be written as an average of anything and is therefore not governed by the law of large numbers.↩︎ As usual, we’re being a bit sloppy here. The central limit theorem is a bit more general than this section implies. Like most introductory stats texts, we have discussed one situation where the central limit theorem holds: when you’re taking an average across lots of independent events drawn from the same distribution. However, the central limit theorem is much broader than this. There’s a whole class of things called “UU-statistics”, all of which satisfy the central limit theorem and therefore become normally distributed for large sample sizes. The mean is one such statistic, but it’s not the only one.↩︎ Please note that if you were actually interested in this question, you would need to be a lot more careful than we are being here. You can’t simply compare IQ scores in Whyalla to Port Pirie and assume that any differences are due to lead poisoning. Even if it were true that the only differences between the two towns corresponded to the different refineries (and it isn’t, not by a long shot), you need to account for the fact that people already believe that lead pollution causes cognitive deficits: if you recall back to Chapter 2, this means that there are different demand effects for the Port Pirie sample than for the Whyalla sample. In other words, you might end up with an illusory group difference in your data, caused by the fact that people think that there is a real difference. It is pretty implausible to think that the locals wouldn’t be well aware of what you were trying to do if a bunch of researchers turned up in Port Pirie with lab coats and IQ tests, and even less plausible to think that a lot of people would be pretty resentful of you for doing it. Those people won’t be as cooperative in the tests. Other people in Port Pirie might be more motivated to do well because they don’t want their home town to look bad. The motivational effects that would apply in Whyalla are likely to be weaker because people don’t have any concept of “iron ore poisoning” in the same way that they have a concept for “lead poisoning”. Psychology is hard.↩︎ The word cromulent was invented in a Simpsons episode in 1996 and, based on its context, might mean “possible”, “acceptable”, or “fine” according to Merriam-Webster (2022). However, the whole point here is, we don’t really know what it is.↩︎ Unbiasedness is a desirable characteristic for an estimator, but there are other things that matter besides bias. However, it’s beyond the scope of this book to discuss this in any detail. Just note that there’s some hidden complexity here.↩︎ While σ̂2\\hat\\sigma^2 is an unbiased estimate of the population variance σ2\\sigma^2, when you take the square root, it turns out that σ̂\\hat\\sigma is a biased estimator of the population standard deviation σ\\sigma. So, why is σ̂\\hat\\sigma biased? The technical answer is “because non-linear transformations (e.g. the square root) don’t commute with expectation”, but that just sounds like gibberish to everyone who hasn’t taken a course in mathematical statistics. Fortunately, it doesn’t matter for practical purposes. The bias is so small, and in real life, everyone uses σ̂\\hat\\sigma, and it works just fine. Sometimes mathematics is just annoying.↩︎ "],["hypothesistesting.html", "Chapter 9 Hypothesis testing 9.1 A menagerie of hypotheses 9.2 Two types of errors 9.3 Test statistics and sampling distributions 9.4 Making decisions 9.5 The pp value of a test 9.6 Reporting the results of a hypothesis test 9.7 Effect size, sample size and power 9.8 Some issues to consider 9.9 Summary", " Chapter 9 Hypothesis testing In Chapter 8, we discussed the ideas behind estimation, which is one of the two “big ideas” in inferential statistics. It’s now time to turn out attention to the other big idea, which is hypothesis testing. In its most abstract form, hypothesis testing is really a very simple idea: the researcher has some theory about the world and wants to determine whether or not the data actually support that theory. However, the details are messy, and most people find the theory of hypothesis testing to be the most frustrating part of statistics. The structure of the chapter is as follows. Firstly, we’ll talk about how hypothesis testing works in a fair amount of detail, using a simple running example to show you how a hypothesis test is “built”. We’ll focus on the underlying logic of the testing procedure rather than being too dogmatic about it. Afterwards, we’ll spend a bit of time talking about the dogmas, rules and heresies surrounding the hypothesis testing theory. 9.1 A menagerie of hypotheses Eventually, we all succumb to madness. Let’s suppose that this glorious day has come, and we indulge in a most thoroughly unproductive line of psychological research: the search for extrasensory perception (ESP).35 Our first study is a simple one in which we seek to test whether clairvoyance exists. Each participant sits down at a table and is shown a card by an experimenter. The card is black on one side and white on the other. The experimenter takes the card away and places it on a table in an adjacent room. The card is placed black side up or white side up entirely at random, with the randomisation occurring after the experimenter has left the room with the participant. A second experimenter comes in and asks the participant which side of the card is now facing upwards. It’s purely a one-shot experiment. Each person sees only one card and gives only one answer. At no stage is the participant in contact with someone who knows the correct answer. The data set, therefore, is very simple. We have asked the question of, say, N=100N = 100 people and X=62X = 62 of these people have given the correct response. It’s a surprisingly large number, sure, but is it large enough for us to feel safe in claiming we’ve found evidence for ESP? This is the situation where hypothesis testing comes in useful. However, before we talk about how to test hypotheses, we need to be clear about what we mean by hypotheses. 9.1.1 Research hypotheses versus statistical hypotheses The first distinction that you need to keep clear in your mind is between research hypotheses and statistical hypotheses. In our ESP study, the overall scientific goal is to demonstrate that clairvoyance exists. In this situation, we have a clear research goal: we are hoping to discover evidence for ESP. In other cases, we might be a lot more neutral than that, so we might say our goal is to determine whether or not clairvoyance exists. Regardless of how we want to portray it, the basic point that we’re trying to convey here is that a research hypothesis involves making a substantive, testable scientific claim. If you are a psychologist, your research hypotheses are fundamentally about psychological constructs. Any of the following would count as research hypotheses: Listening to music reduces your ability to pay attention to other things. This is a claim about the causal relationship between two psychologically meaningful concepts (listening to music and paying attention to things), so it’s a perfectly reasonable research hypothesis. Intelligence is related to personality. Like the last one, this is a relational claim about two psychological constructs (intelligence and personality), but the claim is weaker: correlational, not causal. Intelligence is the speed of information processing. This hypothesis has quite a different character: it’s not a relational claim at all. It’s an ontological claim about the fundamental character of intelligence. It’s worth expanding on this one actually: It’s usually easier to think about how to construct experiments to test research hypotheses of the form “does X affect Y?” than it is to address claims like “what is X?” And in practice, what usually happens is that you find ways of testing relational claims that follow from your ontological ones. For instance, if we believe that intelligence is the speed of information processing in the brain, our experiments will often involve looking for relationships between measures of intelligence and measures of speed. Consequently, most everyday research questions tend to be relational in nature, but they’re almost always motivated by deeper ontological questions about the state of nature. Notice that in practice, our research hypotheses could overlap a lot. The ultimate goal in the ESP experiment might be to test an ontological claim like “ESP exists”. But we might operationally restrict ourselves to a narrower hypothesis like “Some people can ‘see’ objects in a clairvoyant fashion”. That said, some things really don’t count as proper research hypotheses in any meaningful sense: Love is a battlefield. This is too vague to be testable. While it’s okay for a research hypothesis to have a degree of vagueness to it, it has to be possible to operationalise your theoretical ideas. If this cannot be converted into any concrete research design, then this isn’t a scientific research hypothesis: it’s a pop song. The first rule of the tautology club is the first rule of the tautology club. This is not a substantive claim of any kind. It’s true by definition. No conceivable state of nature could possibly be inconsistent with this claim. As such, we say this is an unfalsifiable hypothesis, and as such, it is outside the domain of science. Whatever else you do in science, your claims must have the possibility of being wrong. More people in my experiment will say “yes” than “no”. This one fails as a research hypothesis because it’s a claim about the data set, not about psychology (unless, of course, your actual research question is whether people have some kind of “yes” bias!). As we’ll see shortly, this hypothesis is starting to sound more like a statistical hypothesis than a research hypothesis. As you can see, research hypotheses can be somewhat messy at times; and ultimately, they are scientific claims. Statistical hypotheses are neither of these two things. They must be mathematically precise and correspond to specific claims about the characteristics of the “population”. Even so, the intent is that statistical hypotheses clearly relate to the substantive research hypotheses you care about! For instance, in our ESP study, the research hypothesis is that some people are able to see through walls or whatever. We want to “map” this onto a statement about how the data were generated. So let’s think about what that statement would be. The quantity that we’d be interested in within the experiment is P(&quot;correct&quot;)P(\\mbox{&quot;correct&quot;}), the true-but-unknown probability with which the participants in my experiment answer the question correctly. Let’s use the Greek letter θ\\theta (theta) to refer to this probability. Here are four different statistical hypotheses: If ESP doesn’t exist and if the experiment is well designed, then the participants are just guessing. So we should expect them to get it right half of the time, and so the statistical hypothesis is that the true probability of choosing correctly is θ=0.5\\theta = 0.5. Alternatively, suppose ESP does exist, and participants can see the card. If that’s true, people will perform better than chance. The statistical hypothesis would be that θ&gt;0.5\\theta &gt; 0.5. A third possibility is that ESP does exist, but the colours are all reversed, and people don’t realise it. If that’s how it works, then you’d expect people’s performance to be below chance. This would correspond to a statistical hypothesis that θ&lt;0.5\\theta &lt; 0.5. Finally, suppose ESP exists, but we have no idea whether people are seeing the right colour or the wrong one. In that case, the only claim to be made about the data would be that the probability of making the correct answer is not equal to 50. This corresponds to the statistical hypothesis that θ≠0.5\\theta \\neq 0.5. These are legitimate examples of statistical hypotheses because they are statements about a population parameter and are meaningfully related to my experiment. What this discussion hopefully makes clear is that when attempting to construct a statistical hypothesis test, the researcher has two quite distinct hypotheses to consider. They have a research hypothesis (a claim about psychology) corresponding to a statistical hypothesis (a claim about the data generating population). Table 9.1: Research and statistical hypotheses in our ESP research example. Research hypothesis Statistical hypothesis ESP exists θ≠0.5\\theta \\neq 0.5 And the critical thing to recognise is this: a statistical hypothesis test is a test of the statistical hypothesis, not the research hypothesis. If your study is poorly designed, the link between your research hypothesis and your statistical hypothesis is broken. To give a silly example, suppose that the ESP study was conducted in a situation where the participant can actually see the card reflected in a window; if that happens, we would be able to find robust evidence that θ≠0.5\\theta \\neq 0.5, but this would tell us nothing about whether “ESP exists”. 9.1.2 Null hypotheses and alternative hypotheses We have a research hypothesis that corresponds to the question we want to ask about the world, and we can map it onto a statistical hypothesis. Our statistical hypothesis will have a claim. This claim will become our “alternative” hypothesis, H1H_1. In constrast, the “null” hypothesis, H0H_0, will correspond to the exact opposite of what the claim was. Then, we’ll focus exclusively on the null hypothesis. In our ESP example, the null hypothesis is that θ=0.5\\theta = 0.5, since that’s what we’d expect if ESP didn’t exist. The hope, of course, is that ESP is totally real, and so the alternative to this null hypothesis is θ≠0.5\\theta \\neq 0.5. In essence, what we’re doing here is dividing up the possible values of θ\\theta into two groups: those values that we really hope aren’t true (the null) and those values that we’d be happy with if they turn out to be correct (the alternative). Having done so, the important thing to recognise is that the goal of a hypothesis test is not to show that the alternative hypothesis is (probably) true; the goal is to show that the null hypothesis is (probably) false. Most people find this pretty weird. According to Danielle, the best way to think about it is to imagine that a hypothesis test is a criminal trial: the trial of the null hypothesis. The null hypothesis is the defendant, the researcher is the prosecutor, and the statistical test itself is the judge. Just like a criminal trial, there is a presumption of innocence: the null hypothesis is deemed to be true unless you, the researcher, can prove beyond a reasonable doubt that it is false. You are free to design your experiment however you like (within reason, obviously!), and your goal when doing so is to maximise the chance that the data will yield a conviction for the crime of being false. The catch is that the statistical test sets the rules of the trial, which are designed to protect the null hypothesis – specifically to ensure that if the null hypothesis is true, the chances of a false conviction are guaranteed to be low. This is pretty important: after all, the null hypothesis doesn’t get a lawyer. And given that the researcher is trying desperately to prove it to be false, someone has to protect it. 9.2 Two types of errors Ideally, we would like to construct our test so that we never make any errors. Unfortunately, this is never possible. Sometimes you’re just really unlucky: for instance, suppose you flip a coin 10 times in a row and it comes up heads all 10 times. That feels like powerful evidence that the coin is biased (and it is!), but of course, there’s a 1 in 1024 chance that this would happen even if the coin was totally fair. In other words, in real life, we always have to accept that there’s a chance that we did the wrong thing. Consequently, statistical hypothesis testing aims not to eliminate errors but to minimise them. At this point, we need to be more precise about what we mean by “errors”. Firstly, let’s state the obvious: it is either the case that the null hypothesis is true, or it is false. And our test will either reject the null hypothesis or retain it. So, as the table below illustrates, after we run the test and make our choice, one of four things might have happened: Retain H0H_0 Reject H0H_0 H0H_0 is true Correct decision Error (type I) H0H_0 is false Error (type II) Correct decision As a consequence, there are actually two different types of error here. If we reject a null hypothesis that is actually true, then we have made a type I error. On the other hand, if we retain the null hypothesis when it is, in fact, false, then we have made a type II error. A criminal trial requires that you establish “beyond a reasonable doubt” that the defendant did it. The trial is designed to protect the rights of a defendant. In other words, a criminal trial doesn’t treat the two types of error in the same way: punishing the innocent is deemed to be much worse than letting the guilty go free. A statistical test is pretty much the same: the single most important design principle of the test is to control the probability of a type I error to keep it below some fixed probability. This probability, which is denoted α\\alpha, is called the significance level of the test (or sometimes, the size of the test). A hypothesis test is said to have a significance level α\\alpha if the type I error rate is no larger than α\\alpha. So, what about the type II error rate? Well, we’d also like to keep those under control too, and we denote this probability by β\\beta. However, it’s much more common to refer to the power of the test, which is the probability with which we reject a null hypothesis when it is false, which is 1−β1-\\beta. To help keep this straight, here’s the same table again, but with the relevant numbers added: Retain H0H_0 Reject H0H_0 H0H_0 is true 1−α1-\\alpha (probability of correct retention) α\\alpha (type I error rate) H0H_0 is false β\\beta (type II error rate) 1−β1-\\beta (power of the test) A “powerful” hypothesis test has a small value of β\\beta while still keeping α\\alpha fixed at some (small) desired level. By convention, scientists make use of three different α\\alpha levels: .05.05, .01.01 and .001.001. Notice the asymmetry here: the tests are designed to ensure that the α\\alpha level is kept small, but there’s no corresponding guarantee regarding β\\beta. We’d certainly like the type II error rate to be small, and we try to design tests that keep it small, but this is very much secondary to the overwhelming need to control the type I error rate. Paraphrasing Blackstone had he been a statistician: it is “better to retain ten false null hypotheses than to reject a single true one”. 9.3 Test statistics and sampling distributions At this point, we need to start talking specifics about how to construct a hypothesis test. To that end, let’s return to the ESP example. Let’s ignore the actual data we obtained, for the moment, and think about the structure of the experiment. Regardless of the actual numbers, the form of the data is that XX out of NN people correctly identified the colour of the hidden card. Moreover, let’s suppose for the moment that the null hypothesis really is true: ESP doesn’t exist, and the true probability that anyone picks the correct colour is exactly θ=0.5\\theta = 0.5. What would we expect the data to look like? Well, obviously, we’d expect the proportion of people who make the correct response to be pretty close to 50%. Or, to phrase this in more mathematical terms, we’d say that X/NX/N is approximately 0.50.5. Of course, we wouldn’t expect this fraction to be exactly 0.5: if, for example, we tested N=100N=100 people, and X=53X = 53 of them got the question right, we’d probably be forced to concede that the data are quite consistent with the null hypothesis. On the other hand, if X=99X = 99 of our participants got the question right, then we’d feel pretty confident that the null hypothesis is wrong. Similarly, if only X=3X=3 people got the answer right, we’d be similarly confident that the null was wrong. Let’s be a little more technical about this: we have a quantity XX that we can calculate by looking at our data; after looking at the value of XX, we decide whether to believe that the null hypothesis is correct or to reject the null hypothesis in favour of the alternative. The name for this thing that we calculate to guide our choices is a test statistic. Having chosen a test statistic, now the next step is to state precisely which values of the test statistic would cause us to reject the null hypothesis and which values would cause us to keep it. To do so, we need to determine what the sampling distribution of the test statistic would be if the null hypothesis were true (we discussed sampling distributions earlier in Chapter 8.3.1). Why do we need this? Because this distribution tells us precisely what values of XX, our null hypothesis would lead us to expect. And therefore, we can use this distribution to assess how closely the null hypothesis agrees with our data. Figure 9.1: The sampling distribution for our test statistic XX when the null hypothesis is true. For our ESP scenario, this is a binomial distribution. Not surprisingly, since the null hypothesis says that the probability of a correct response is θ=.5\\theta = .5, the sampling distribution says that the most likely value is 50 (out of 100) correct responses. Most of the probability mass lies between 40 and 60. How do we determine the sampling distribution of the test statistic? Fortunately, our ESP example provides us with one of the most uncomplicated cases. Our population parameter θ\\theta is just the overall probability that people respond correctly when asked the question, and our test statistic XX is the count of the number of people who did so out of a sample size of NN. We’ve seen a distribution like this in Chapter 7.4.1: that’s exactly what the binomial distribution describes! So, to use the notation and terminology introduced in that section, we would say that the null hypothesis predicts that XX is binomially distributed, which is written X∼Binomial(θ,N) X \\sim \\mbox{Binomial}(\\theta,N) Since the null hypothesis states that θ=0.5\\theta = 0.5 and our experiment has N=100N=100 people, we have the sampling distribution we need. This sampling distribution is plotted in Figure 9.1. No surprises, really: the null hypothesis says that X=50X=50 is the most likely outcome, and it says that we’re almost certain to see somewhere between 40 and 60 correct responses. 9.4 Making decisions We’ve constructed a test statistic (XX), and we chose it so that we’re pretty confident that if XX is close to N/2N/2, then we should retain the null, and if not, we should reject it. The question remains: exactly which values of the test statistic should we associate with the null hypothesis, and which values go with the alternative hypothesis? In the ESP study, for example, we’ve observed a value of X=62X=62. What decision should we make? Should we choose to believe the null hypothesis or the alternative hypothesis? 9.4.1 Critical regions and critical values To answer this question, we need to introduce the concept of a critical region for the test statistic XX. The critical region of the test corresponds to those values of XX that would lead us to reject the null hypothesis (which is why the critical region is also sometimes called the rejection region). How do we find this critical region? Well, let’s consider what we know: XX should be very big or very small to reject the null hypothesis. If the null hypothesis is true, the sampling distribution of XX is Binomial(0.5,N)(0.5, N). If α=.05\\alpha =.05, the critical region must cover 5% of this sampling distribution. You must understand this last point: the critical region corresponds to those values of XX for which we would reject the null hypothesis, and the sampling distribution in question describes the probability that we would obtain a particular value of XX if the null hypothesis were actually true. Now, let’s suppose that we chose a critical region that covers 20% of the sampling distribution, and assume that the null hypothesis is actually true. What would be the probability of incorrectly rejecting the null? The answer is, of course, 20%. And therefore, we would have built a test that had an α\\alpha level of 0.20.2. If we want α=.05\\alpha = .05, the critical region is only allowed to cover 5% of the sampling distribution of our test statistic. Figure 9.2: The critical region associated with the hypothesis test for the ESP study, for a hypothesis test with a significance level of α=.05\\alpha = .05. The plot shows the sampling distribution of XX under the null hypothesis: the grey bars correspond to those values of XX, for which we would retain the null hypothesis. The black bars show the critical region: those values of XX for which we would reject the null. Because the alternative hypothesis is two-sided (i.e. allows both θ&lt;.5\\theta &lt;.5 and θ&gt;.5\\theta &gt;.5), the critical region covers both tails of the distribution. To ensure an α\\alpha level of .05.05, we need to ensure that each of the two regions encompasses 2.5% of the sampling distribution. As it turns out, those three things uniquely solve the problem: our critical region consists of the most extreme values, known as the tails of the distribution (illustrated in Figure 9.2). As it turns out, if we want α=.05\\alpha = .05, then our critical regions correspond to X≤40X \\leq 40 and X≥60X \\geq 60.36 If the number of people saying “true” is between 41 and 59, we should retain the null hypothesis. We should reject the null hypothesis if the number is between 0 to 40 or between 60 to 100. The numbers 40 and 60 are often referred to as the critical values since they define the edges of the critical region. At this point, our hypothesis test is essentially complete: - (1) we choose an α\\alpha level (e.g. α=.05\\alpha = .05), - (2) we come up with some test statistic (e.g., XX) that does a good job (in some meaningful sense) of comparing H0H_0 to H1H_1, - (3) we figure out the sampling distribution of the test statistic on the assumption that the null hypothesis is true (in this case, binomial) and then - (4) we calculate the critical region that produces an appropriate α\\alpha level (0-40 and 60-100). Now, we have to calculate the value of the test statistic for the real data (e.g., X=62X = 62) and then compare it to the critical values to make our decision. Since 62 is greater than the critical value of 60, we would reject the null hypothesis. Or, to phrase it slightly differently, we say that the test has produced a significant result. 9.4.2 A note on statistical “significance” A very brief digression is in order regarding the word “significant”. It is a misnomer. The concept of statistical significance is very simple, but has a very unfortunate name. If the data allows us to reject the null hypothesis, we say that “the result is statistically significant”, often shortened to “the result is significant”. This terminology dates back to a time when “significant” just meant something like “indicated” rather than its modern meaning, which is much closer to “important”. As a result, many modern readers get very confused when they start learning statistics because they think a “significant result” must be an important one. It doesn’t mean that at all. All that “statistically significant” means is that the data allowed us to reject a null hypothesis. Whether or not the result is actually important in the real world is a very different question and depends on all sorts of other things. 9.4.3 The difference between one sided and two sided tests There’s one more thing to point out about the constructed hypothesis test. Let us take a moment to think about the statistical hypotheses: H0:θ=.5H1:θ≠.5 \\begin{array}{cc} H_0 : &amp; \\theta = .5 \\\\ H_1 : &amp; \\theta \\neq .5 \\end{array} We notice that the alternative hypothesis covers both the possibility that θ&lt;.5\\theta &lt; .5 and the possibility that θ&gt;.5\\theta &gt; .5. This makes sense if we think ESP could produce better-than-chance performance or worse-than-chance performance. This is an example of a two-sided test in statistical language. It’s called this because the alternative hypothesis covers the area on both “sides” of the null hypothesis. As a consequence, the critical region of the test covers both tails of the sampling distribution (2.5% on either side provided that α=.05\\alpha =.05), as illustrated earlier in Figure 9.2. However, that’s not the only possibility. For example, it might be the case that we’re only willing to believe in ESP if it produces better than chance performance. If so, then the alternative hypothesis would only cover the possibility that θ&gt;.5\\theta &gt; .5, and as a consequence, the null hypothesis now becomes θ≤.5\\theta \\leq .5: H0:θ≤.5H1:θ&gt;.5 \\begin{array}{cc} H_0 : &amp; \\theta \\leq .5 \\\\ H_1 : &amp; \\theta &gt; .5 \\end{array} When this happens, we have what’s called a one-sided test, and when this happens, the critical region only covers one tail of the sampling distribution. This is illustrated in Figure 9.3. Figure 9.3: The critical region for a one sided test. In this case, the alternative hypothesis is that θ&gt;.05\\theta &gt; .05, so we would only reject the null hypothesis for large values of XX. As a consequence, the critical region only covers the upper tail of the sampling distribution; specifically the upper 5% of the distribution. Contrast this to the two-sided version earlier) 9.5 The pp value of a test In one sense, our hypothesis test is complete; we’ve constructed a test statistic, figured out its sampling distribution if the null hypothesis is true, and then constructed the critical region for the test. Nevertheless, we’ve actually omitted the most important number of all: the pp value. It is to this topic that we now turn. There are two somewhat different ways of interpreting a pp value, one proposed by Sir Ronald Fisher and the other by Jerzy Neyman. Both versions are legitimate, though they reflect very different ways of thinking about hypothesis tests. Most introductory textbooks only give Fisher’s version, but that’s a bit of a shame. Danielle is believes Neyman’s version is cleaner and that it better reflects the logic of the null hypothesis test. You might disagree, though, so both are included. We’ll start with Neyman’s version. 9.5.1 A softer view of decision making One problem with the hypothesis testing procedure is that it makes no distinction between a “barely significant” and a “highly significant” result. For instance, in the ESP study, the data only just fell inside the critical region - so we did get a significant effect, but it was a pretty near thing. In contrast, suppose we run a study in which X=97X=97 out of the N=100N=100 participants got the answer right. This would obviously be significant, too, but by a much larger margin. There is no real ambiguity about this at all. The procedure makes no distinction between the two. If we adopt the standard convention of allowing α=.05\\alpha = .05 as an acceptable Type I error rate, then both are significant results. This is where the pp value comes in handy. To understand how it works, let’s suppose that we ran many hypothesis tests on the same data set: but with a different value of α\\alpha in each case. When we do that for our ESP data, what we’d get is something like this: Value of α\\alpha Reject the null? 0.05 Yes 0.04 Yes 0.03 Yes 0.02 No 0.01 No When we test ESP data (X=62X=62 successes out of N=100N=100 observations) using α\\alpha levels of .03 and above, we always reject the null hypothesis. We always retain the null hypothesis for α\\alpha levels of .02 and below. Therefore, somewhere between .02 and .03, there must be the smallest value of α\\alpha that would allow us to reject the null hypothesis for this data. This is the pp value; as it turns out the ESP data has p=.021p = .021. In short: pp is defined to be the smallest Type I error rate (α\\alpha) that you have to be willing to tolerate if you want to reject the null hypothesis. If it turns out that pp describes an error rate that you find intolerable, then you must retain the null. If you’re comfortable with an error rate equal to pp, then it’s okay to reject the null hypothesis in favour of your preferred alternative. In effect, pp is a summary of all the possible hypothesis tests you could have run, taken across all possible α\\alpha values. And as a consequence, it has the effect of “softening” our decision process. For those tests in which p≤αp \\leq \\alpha, you would have rejected the null hypothesis, whereas for those tests in which p&gt;αp &gt; \\alpha, you would have retained the null. In our ESP study, we obtained X=62X=62, and as a consequence we’ve ended up with p=.021p = .021. So the error rate we have to tolerate is 2.1%. In contrast, suppose the experiment had yielded X=97X=97. What happens to the pp value now? This time it’s shrunk to p=1.36×10−25p = 1.36 \\times 10^{-25}, which is a tiny, tiny37 Type I error rate. For this second case, we would be able to reject the null hypothesis with a lot more confidence because we only have to be “willing” to tolerate a type I error rate of about 1 in 10 trillion trillion to justify our decision to reject. 9.5.2 The probability of extreme data The second definition of the pp-value comes from Sir Ronald Fisher, which you tend to see in most introductory statistics textbooks. Notice how, when we constructed the critical region, it corresponded to the tails (i.e. extreme values) of the sampling distribution? That’s not a coincidence: almost all “good” tests have this characteristic (good in minimising our type II error rate, β\\beta). The reason for that is that a good critical region almost always corresponds to those values of the test statistic that are least likely to be observed if the null hypothesis is true. If this rule is true, then we can define the pp-value as the probability that we would have observed a test statistic that is at least as extreme as the one we actually did get. In other words, if the data are extremely implausible according to the null hypothesis, then the null hypothesis is probably wrong. 9.5.3 A common mistake You can see that there are two somewhat different but legitimate ways to interpret the pp value, one based on Neyman’s approach to hypothesis testing and the other based on Fisher’s. Unfortunately, there is a third explanation that people sometimes give, especially when they’re first learning statistics, and it is absolutely and completely wrong. This mistaken approach is to refer to the pp value as “the probability that the null hypothesis is true”. It’s an intuitively appealing way to think, but it’s wrong in two key respects: null hypothesis testing is a frequentist tool, and the frequentist approach to probability does not allow you to assign probabilities to the null hypothesis. According to this view of probability, the null hypothesis is either true or not, but it cannot have a “5% chance” of being true. even within the Bayesian approach, which does let you assign probabilities to hypotheses, the pp value would not correspond to the probability that the null is true; this interpretation is entirely inconsistent with the mathematics of how the pp value is calculated. Put bluntly, despite the intuitive appeal of thinking this way, there is no justification for interpreting a pp value this way. Never do it. 9.6 Reporting the results of a hypothesis test When writing up the results of a hypothesis test, there are usually several pieces of information that you need to report, but it varies a fair bit from test to test. In the chapters discussing each statistical tool, we’ll spend a little time talking about how to report the results correctly. However, regardless of what test you’re doing, the one thing that you always have to do is say something about the pp value and whether or not the outcome was significant. The fact that you have to do this is unsurprising: it’s the whole point of doing the test. It might be surprising, though, that there is some contention over exactly how you’re supposed to do it. Leaving aside those people who completely disagree with the entire framework underpinning null hypothesis testing, there’s a certain amount of tension that exists regarding whether or not to report the exact pp value that you obtained, or if you should state only that p&lt;αp &lt; \\alpha for a significance level that you chose in advance (e.g., p&lt;.05p&lt;.05). 9.6.1 The issue To see why this is an issue, the key thing to recognise is that pp values are terribly convenient. In practice, the fact that we can compute a pp value means that we don’t have to specify any α\\alpha level at all to run the test. Instead, what you can do is calculate your pp value and interpret it directly: if you get p=.062p = .062, then it means that you’d have to be willing to tolerate a Type I error rate of 6.2% to justify rejecting the null. If you personally find 6.2% intolerable, then you retain the null. Therefore, the argument goes, why don’t we just report the actual pp value and let the reader make up their own minds about what an acceptable Type I error rate is? This approach has the big advantage of “softening” the decision-making process – in fact, if you accept the Neyman definition of the pp value, that’s the whole point of the pp value. We no longer have a fixed significance level of α=.05\\alpha = .05 as a bright line separating “accept” from “reject” decisions; and this removes the rather pathological problem of being forced to treat p=.051p = .051 in a fundamentally different way to p=.049p = .049. This flexibility is both the advantage and the disadvantage to the pp value. Many people don’t like the idea of reporting an exact pp value because it gives the researcher a bit too much freedom. In particular, it lets you change your mind about what error tolerance you’re willing to put up with after you look at the data. For instance, consider the ESP experiment. Suppose we ran the test and ended up with a pp value of .09. Should we accept or reject? Now, we haven’t yet bothered to think about what level of Type I error we’re “really” willing to accept. But we do have an opinion about whether or not ESP exists. Regardless, we could always decide that a 9% error rate isn’t so bad, especially compared to how annoying it would be to admit to the world that the experiment has failed. So, to avoid looking like we just made it up after the fact, we now say that our α\\alpha is .1: a 10% type I error rate isn’t too bad, and at that level, our test is significant! We win. In other words, the worry here is that we might have the best of intentions and be the most honest of people, but the temptation to just “shade” things a little bit here and there is really, really strong. Anyone who has ever run an experiment can attest that it’s a long and difficult process, and you often get very attached to your hypotheses. It’s hard to let go and admit the experiment didn’t find what you wanted it to find. And that’s the danger here. If we use the “raw” pp-value, people will start interpreting the data in terms of what they want to believe, not what the data are actually saying. And if we allow that, well, why are we bothering to do science at all? Why not let everyone believe whatever they like about anything, regardless of what the facts are? Okay, that’s a bit extreme, but that’s where the worry comes from. According to this view, you really must specify your α\\alpha value in advance and then only report whether the test was significant or not. It’s the only way to keep ourselves honest. 9.6.2 Two proposed solutions In practice, it’s pretty rare for a researcher to specify a single α\\alpha level ahead of time. Instead, the convention is that scientists rely on three standard significance levels: .05, .01 and .001. When reporting your results, you indicate which (if any) of these significance levels allow you to reject the null hypothesis. This is summarised in Table 9.2. This allows us to soften the decision rule a little bit since p&lt;.01p&lt;.01 implies that the data meet a stronger evidentiary standard than p&lt;.05p&lt;.05 would. Nevertheless, since these levels are fixed in advance by convention, it does prevent people from choosing their α\\alpha level after looking at the data. Table 9.2: A commonly adopted convention for reporting pp values: in many places it is conventional to report one of four different things (e.g., p&lt;.05p&lt;.05) as shown below. A “significance stars” notation (i.e., a * indicates p&lt;.05p&lt;.05) is sometimes produced by statistical software. It’s also worth noting that some people will write n.s. (not significant) rather than p&gt;.05p&gt;.05. Usual notation Signif. stars Meaning The null is… p&gt;.05p&gt;.05 The test wasn’t significant Retained p&lt;.05p&lt;.05 * The test was significant at α=.05\\alpha = .05 but not at α=.01\\alpha =.01 or α=.001\\alpha = .001. Rejected p&lt;.01p&lt;.01 ** The test was significant at α=.05\\alpha = .05 and α=.01\\alpha = .01 but not at α=.001\\alpha = .001 Rejected p&lt;.001p&lt;.001 *** The test was significant at all levels Rejected Nevertheless, many people still prefer to report exact pp values. To many people, the advantage of allowing the reader to make up their own mind about how to interpret p=.06p = .06 outweighs any disadvantages. In practice, however, even among those researchers who prefer exact pp values, it is quite common to just write p&lt;.001p&lt;.001 instead of reporting an exact value for small pp. This is in part because a lot of software doesn’t actually print out the pp value when it’s that small (e.g., SPSS just writes p=.000p = .000 whenever p&lt;.001p&lt;.001), and in part because a very small pp value can be kind of misleading. The human mind sees a number like .0000000001, and it’s hard to suppress the gut feeling that the evidence in favour of the alternative hypothesis is a near certainty. In practice, however, this is usually wrong. Every statistical test ever invented relies on simplifications, approximations and assumptions. As a consequence, it’s probably not reasonable to walk away from any statistical analysis with a feeling of confidence stronger than p&lt;.001p&lt;.001 implies. In other words, p&lt;.001p&lt;.001 is really code for “as far as this test is concerned, the evidence is overwhelming.” In light of all this, you might wonder what exactly you should do. There’s a fair bit of contradictory advice on the topic, with some people arguing that you should report the exact pp value and other people arguing that you should use the tiered approach illustrated in Table 9.2. As a result, the best advice is that you look at papers/reports written in your field and see what the convention seems to be. If there doesn’t seem to be any consistent pattern, then use whichever method you prefer. For any hypothesis test that CogStat will run for you, whether that be a t-test, ANOVA, regression, etc., the output will include a pp value. If you want to report the pp value, you can just copy and paste it from the output. 9.7 Effect size, sample size and power In previous sections, we emphasised the fact that the major design principle behind statistical hypothesis testing is that we try to control our Type I error rate. When we fix α=.05\\alpha = .05, we are attempting to ensure that only 5% of true null hypotheses are incorrectly rejected. However, this doesn’t mean that we don’t care about Type II errors. In fact, from the researcher’s perspective, the error of failing to reject the null when it is actually false is an extremely annoying one. With that in mind, a secondary goal of hypothesis testing is to try to minimise β\\beta, the Type II error rate, although we don’t usually talk in terms of minimising Type II errors. Instead, we talk about maximising the power of the test. Since power is defined as 1−β1-\\beta, this is the same thing. 9.7.1 The power function Figure 9.4: Sampling distribution under the alternative hypothesis, for a population parameter value of θ=0.55θ = 0.55. A reasonable proportion of the distribution lies in the rejection region. Let’s take a moment to think about what a Type II error actually is. A Type II error occurs when the alternative hypothesis is true, but we are nevertheless unable to reject the null hypothesis. Ideally, we’d be able to calculate a single number β\\beta that tells us the Type II error rate, similarly to how we can set α=.05\\alpha = .05 for the Type I error rate. Unfortunately, this is a lot trickier to do. To see this, notice that in the ESP study, the alternative hypothesis actually corresponds to lots of possible values of θ\\theta. In fact, the alternative hypothesis corresponds to every value of θ\\theta except 0.5. Let’s suppose that the true probability of someone choosing the correct response is 55% (i.e., θ=.55\\theta = .55). If so, then the true sampling distribution for XX is not the same one that the null hypothesis predicts: the most likely value for XX is now 55 out of 100. Not only that, the whole sampling distribution has now shifted, as shown in Figure 9.4. The critical regions, of course, do not change: by definition, the critical regions are based on what the null hypothesis predicts. What we’re seeing in this figure is the fact that when the null hypothesis is wrong, a much larger proportion of the sampling distribution falls in the critical region. And, of course, that’s what should happen: the probability of rejecting the null hypothesis is larger when the null hypothesis is actually false! However, θ=.55\\theta = .55 is not the only possibility that is consistent with the alternative hypothesis. Let’s instead suppose that the true value of θ\\theta is 0.7. What happens to the sampling distribution when this occurs? The answer, shown in Figure 9.5, is that almost the entirety of the sampling distribution has now moved into the critical region. Therefore, if θ=0.7\\theta = 0.7, the probability of us correctly rejecting the null hypothesis (i.e. the power of the test) is much larger than if θ=0.55\\theta = 0.55. In short, while θ=.55\\theta = .55 and θ=.70\\theta = .70 are both part of the alternative hypothesis, the Type II error rate is different. Figure 9.5: Sampling distribution under the alternative hypothesis, for a population parameter value of θ=0.70\\theta = 0.70. Almost all of the distribution lies in the rejection region. Figure 9.6: The probability that we will reject the null hypothesis is plotted as a function of the true value of θ\\theta. Obviously, the test is more powerful (greater chance of correct rejection) if the true value of θ\\theta is very different from the value that the null hypothesis specifies (i.e., θ=.5\\theta=.5). Notice that when θ\\theta actually is equal to .5 (plotted as a black dot), the null hypothesis is, in fact, true: rejecting the null hypothesis in this instance would be a Type I error. This means that the power of a test (i.e., 1−β1-\\beta) depends on the true value of θ\\theta. To illustrate this, we’ve calculated the expected probability of rejecting the null hypothesis for all values of θ\\theta and plotted it in Figure 9.6. This plot describes what is usually called the power function of the test. It’s a nice summary of how good the test is because it actually tells you the power (1−β1-\\beta) for all possible values of θ\\theta. As you can see, when the true value of θ\\theta is very close to 0.5, the power of the test drops very sharply, but when it is further away, the power is large. 9.7.2 Effect size The plot shown in Figure 9.6 captures a basic point about hypothesis testing. If the true state of the world is very different from what the null hypothesis predicts, then your power will be very high; but if the true state of the world is similar to the null (but not identical), then the power of the test is going to be very low. Therefore, it’s useful to be able to have some way of quantifying how “similar” the true state of the world is to the null hypothesis. A statistic that does this is called a measure of effect size (e.g. Cohen, 1988; Ellis, 2010). Effect size is defined slightly differently in different contexts, but the qualitative idea that it tries to capture is always the same: how big is the difference between the true population parameters and the parameter values that are assumed by the null hypothesis. In our ESP example, if we let θ0=0.5\\theta_0 = 0.5 denote the value assumed by the null hypothesis, and let θ\\theta denote the true value, then a simple measure of effect size could be something like the difference between the true value and null (i.e., θ−θ0\\theta - \\theta_0), or possibly just the magnitude of this difference, abs(θ−θ0)\\mbox{abs}(\\theta - \\theta_0). Big effect size Small effect size Significant result difference is real, and of practical importance difference is real, but might not be interesting Non-significant result no effect observed no effect observed Why calculate effect size? Let’s assume that you’ve run your experiment, collected the data, and gotten a significant effect when you ran your hypothesis test. Isn’t it enough just to say that you’ve gotten a significant effect? Surely that’s the point of hypothesis testing? Well, sort of. Yes, the point of doing a hypothesis test is to try to demonstrate that the null hypothesis is wrong, but that’s hardly the only thing we’re interested in. If the null hypothesis claimed that θ=.5\\theta = .5, and we show that it’s wrong, we’ve only really told half of the story. Rejecting the null hypothesis implies that we believe that θ≠.5\\theta \\neq .5, but there’s a big difference between θ=.51\\theta = .51 and θ=.8\\theta = .8. If we find that θ=.8\\theta = .8, then not only have we found that the null hypothesis is wrong, it appears to be very wrong. On the other hand, suppose we’ve successfully rejected the null hypothesis, but it looks like the true value of θ\\theta is only .51 (this would only be possible with a large study). Sure, the null hypothesis is wrong, but it’s not at all clear that we actually care, because the effect size is so small. In the context of the ESP study, we might still care, since any demonstration of real psychic powers would actually be pretty cool38, but in other contexts, a 1% difference isn’t very interesting, even if it is a real difference. For instance, suppose we’re looking at differences in high school exam scores between males and females, and it turns out that the female scores are 1% higher on average than the males. If I’ve got data from thousands of students, then this difference will almost certainly be statistically significant, but regardless of how small the pp value is, it’s just not very interesting. You’d hardly want to go around proclaiming a crisis in boys’ education based on such a tiny difference, would you? For this reason, it is becoming more standard (slowly but surely) to report some kind of standard measure of effect size along with the results of the hypothesis test. The hypothesis test itself tells you whether you should believe that the effect you have observed is real (i.e., not just due to chance); the effect size tells you whether or not you should care. 9.7.3 Increasing the power of your study Not surprisingly, scientists are fairly obsessed with maximising the power of their experiments. We want our experiments to work, so we want to maximise the chance of rejecting the null hypothesis if it is false (and we usually want to believe it is false!). As we’ve seen, one factor that influences power is the effect size. So the first thing you can do to increase your power is to increase the effect size. In practice, this means that you want to design your study so that the effect size gets magnified. For instance, in the ESP study, we might believe that psychic powers work best in a quiet, darkened room; with fewer distractions to cloud the mind. Therefore, we would try to conduct the experiments in such an environment. If we can strengthen people’s ESP abilities somehow, then the true value of θ\\theta will go up39 and, therefore, our effect size will be larger. In short, clever experimental design is one way to boost power; because it can alter the effect size. Unfortunately, it’s often the case that even with the best experimental designs, you may have only a small effect. Perhaps, for example, ESP really does exist, but even under the best of conditions, it’s very very weak. Under those circumstances, your best bet for increasing power is to increase the sample size. Generally, the more observations you have available, the more likely you can discriminate between two hypotheses. If we had 10 participants, and 7 of them correctly guessed the colour of the hidden card, you wouldn’t be terribly impressed. But if we had 10,000 participants and 7,000 of them got the answer right, you would likely think we had discovered something. In other words, power increases with the sample size. This is illustrated in Figure 9.7, which shows the power of the test for a true parameter of θ=0.7\\theta = 0.7, for all sample sizes NN from 1 to 100, where I’m assuming that the null hypothesis predicts that θ0=0.5\\theta_0 = 0.5. Figure 9.7: The power of our test, plotted as a function of the sample size NN. In this case, the true value of θ\\theta is 0.7, but the null hypothesis is that θ=0.5\\theta = 0.5. Overall, larger NN means greater power. (The small zig-zags in this function occur because of some odd interactions between θ\\theta, α\\alpha and the fact that the binomial distribution is discrete; it doesn’t matter for any serious purpose) Because power is important, it would be pretty useful to know how much power you’re likely to have when you’re contemplating running an experiment. It’s never possible to know for sure since you can’t possibly know what your effect size is. However, it’s sometimes possible to guess how big it should be. If so, you can guess what sample size you need! This idea is called power analysis. If it’s feasible to do it, it’s very helpful since it can tell you whether you have enough time or money to run the experiment successfully. It’s increasingly common to see people arguing that power analysis should be a required part of experimental design, so it’s worth knowing about, but we won’t be discussing it in this book in details. 9.8 Some issues to consider What we’ve discussed in this chapter is the orthodox framework for null hypothesis significance testing (NHST). Understanding how NHST works is an absolute necessity since it has been the dominant approach to inferential statistics since its prominence in the early 20th century. It’s what the vast majority of working scientists rely on for their data analysis, so even if you hate it, you need to know it. However, the approach is not without problems. There are several quirks in the framework, historical oddities in how it came to be, theoretical disputes over whether or not the framework is proper, and many practical traps for the unwary. Without going into much detail on this topic, it’s worth briefly discussing a few of these issues. 9.8.1 Neyman versus Fisher The first thing you should be aware of is that orthodox NHST is a mash-up of two somewhat different approaches to hypothesis testing, one proposed by Sir Ronald Fisher and the other proposed by Jerzy Neyman (for a historical summary, see Lehmann, 2011). The history is messy because Fisher and Neyman were real people whose opinions changed over time, and at no point did either of them offer “the definitive statement” of how we should interpret their work many decades later. That said, here’s a quick summary of these two approaches. First, let’s talk about Fisher’s approach. Fisher assumed that you only had one hypothesis (the null), and what you want to do is find out if the null hypothesis is inconsistent with the data. From his perspective, what you should do is check to see if the data are “sufficiently unlikely” according to the null. In fact, if you remember back to our earlier discussion, that’s how Fisher defines the pp-value. According to Fisher, if the null hypothesis provided a very poor account of the data, you could safely reject it. But, since you don’t have any other hypotheses to compare it to, there’s no way of “accepting the alternative” because you don’t necessarily have an explicitly stated alternative. That’s more or less all that there was to it. In contrast, Neyman thought that the point of hypothesis testing was as a guide to action, and his approach was somewhat more formal than Fisher’s. His view was that there are multiple things you could do (accept the null or accept the alternative), and the point of the test was to tell you which one the data support. From this perspective, it is critical to specify your alternative hypothesis properly. If you don’t know the alternative hypothesis, then you don’t know how powerful the test is or which action makes sense. His framework genuinely requires competition between different hypotheses. For Neyman, the pp value didn’t directly measure the probability of the data (or data more extreme) under the null; it was more of an abstract description about which “possible tests” were telling you to accept the null and which “possible tests” were telling you to accept the alternative. As you can see, what we have today is an odd mishmash of the two. We talk about having both a null hypothesis and an alternative (Neyman) but usually define the pp value in terms of extreme data (Fisher), but we still have α\\alpha values (Neyman). Some statistical tests have explicitly specified alternatives (Neyman), but others are quite vague about it (Fisher). And, according to some people, we’re not allowed to talk about accepting the alternative (Fisher). It’s a mess. 9.8.2 Bayesians versus frequentists Earlier in this chapter, we emphasised how you cannot interpret the pp value as the probability that the null hypothesis is true. NHST is fundamentally a frequentist tool (see Chapter 7), and as such, it does not allow you to assign probabilities to hypotheses: the null hypothesis is either true or not. The Bayesian approach to statistics interprets probability as a degree of belief, so it’s totally okay to say that there is a 10% chance that the null hypothesis is true: that’s just a reflection of your degree of confidence in this hypothesis. You aren’t allowed to do this within the frequentist approach. Remember, if you’re a frequentist, a probability can only be defined in terms of what happens after a large number of independent replications (i.e. a long-run frequency). If this is your interpretation of probability, talking about the “probability” that the null hypothesis is true is complete gibberish. Most importantly, this isn’t an ideological matter purely. If you decide that you are a Bayesian and are okay with making probability statements about hypotheses, you must follow the Bayesian rules for calculating those probabilities. We’ll talk more about this in Chapter 15, but for now, understand that pp value is a terrible approximation to the probability that H0H_0 is true. If what you want to know is the probability of the null, then the pp value is not what you’re looking for! 9.8.3 Traps As you can see, the theory behind hypothesis testing is a mess, and even now, there are arguments in statistics about how it “should” work. However, disagreements among statisticians are not our real concern here. Our real concern is practical data analysis. And while the “orthodox” approach to null hypothesis significance testing has many drawbacks, even an unrepentant Bayesian would agree that they can be useful if used responsibly. They usually give sensible answers, and you can use them to learn interesting things. Setting aside the various ideologies and historical confusions that we’ve discussed, the fact remains that the biggest danger in all of statistics is thoughtlessness. Not stupidity but thoughtlessness. The rush to interpret a result without thinking through what each test says about the data and checking whether that’s consistent with how you’ve interpreted it. That’s where the biggest trap lies. To give an example of this, consider the following example (see Gelman &amp; Stern, 2006). Suppose we run the ESP study, and we’ve decided to analyse the data separately for the male and female participants. Of the male participants, 33 out of 50 guessed the card’s colour correctly. This is a significant effect (p=.03p = .03). Of the female participants, 29 out of 50 guessed correctly. This is not a significant effect (p=.32p = .32). Upon observing this, it is extremely tempting for people to start wondering why there is a difference between males and females regarding their psychic abilities. However, this doesn’t seem right. If you think about it, we haven’t actually run a test that explicitly compares males to females. All we have done is compare males to chance (binomial test was significant) and compare females to chance (binomial test was non-significant). If we want to argue that there is a real difference between the males and the females, we should probably run a test of the null hypothesis that there is no difference! We can do that using a different hypothesis test, but when we do that, it turns out that we have no evidence that males and females are significantly different (p=.54p = .54). Now do you think that there’s anything fundamentally different between the two groups? Of course not. What’s happened here is that the data from both groups (male and female) are pretty borderline: by pure chance, one of them happened to end up on the magic side of the p=.05p = .05 line, and the other one didn’t. That doesn’t imply that males and females are different. This mistake is so common that you should always be wary of it: the difference between significant and not-significant is not evidence of a real difference – if you want to say that there’s a difference between two groups, then you have to test for that difference! Think about what it is you want to test, why you want to test it, and whether or not the answers that your test gives could possibly make any sense in the real world. 9.9 Summary Null hypothesis testing is one of the most ubiquitous elements of statistical theory. The vast majority of scientific papers report the results of some hypothesis test or another. As a consequence, it is almost impossible to get by in science without having at least a cursory understanding of what a pp-value means, making this one of the most important chapters in the book. Here is a quick recap of the key ideas that we’ve talked about: Research hypotheses and statistical hypotheses. Null and alternative hypotheses. (Section 9.1). Type 1 and Type 2 errors (Section 9.2) Test statistics and sampling distributions (Section 9.3) Hypothesis testing as a decision making process (Section 9.4) pp-values as “soft” decisions (Section 9.5) Writing up the results of a hypothesis test (Section 9.6) Effect size and power (Section 9.7) A few issues to consider regarding hypothesis testing (Section 9.8) Later in the book, in Chapter 15, we’ll revisit the theory of null hypothesis tests from a Bayesian perspective and introduce a number of new tools that you can use if you aren’t particularly fond of the orthodox approach. But for now, though, we’re done with the abstract statistical theory, and we can start discussing specific data analysis tools. References Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Lawrence Erlbaum. Ellis, P. D. (2010). The essential guide to effect sizes: Statistical power, meta-analysis, and the interpretation of research results. Cambridge University Press. Gelman, A., &amp; Stern, H. (2006). The difference between “significant” and “not significant” is not itself statistically significant. The American Statistician, 60, 328–331. Lehmann, E. L. (2011). Fisher, Neyman, and the creation of classical statistics. Springer. My apologies to anyone who actually believes in this stuff, but on my reading of the literature on ESP, it’s just not reasonable to think this is real. To be fair, though, some of the studies are rigorously designed; so it’s actually an interesting area for thinking about psychological research design. And of course, it’s a free country, so you can spend your own time and effort proving me wrong if you like, but I wouldn’t think that’s a terribly practical use of your intellect. – Danielle↩︎ Strictly speaking, the test has α=.057\\alpha = .057, which is a bit too generous. However, if we’d chosen 39 and 61 as the boundaries for the critical region, then the critical region only covers 3.5% of the distribution. For the sake of the example, we’re willing to tolerate a 5.7% type I error rate since that’s as close as we can get to a value of α=.05\\alpha = .05.↩︎ That’s p=.000000000000000000000000136p = .000000000000000000000000136 for folks that don’t like or know scientific notation!↩︎ Although, in practice, a very small effect size is worrying because even very minor methodological flaws might be responsible for the effect. And in practice, no experiment is perfect, so there are always methodological issues to worry about.↩︎ Notice that the true population parameter θ\\theta doesn’t necessarily correspond to an immutable fact of nature. In this context, θ\\theta is just the true probability that people would correctly guess the colour of the card in the other room. As such, the population parameter can be influenced by all sorts of things. Of course, this is all on the assumption that ESP actually exists!↩︎ "],["chisquare.html", "Chapter 10 Categorical data analysis 10.1 The χ2\\chi^2 goodness-of-fit test 10.2 The χ2\\chi^2 test of independence (or association) 10.3 Yates correction for 1 degree of freedom 10.4 Effect size (Cramér’s VV) 10.5 Assumptions of the test(s) 10.6 The Fisher exact test 10.7 The McNemar test 10.8 What’s the difference between McNemar and independence? 10.9 Summary", " Chapter 10 Categorical data analysis Now that we’ve got the basic theory behind hypothesis testing, it’s time to start looking at specific tests commonly used in psychology. We’ll start with “χ2\\chi^2 tests” (pronounced as ‘chi square’) in this chapter and “tt-tests” (Chapter 11) in the next one. Both of these tools are very frequently used in scientific practice for comparing groups. While they’re not as powerful as “analysis of variance” (Chapter 12) and “regression” (Chapter 14), they’re much easier to understand. The term “categorical data” is the term preferred by data analysis people, but it’s just another name for “nominal scale data”. To refresh your memory on data types, please revisit our introductory chapter on scales of measurement and types of variables (see Chapter 2.2). In any case, categorical data analysis refers to a collection of tools that you can use when your data are nominal scale. We can use many tools for categorical data analysis, but this chapter covers the ones used by CogStat along some more common ones. 10.1 The χ2\\chi^2 goodness-of-fit test The χ2\\chi^2 goodness-of-fit test is one of the oldest hypothesis tests around: it was invented by Karl Pearson around the turn of the century (Pearson, 1900), with some corrections made later by Sir Ronald Fisher (Fisher, 1922a). Let’s start with some psychology to introduce the statistical problem it addresses. Over the years, there have been a lot of studies showing that humans have a lot of difficulties in simulating randomness. Try as we might to “act” random, we think in terms of patterns and structure, and so when asked to “do something at random”, what people do is anything but random. Consequently, the study of human randomness (or non-randomness, as the case may be) opens up a lot of deep psychological questions about how we think about the world. With this in mind, let’s consider a very simple study. Suppose we asked people to imagine a shuffled deck of cards and mentally pick one card from this imaginary deck “at random”. After they’ve chosen one card, we ask them to select a second one mentally. For both choices, we’re going to look at the suit (hearts, clubs, spades or diamonds) that people chose. After asking, say, N=200N=200 people to do this, we’d like to look at the data and figure out whether or not the cards that people pretended to select were random. The data are contained in the cards.csv file, which we will load into CogStat. For the moment, let’s just focus on the first choice that people made (choice_1). Figure 10.1: Loading the cards.csv data and running Explore variable command on choice_1 Important note: CogStat currently doesn’t support single-variable hypothesis testing for nominal scale data. However, this chapter will still be useful for you to understand the tools used in hypothesis testing, and you can use them as described here in other software packages. We can see that the data are nominal scale, so we’ll use the χ2\\chi^2 goodness-of-fit test to analyze them. We’ll also use the “Fisher’s exact test” option, which is a more powerful version of the χ2\\chi^2 test that is appropriate when the sample size is small (less than 40). We’ll also use the “Bonferroni correction” option, which is a way of correcting for multiple comparisons. For now, let’s just run the analysis. That little frequency table in Figure 10.1 is quite helpful. Looking at it, there’s a bit of a hint that people might be more likely to select hearts than clubs, but it’s not completely obvious just from looking at it whether that’s really true, or if this is just due to chance. So we’ll probably have to do some kind of statistical analysis to find out, which is what we’re going to talk about in the next section. A quick side-note here: the mathematical notation of observations (i.e. an element in the data set) is 0i0_i, where OO stands for observation (but could very well be the traditional XX or YY etc.) and ii is the index of the observation. So 010_1 is the first observation, 020_2 is the second observation, and so on. 10.1.1 The null hypothesis and the alternative hypothesis Our research hypothesis is that “people don’t choose cards randomly”. What we’re going to want to do now is translate this into some statistical hypotheses, and construct a statistical test of those hypotheses. The test is Pearson’s χ2\\chi^2 goodness of fit test. As is so often the case, we have to begin by carefully constructing our null hypothesis. In this case, it’s pretty easy. First, let’s state the null hypothesis in words. Null hypothesis (H0H_0): All four suits are chosen with equal probability. Now, because this is statistics, we have to be able to say the same thing mathematically. Let’s use the notation PjP_j to refer to the true probability that the jj-th suit is chosen. If the null hypothesis is true, then each of the four suits has a 25% chance of being selected: in other words, our null hypothesis claims that P1=0.25P_1 = 0.25, P2=0.25P_2 = 0.25, P3=0.25P_3 = 0.25 and finally that P4=0.25P_4 = 0.25. We can use PP to refer to the probabilities corresponding to our null hypothesis. So if we let the vector P=(P1,P2,P3,P4)P = (P_1, P_2, P_3, P_4) refer to the collection of probabilities that describe our null hypothesis, then we have H0:P=(0.25,0.25,0.25,0.25) H_0: {P} = (0.25, 0.25, 0.25, 0.25) If the experimental task were for people to imagine they were drawing from a deck that had twice as many clubs as any other suit, then the null hypothesis would correspond to something like P=(0.4,0.2,0.2,0.2)P = (0.4, 0.2, 0.2, 0.2). As long as the probabilities are all positive numbers, and they all sum to 1, then it’s a perfectly legitimate choice for the null hypothesis. However, the most common use of the goodness of fit test is to test a null hypothesis that all categories are equally likely, so we’ll stick to that for our example. What about our alternative hypothesis, H1H_1? We’re interested in demonstrating that the probabilities involved aren’t all identical (that is, people’s choices weren’t entirely random). As a consequence, the “human-friendly” versions of our hypotheses look like this: Null hypothesis (H0H_0): All four suits are chosen with equal probability. Alternative hypothesis (H1H_1): At least one of the suit-choice probabilities isn’t 0.25. and the “mathematician friendly” version is H0H_0 H1H_1 P=(0.25,0.25,0.25,0.25)P = (0.25, 0.25, 0.25, 0.25) P≠(0.25,0.25,0.25,0.25)P \\neq (0.25,0.25,0.25,0.25) 10.1.2 The “goodness of fit” test statistic What we now want to do is construct a test of the null hypothesis. As always, if we want to test H0H_0 against H1H_1, we will need a test statistic. The basic trick that a goodness of fit test uses is to construct a test statistic that measures how “close” the data are to the null hypothesis. If the data don’t resemble what you’d “expect” to see if the null hypothesis were true, then it probably isn’t true. So, what would we expect to see if the null hypothesis were true? Or, to use the correct terminology, what are the expected frequencies? There are N=200N=200 observations, and (if the null is true) the probability of any one of them choosing a heart is P3=0.25P_3 = 0.25, so we’re expecting 200×0.25=50200 \\times 0.25 = 50 hearts, right? Or, more specifically, if we let EiE_i refer to “the number of category ii responses that we’re expecting if the null is true”, then Ei=N×Pi E_i = N \\times P_i Clearly, what we want to do is compare the expected number of observations in each category (EiE_i) with the observed number of observations in that category (OiO_i). And on the basis of this comparison, we ought to be able to come up with a good test statistic. To start with, let’s calculate the difference between what the null hypothesis expected us to find and what we actually did find. That is, we calculate the “observed minus expected” difference score, Oi−EiO_i - E_i. This is illustrated in the following table. ♣\\clubsuit ♢\\diamondsuit ♡\\heartsuit ♠\\spadesuit Expected frequency EiE_i 50 50 50 50 Observed frequency OiO_i 35 51 64 50 Difference score Oi−EiO_i - E_i -15 1 14 0 It’s clear that people chose more hearts and fewer clubs than the null hypothesis predicted. However, a moment’s thought suggests that these raw differences aren’t quite what we’re looking for. Intuitively, it feels like it’s just as bad when the null hypothesis predicts too few observations (which is what happened with hearts) as it is when it predicts too many (which is what happened with clubs). So it’s a bit weird that we have a negative number for clubs and a positive number for hearts. One easy way to fix this is to square everything so that we now calculate the squared differences, (Ei−Oi)2(E_i - O_i)^2. ♣\\clubsuit ♢\\diamondsuit ♡\\heartsuit ♠\\spadesuit Expected frequency EiE_i 50 50 50 50 Observed frequency OiO_i 35 51 64 50 Difference score Oi−EiO_i - E_i -15 1 14 0 Squared differences (Oi−Ei)2\\left(O_i - E_i\\right)^2 225 1 196 0 Now we’re making progress. Now, we’ve got a collection of numbers that are big whenever the null hypothesis makes a lousy prediction (clubs and hearts) but small whenever it makes a good one (diamonds and spades). Next, let’s also divide all these numbers by the expected frequency EiE_i, so we’re calculating (Ei−Oi)2Ei\\frac{(E_i-O_i)^2}{E_i}. Since Ei=50E_i = 50 for all categories in our example, it’s not a very interesting calculation, but let’s do it anyway. ♣\\clubsuit ♢\\diamondsuit ♡\\heartsuit ♠\\spadesuit Expected frequency EiE_i 50 50 50 50 Observed frequency OiO_i 35 51 64 50 Difference score Oi−EiO_i - E_i -15 1 14 0 Squared differences (Oi−Ei)2\\left(O_i - E_i\\right)^2 225 1 196 0 Squared differences divided by expected frequency (Oi−Ei)2Ei\\frac{\\left(O_i - E_i\\right)^2}{E_i} 4.5 0.02 3.92 0 In effect, what we’ve got here are four different “error” scores, each one telling us how big a “mistake” the null hypothesis made when we tried to use it to predict our observed frequencies. So, in order to convert this into a useful test statistic, one thing we could do is just add these numbers up. We get X2=8.42 X^2 = 8.42 The result is called the goodness of fit statistic, conventionally referred to either as X2X^2 or GOF. If we let kk refer to the total number of categories (i.e. k=4k=4 for our cards data), then the X2X^2 statistic is given by the following formula: X2=∑i=1k(Oi−Ei)2Ei X^2 = \\sum_{i=1}^k \\frac{(O_i - E_i)^2}{E_i} Intuitively, it’s clear that if X2X^2 is small, then the observed data OiO_i are very close to what the null hypothesis predicted EiE_i, so we’re going to need a large X2X^2 statistic in order to reject the null. As we’ve seen from our calculations, we’ve got a value of X2=8.44X^2 = 8.44 in our cards data set. So now the question becomes, is this a big enough value to reject the null? 10.1.3 The sampling distribution of the GOF statistic (advanced) To determine whether or not a particular value of X2X^2 is large enough to justify rejecting the null hypothesis, we will need to figure out what the sampling distribution for X2X^2 would be if the null hypothesis were true. If you want to cut to the chase and are willing to take it on faith that the sampling distribution is a chi-squared (χ2\\chi^2) distribution with k−1k-1 degrees of freedom, you can skip the rest of this section. However, if you want to understand why the goodness of fit test works the way it does, read on. Let’s suppose that the null hypothesis is true. If so, then the true probability that an observation falls in the ii-th category is PiP_i. After all, that’s the definition of our null hypothesis. If you think about it, this is kind of like saying that “nature” decides whether or not the observation ends up in category ii by flipping a weighted coin (i.e. one where the probability of getting a head is PjP_j). And therefore, we can think of our observed frequency OiO_i by imagining that nature flipped NN of these coins (one for each observation in the data set). And exactly OiO_i of them came up heads. Obviously, this is a pretty weird way to think about the experiment. But it reminds you that we’ve seen this scenario before. It’s exactly the same set-up that gave rise to the binomial distribution in Chapter 7.4.1. In other words, if the null hypothesis is true, then it follows that our observed frequencies were generated by sampling from a binomial distribution: Oi∼Binomial(Pi,N) O_i \\sim \\mbox{Binomial}(P_i, N) Now, if you remember from our discussion of the central limit theorem (Section 8.3.3), the binomial distribution starts to look pretty much identical to the normal distribution, especially when NN is large and when PiP_i isn’t too close to 0 or 1. In other words, as long as N×PiN \\times P_i is large enough – or, to put it another way, when the expected frequency EiE_i is large enough – the theoretical distribution of OiO_i is approximately normal. Better yet, if OiO_i is normally distributed, then so is (Oi−Ei)/Ei(O_i - E_i)/\\sqrt{E_i} … since EiE_i is a fixed value, subtracting off EiE_i and dividing by Ei\\sqrt{E_i} changes the mean and standard deviation of the normal distribution. Okay, so now let’s have a look at what our goodness of fit statistic actually is. What we’re doing is taking a bunch of things that are normally distributed, squaring them, and adding them up. As we discussed in Chapter 7.4.4, when you take a bunch of things that have a standard normal distribution (i.e. mean 0 and standard deviation 1), square them, then add them up, then the resulting quantity has a chi-square distribution. So now we know that the null hypothesis predicts that the sampling distribution of the goodness of fit statistic is a chi-square distribution. There’s one last detail to talk about, namely the degrees of freedom. If you remember back to Chapter 7.4.4, if the number of things you’re adding up is kk, then the degrees of freedom for the resulting chi-square distribution is kk. Yet, at the start of this section, we said that the actual degrees of freedom for the chi-square goodness of fit test is k−1k-1. What’s up with that? The answer here is that what we’re supposed to be looking at is the number of genuinely independent things that are getting added together. And, even though there are kk things that we’re adding, only k−1k-1 of them are truly independent; and so the degrees of freedom are actually only k−1k-1. 10.1.4 Degrees of freedom Figure 10.2: Chi-square distributions with different values for the “degrees of freedom”. When discussing the chi-square distribution in Chapter 7.4.4, we didn’t elaborate on what “degrees of freedom” actually mean. Looking at Figure 10.2, you can see that if we change the degrees of freedom, then the chi-square distribution changes shape substantially. But what exactly is it? It’s the number of “normally distributed variables” that we are squaring and adding together. But, for most people, that’s kind of abstract and not entirely helpful. What we really need to do is try to understand degrees of freedom in terms of our data. So here goes. The basic idea behind degrees of freedom is quite simple: you calculate it by counting up the number of distinct “quantities” that are used to describe your data; and then subtracting off all of the “constraints” that those data must satisfy.40 This is a bit vague, so let’s use our cards.csv data as a concrete example. We describe our data using four numbers, O1O_1, O2O_2, O3O_3 and O4O_4 corresponding to the observed frequencies of the four different categories (hearts, clubs, diamonds, spades). These four numbers are the random outcomes of our experiment. But, the experiment has a fixed constraint built into it: the sample size NN.41 That is, if we know how many people chose hearts, how many chose diamonds and how many chose clubs, then we’d be able to figure out exactly how many chose spades. In other words, although our data are described using four numbers, they only actually correspond to 4−1=34-1 = 3 degrees of freedom. A slightly different way of thinking about it is to notice that there are four probabilities that we’re interested in (again, corresponding to the four different categories), but these probabilities must sum to one, which imposes a constraint. Therefore, the degrees of freedom is 4−1=34-1 = 3. Regardless of whether you want to think about it in terms of the observed frequencies or in terms of the probabilities, the answer is the same. In general, when running the chi-square goodness of fit test for an experiment involving kk groups, then the degrees of freedom will be k−1k-1. 10.1.5 Testing the null hypothesis Figure 10.3: Illustration of how the hypothesis testing works for the chi-square goodness of fit test. The final step in constructing our hypothesis test is to figure out what the rejection region is. That is, what values of X2X^2 would lead us to reject the null hypothesis? As we saw earlier, large values of X2X^2 imply that the null hypothesis has done a poor job of predicting the data from our experiment, whereas small values of X2X^2 imply that it’s actually done pretty well. Therefore, a pretty sensible strategy would be to say there is some critical value, such that if X2X^2 is bigger than the critical value, we reject the null; but if X2X^2 is smaller than this value, we retain the null. In other words, to use the language we introduced in Chapter 9, the chi-squared goodness of fit test is always a one-sided test. If we want our test to have a significance level of α=.05\\alpha = .05 (that is, we are willing to tolerate a Type I error rate of 5%), then we have to choose our critical value so that there is only a 5% chance that X2X^2 could get to be that big if the null hypothesis is true. Meaning that we want the 95th percentile of the sampling distribution. This is illustrated in Figure 10.3. So if our X2X^2 statistic is bigger than 7.814728, then we can reject the null hypothesis. Since we calculated that before (i.e. X2=8.44X^2 = 8.44), we can reject the null. The corresponding pp-value is 0.03774185. This is the probability of getting a value of X2X^2 as big as 8.44, or bigger, if the null hypothesis is true. Since this is less than our significance level of α=.05\\alpha = .05, we can reject the null hypothesis. And that’s it, basically. You now know Pearson’s χ2\\chi^2 test for the goodness of fit. 10.1.6 How to report the results of the test If we wanted to write this result up for a paper or something, the conventional way to report this would be to write something like this: Of the 200 participants in the experiment, 64 selected hearts for their first choice, 51 selected diamonds, 50 selected spades, and 35 selected clubs. A chi-square goodness of fit test was conducted to test whether the choice probabilities were identical for all four suits. The results were significant (χ2(3)=8.44,p&lt;.05\\chi^2(3) = 8.44, p&lt;.05), suggesting that people did not select suits purely at random. This is pretty straightforward, and hopefully it seems pretty unremarkable. There are a few things that you should note about this description: The statistical test is preceded by descriptive statistics. That is, we told the reader something about what the data looked like before going on to do the test. In general, this is good practice: remember that your reader doesn’t know your data anywhere near as well as you do. So unless you describe it to them adequately, the statistical tests won’t make sense to them. The description tells you what the null hypothesis being tested is. Writers don’t always do this, but it’s often a good idea in those situations where some ambiguity exists; or when you can’t rely on your readership being intimately familiar with the statistical tools you’re using. Quite often, the reader might not know (or remember) all the details of the test that your using, so it’s a kind of politeness to “remind” them! As far as the goodness of fit test goes, you can usually rely on a scientific audience knowing how it works (since it’s covered in most intro stats classes). However, it’s still a good idea to explicitly state the null hypothesis (briefly!) because the null hypothesis can differ depending on your test. For instance, in the cards example our null hypothesis was that all the four suit probabilities were identical (i.e. P1=P2=P3=P4=0.25P_1 = P_2 = P_3 = P_4 = 0.25), but there’s nothing special about that hypothesis. We could just as easily have tested the null hypothesis that P1=0.7P_1 = 0.7 and P2=P3=P4=0.1P_2 = P_3 = P_4 = 0.1 using a goodness of fit test. So it’s helpful to the reader to explain your null hypothesis to them. Also, we described the null hypothesis in words, not in maths. That’s perfectly acceptable. You can describe it in maths if you like, but since most readers find words easier to read than symbols, most writers tend to describe the null using words if they can. A “stat block” is included. When reporting the results of the test itself, we didn’t just say that the result was significant; we included a “stat block” (i.e. the dense mathematical-looking part in the parentheses), which reports all the “raw” statistical data. For the chi-square goodness of fit test, the information that gets reported is the test statistic (that the goodness of fit statistic was 8.44), the information about the distribution used in the test (χ2\\chi^2 with 3 degrees of freedom, which is usually shortened to χ2(3)\\chi^2(3)), and then the information about whether the result was significant (in this case p&lt;.05p&lt;.05). The particular information that needs to go into the stat block is different for every test, and so each time we introduce a new test, we’ll show you what the stat block should look like. The results are interpreted. In addition to indicating that the result was significant, we provided an interpretation of the result (i.e. that people didn’t choose randomly). This is also a kindness to the reader because it tells them what they should believe about your data. If you don’t include something like this, it’s tough for your reader to understand what’s going on.42 As with everything else, your overriding concern should be that you explain things to your reader. 10.1.7 A comment on statistical notation (advanced) If you’ve been reading very closely, there is one thing about how we wrote up the chi-square test in the last section that might be bugging you a little bit. There’s something that feels a bit wrong with writing “χ2(3)=8.44\\chi^2(3) = 8.44”, you might be thinking. After all, it’s the goodness of fit statistic that is equal to 8.44, so shouldn’t I have written X2=8.44X^2 = 8.44 or maybe GOF=8.44=8.44? This seems to be conflating the sampling distribution (i.e. χ2\\chi^2 with df=3df = 3) with the test statistic (i.e. X2X^2). You figured it was a typo since χ\\chi and XX look pretty similar. Oddly, it’s not. Writing χ2(3)=8.44\\chi^2(3) = 8.44 is essentially a highly condensed way of writing “the sampling distribution of the test statistic is χ2(3)\\chi^2(3), and the value of the test statistic is 8.44”. In one sense, this is kind of stupid. There are lots of different test statistics out there that have a chi-square sampling distribution: the X2X^2 statistic that we’ve used for our goodness of fit test is only one of many (albeit one of the most commonly encountered ones). In a sensible, perfectly organised world, we’d always have a separate name for the test statistic and the sampling distribution: that way, the stat block itself would tell you precisely what it was that the researcher had calculated. Sometimes this happens. For instance, the test statistic used in the Pearson goodness of fit test is written X2X^2; but there’s a closely related test known as the GG-test43 (Sokal &amp; Rohlf, 1994), in which the test statistic is written as GG. As it happens, the Pearson goodness of fit test and the GG-test both test the same null hypothesis; and the sampling distribution is exactly the same (i.e. chi-square with k−1k-1 degrees of freedom). If we’d done a GG-test for the cards data rather than a goodness of fit test, then we’d have ended up with a test statistic of G=8.65G = 8.65, which is slightly different from the X2=8.44X^2 = 8.44; and produces a slightly smaller pp-value of p=.034p = .034. Suppose that the convention was to report the test statistic, then the sampling distribution, and then the pp-value. If that were true, then these two situations would produce different stat blocks: the original result would be written X2=8.44,χ2(3),p=.038X^2 = 8.44, \\chi^2(3), p = .038, whereas the new version using the GG-test would be written as G=8.65,χ2(3),p=.034G = 8.65, \\chi^2(3), p = .034. However, using the condensed reporting standard, the original result is written χ2(3)=8.44,p=.038\\chi^2(3) = 8.44, p = .038, and the new one is written χ2(3)=8.65,p=.034\\chi^2(3) = 8.65, p = .034, and so it’s actually unclear which test was actually run. So why don’t we live in a world where the stat block’s contents uniquely specify what tests were run? Any test statistic that follows a χ2\\chi^2 distribution is commonly called a “chi-square statistic”; anything that follows a tt-distribution is called a “tt-statistic” and so on. But, as the X2X^2 versus GG example illustrates, two different things with the same sampling distribution are still, well, different. Consequently, it’s sometimes a good idea to be clear about what the actual test was that you ran, especially if you’re doing something unusual. If you just say “chi-square test”, it’s unclear what test you’re talking about. Although, since the two most common chi-square tests are the goodness of fit test and the independence test (Section 10.2), most readers with stats training can probably guess. Nevertheless, it’s something to be aware of. 10.2 The χ2\\chi^2 test of independence (or association) The other day Danielle was watching an animated documentary examining the quaint customs of the natives of the planet Chapek 9. Apparently, in order to gain access to their capital city, a visitor must prove that they’re a robot, not a human. In order to determine whether or not the visitor is human, they ask whether the visitor prefers puppies, flowers or large, properly formatted data files. But what if humans and robots have the same preferences? That probably wouldn’t be a very good test then, would it? In order to determine whether or not a visitor is human, the natives of Chapek 9 need to know whether or not the visitor’s preferences are independent of their species. In other words, they need to know whether or not the visitor’s preferences are associated with their species. Figure 10.4: Loading the chapek9.csv data set into CogStat. In total, there are 180 entries in the data frame, one for each person (counting both robots and humans as “people”) who was asked to make a choice. Specifically, there are 93 humans and 87 robots. What we want to do is look at the choices broken down by species. That is, we need to cross-tabulate the data. We cannot use the Pivot table option in CogStat for strings, but we can use the Compare groups option instead. We’ll use the species variable as the grouping variable and the choices variable as the variable to compare. Figure 10.5: Using the Compare groups dialogue to get some information about choices by species. The overwhelmingly preferred choice is the data file. You can see a visual representation of this in Figure 10.6. Figure 10.6: The mosaic plot of choices by species. Scrolling down, you can see the descriptives for the groups in the Sample properties section: Figure 10.7: The Sample properties section of the Compare groups results showing the contingency table we’ll discuss later in this chapter. Let’s put these results in a table for our discussion on the χ2\\chi^2 test of independence. Table 10.1: Cross-tabulation of choices by species Robot Human Total Puppy 13 15 28 Flower 30 13 43 Data file 44 65 109 Total 87 93 180 It’s quite clear that most humans chose the data file, whereas the robots tended to be a lot more even in their preferences. Leaving aside the question of why humans might be more likely to choose the data file for the moment, first, we must determine if the discrepancy between human choices and robot choices in the data set is statistically significant. 10.2.1 Constructing our hypothesis test How do we analyse this data manually? Specifically, since our research hypothesis is that “humans and robots answer the question in different ways”, how can we construct a test of the null hypothesis that “humans and robots answer the question the same way”? As before, we begin by establishing some notation to describe the data: Robot Human Total Puppy O11O_{11} O12O_{12} R1R_{1} Flower O21O_{21} O22O_{22} R2R_{2} Data file O31O_{31} O32O_{32} R3R_{3} Total C1C_{1} C2C_{2} NN In this notation, we say that OijO_{ij} is a count (observed frequency) of the number of respondents that are of species jj (robot or human) who answered ii (puppy, flower or data) when asked to make a choice. The total number of observations is written NN, as usual. Finally, RiR_i denotes the row totals (e.g. R1R_1 is the total number of people who chose the flower), and CjC_j denotes the column totals (e.g., C1C_1 is the total number of robots). To use the terminology from another mathematical statistics textbook (Hogg et al., 2005), we should technically refer to this situation as a chi-square test of homogeneity; and reserve the term chi-square test of independence for the situation where both the row and column totals are random outcomes of the experiment. So now, let’s think about what the null hypothesis says. If robots and humans are responding in the same way to the question, it means that the probability that “a robot says puppy” is the same as the probability that “a human says puppy”, and so on for the other two possibilities. So, if we use PijP_{ij} to denote “the probability that a member of species jj gives response ii”, then our null hypothesis is that: Table 10.2: The null hypothesis for the χ2\\chi^2 test of independence of the chapek9 data set. H0H_0: All of the following are true: P11=P12P_{11} = P_{12} same probability of saying puppy P21=P22P_{21} = P_{22} same probability of saying flower P31=P32P_{31} = P_{32} same probability of saying data file Since the null hypothesis claims that the true choice probabilities don’t depend on the species of the person making the choice, we can let PiP_i refer to this probability: e.g. P1P_1 is the true probability of choosing the puppy. Next, in much the same way we did with the goodness of fit test, we need to calculate the expected frequencies. For each of the observed counts OijO_{ij}, we need to figure out what the null hypothesis would tell us to expect. Let’s denote this expected frequency by EijE_{ij}. This time, it’s a little bit trickier. If there are a total of CjC_j people that belong to species jj, and the true probability of anyone (regardless of species) choosing option ii is PiP_i, then the expected frequency is just: Eij=Cj×Pi E_{ij} = C_j \\times P_i This is all very well and good, but we have a problem. Unlike the situation we had with the goodness of fit test, the null hypothesis doesn’t specify a particular value for PiP_i. It’s something we have to estimate (Chapter 8) from the data! Fortunately, this is pretty easy to do. If 28 out of 180 people selected the flowers, then a natural estimate for the probability of choosing flowers is 28/18028/180, which is approximately .16.16. If we phrase this in mathematical terms, what we’re saying is that our estimate for the probability of choosing option ii is just the row total divided by the total sample size: P̂i=RiN \\hat{P}_i = \\frac{R_i}{N} Therefore, our expected frequency can be written as the product (i.e. multiplication) of the row total and the column total, divided by the total number of observations:44 Eij=Ri×CjN E_{ij} = \\frac{R_i \\times C_j}{N} Now that we’ve figured out how to calculate the expected frequencies, it’s straightforward to define a test statistic following the same strategy we used in the goodness of fit test. It’s pretty much the same statistic. For a contingency table with rr rows and cc columns, the equation that defines our X2X^2 statistic is X2=∑i=1r∑j=1c(Eij−Oij)2Eij X^2 = \\sum_{i=1}^r \\sum_{j=1}^c \\frac{({E}_{ij} - O_{ij})^2}{{E}_{ij}} The only difference is that we have to include two summation signs (i.e. ∑\\sum) to indicate that we’re summing over both rows and columns. As before, large values of X2X^2 suggest that the null hypothesis provides a poor description of the data, whereas small values of X2X^2 indicate that it does a good job of accounting for the data. Therefore, just like last time, we want to reject the null hypothesis if X2X^2 is too large. Not surprisingly, this statistic is χ2\\chi^2 distributed. All we need to do is figure out how many degrees of freedom are involved, which actually isn’t too hard. You can think of the degrees of freedom as equal to the number of data points you’re analysing minus the number of constraints. A contingency table with rr rows and cc columns contains a total of r×cr \\times c observed frequencies, so that’s the total number of observations. What about the constraints? Here, it’s slightly trickier. The answer is always the same: df=(r−1)(c−1) df = (r-1)(c-1) But the explanation for why the degrees of freedom take this value is different depending on the experimental design. For the sake of argument, let’s suppose that we had honestly intended to survey exactly 87 robots and 93 humans (column totals fixed by the experimenter) but left the row totals free to vary (row totals are random variables). Let’s think about the constraints that apply here. Well, since we deliberately fixed the column totals, we have cc constraints right there. There’s more to it than that. Remember how our null hypothesis had some free parameters (i.e. we had to estimate the PiP_i values)? Those matter too. Every free parameter in the null hypothesis is rather like an additional constraint. So, how many of those are there? Well, since these probabilities have to sum to 1, there’s only r−1r-1 of these. So our total degree of freedom is: df=(number of observations)−(number of constraints)=(rc)−(c+(r−1))=rc−c−r+1=(r−1)(c−1) \\begin{array}{rcl} df &amp;=&amp; \\mbox{(number of observations)} - \\mbox{(number of constraints)} \\\\ &amp;=&amp; (rc) - (c + (r-1)) \\\\ &amp;=&amp; rc - c - r + 1 \\\\ &amp;=&amp; (r - 1)(c - 1) \\end{array} Alternatively, suppose that the only thing that the experimenter fixed was the total sample size NN. That is, we quizzed the first 180 people that we saw, and it just turned out that 87 were robots and 93 were humans. This time around, our reasoning would be slightly different but would still lead us to the same answer. Our null hypothesis still has r−1r-1 free parameters corresponding to the choice probabilities. Still, it now also has c−1c-1 free parameters corresponding to the species probabilities because we’d also have to estimate the probability that a randomly sampled person turns out to be a robot.45 Finally, since we did fix the total number of observations NN, that’s one more constraint. So now we have, rcrc observations, and (c−1)+(r−1)+1(c-1) + (r-1) + 1 constraints. What does that give? df=(number of observations)−(number of constraints)=rc−((c−1)+(r−1)+1)=rc−c−r+1=(r−1)(c−1) \\begin{array}{rcl} df &amp;=&amp; \\mbox{(number of observations)} - \\mbox{(number of constraints)} \\\\ &amp;=&amp; rc - ( (c-1) + (r-1) + 1) \\\\ &amp;=&amp; rc - c - r + 1 \\\\ &amp;=&amp; (r - 1)(c - 1) \\end{array} Amazing. 10.2.2 The test results in CogStat The test is automatically done in CogStat using the Compare groups feature. The result set will contain information about the sample and its properties, as seen in Figure 10.7. Further scrolling down, you’ll see the effect size (which we will cover in a short while in Chapter 10.4). The last part of the result set is the hypothesis test itself (see Figure 10.8). Figure 10.8: Population properties and Hypothesis tests for the chapek9.csv data set. Let us go through the Hypothesis tests section line by line. Hypothesis tests Testing if the distributions are the same.One grouping variable. Two groups. Nominal variable. &gt;&gt; Running chi-squared test. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in w: 0.29. Result of the Pearson's chi-squared test: &#967;2(2, N = 180) = 10.72, p = .005 Testing if the distributions are the same.: This, in plain English, tells us that we are testing for a null hypothesis where all distributions of all group, or probabilities, are the same. It does not differ in essence from the H0H_0 we described more eloquently in Table 10.2. One grouping variable.: This says we are looking at only one variable by which we have dissected our data: species. Two groups: This tells us that we have two groups, robot and human. Nominal variable.: This tells us that the variable we are looking at is categorical. Running chi-squared test.: Based on all the above, CogStat has decided to run a χ2\\chi^2 test. Let us ignore the details about the 95% confidence interval, minimal effect size w, and Cramér’s V (Figure 10.8) for now. We will come back to them in Chapter 10.4. Result of the Pearson's chi-squared test: χ2(2,N=180)=10.72,p=0.005 \\chi^2(2, N = 180) = 10.72, p = 0.005 The test result is 10.72, the degree of freedom is 2 with 180 observations, and the p-value is 0.005. This means that the null hypothesis is rejected at the 0.005 level of significance. This output gives us enough information to write up the result: Pearson’s χ2\\chi^2 revealed a significant association between species and choice (χ2(2,N=180)=10.72,p&lt;.01\\chi^2(2, N = 180) = 10.72, p &lt; .01): robots appeared to be more likely to say that they prefer flowers, but the humans were more likely to say they prefer data. Notice that, once again, we provided a little bit of interpretation to help the human reader understand what’s going on with the data. This is a good habit to get into. It’s also a good idea to report the effect size, which we will do in the next section. 10.3 Yates correction for 1 degree of freedom Time for a little bit of a digression. You need to make a tiny change to your calculations whenever you only have 1 degree of freedom. It’s called the continuity correction, or sometimes the Yates correction. The χ2\\chi^2 test is based on an approximation, specifically on the assumption that binomial distribution starts to look like a normal distribution for large NN. One problem with this is that it often doesn’t quite work, especially when you’ve only got 1 degree of freedom (e.g. when you’re doing a test of independence on a 2×22 \\times 2 contingency table). The main reason for this is that the true sampling distribution for the X2X^2 statistic is actually discrete (because you’re dealing with categorical data!), but the χ2\\chi^2 distribution is continuous. This can introduce systematic problems. Specifically, when NN is small and when df=1df=1, the goodness of fit statistic tends to be “too big”, meaning that you actually have a bigger α\\alpha value than you think (or, equivalently, the pp values are a bit too small). Yates (1934) suggested a simple fix, in which you redefine the goodness of fit statistic as: X2=∑i(|Ei−Oi|−0.5)2Ei X^2 = \\sum_{i} \\frac{(|E_i - O_i| - 0.5)^2}{E_i} Basically, he subtracts off 0.5 everywhere. The correction is basically a hack. It’s not derived from any principled theory: rather, it’s based on an examination of the behaviour of the test and observing that the corrected version seems to work better. CogStat (and many other software, for that matter) introduces this correction, so it’s useful to know what it is about. You won’t know when it happens because the CogStat output doesn’t explicitly say that it has used a “continuity correction” or “Yates’ correction”.46 Let us overwrite all the puppy answers in our chapek9 data frame to look at 1 degree of freedom (Figure 10.9). Let’s use the chapek9two.csv data set for this. Figure 10.9: CogStat results for chapek9two.csv with 1 degree of freedom The result as calculated by default with the Yates correction is: χ2(1,N=180)=6.24,p=0.013 \\chi^2(1, N = 180) = 6.24, p = 0.013 However, had we not applied the Yates correction, the results would have been χ2(2,N=180)=7.02,p=0.008\\chi^2(2, N = 180) = 7.02, p = 0.008, which is a bit different. The difference is not huge, but it is there. The Yates correction is a good thing to know about, but it’s not something you need to worry about too much. It’s just a little bit of a hack that makes the test work better in this specific case. 10.4 Effect size (Cramér’s VV) As we discussed earlier in Chapter 9.7, it’s becoming commonplace to ask researchers to report some measure of effect size. So, suppose that you’ve run your chi-square test, which turns out to be significant. So you now know that there is some association between your variables (independence test) or some deviation from the specified probabilities (goodness of fit test). Now you want to report a measure of effect size. That is, given that there is an association/deviation, how strong is it? There are several different measures you can choose to report and several different tools you can use to calculate them. By default, the two measures that people tend to report most frequently are the ϕ\\phi (pronounced: “phi”) statistic and the somewhat superior version, known as Cramér’s VV. While CogStat gives you only Cramér’s VV, we need to start with ϕ\\phi because they are related. Mathematically, they’re both very simple. To calculate the ϕ\\phi statistic, you just divide your X2X^2 value by the sample size and take the square root: ϕ=X2N \\phi = \\sqrt{\\frac{X^2}{N}} The idea here is that the ϕ\\phi statistic is supposed to range between 0 (no association at all) and 1 (perfect association). However, it doesn’t always do this when your contingency table is bigger than 2×22 \\times 2 (like in our original chapek9 data set), which is a total pain. So, to correct this, people usually prefer to report the VV statistic proposed by Cramér (1946). It’s a pretty simple adjustment to ϕ\\phi. If you’ve got a contingency table with rr rows and cc columns, then define k=min(r,c)k = \\min(r,c) to be the smaller of the two values. If so, then Cramér’s VV statistic is ϕc=X2N(k−1) \\phi_c = \\sqrt{\\frac{X^2}{N(k-1)}} And you’re done. This seems to be a reasonably popular measure, presumably because it’s easy to calculate, and it gives answers that aren’t completely silly: you know that VV does range from 0 (no association at all) to 1 (perfect association). Calculating VV is automatic in CogStat, as you’ve seen in the result sets earlier in both the original chapek9 data set (Figure 10.8) and the modified one (Figure 10.9). Now let’s look at the original chapek9 effect size. Standardized effect sizes Value Cram&eacute;r's V measure of association &#981;c = 0.244 A Cramer’s V of 0.244 tells us that there is a moderate association between the two variables. The usual guidance is that anything below 0.2 is a weak association, 0.2 to 0.6 is a moderate association, and anything above 0.6 is a strong association. However, you must always look at the context of your data when determining the effect size. 10.5 Assumptions of the test(s) All statistical tests make assumptions, and it’s usually a good idea to check that those assumptions are met. For the chi-square tests discussed so far in this chapter, the assumptions are: Expected frequencies are sufficiently large. Remember how in the previous section, we saw that the χ2\\chi^2 sampling distribution emerges because the binomial distribution is similar to a normal distribution? Well, as we discussed in Chapter 7, this is only true when the number of observations is sufficiently large. What that means in practice is that all of the expected frequencies need to be reasonably big. How big is reasonably big? Opinions differ, but the default assumption seems to be that you generally would like to see all your expected frequencies larger than about 5, though for larger tables, you would probably be okay if at least 80% of the expected frequencies are above 5 and none of them are below 1. However, these seem to have been proposed as rough guidelines, not hard and fast rules; and they seem somewhat conservative (Larntz, 1978). Data are independent of one another. One somewhat hidden assumption of the chi-square test is that you have to believe that the observations are genuinely independent. Suppose we are interested in the proportion of babies born at a particular hospital that are boys. We walk around the maternity wards and observe 20 girls and only 10 boys. Seems like a pretty convincing difference, right? But later on, it turns out that we’d actually walked into the same ward 10 times, and in fact, we’d only seen 2 girls and 1 boy. Not as convincing, is it? Our original 30 observations were massively non-independent. And were only, in fact, equivalent to 3 independent observations. Obviously, this is an extreme(ly silly) example, but it illustrates the fundamental issue. Non-independence “stuffs things up”. Sometimes it causes you to falsely reject the null, as the silly hospital example illustrates, but it can go the other way too. Let’s consider what would happen if we’d done the cards experiment slightly differently: instead of asking 200 people to try to imagine sampling one card at random, suppose we asked 50 people to select 4 cards. One possibility would be that everyone selects one heart, one club, one diamond and one spade (in keeping with the “representativeness heuristic”; Tversky &amp; Kahneman 1974). This is highly non-random behaviour from people, but in this case, we would get an observed frequency of 50 for all four suits. For this example, the fact that the observations are non-independent (because the four cards that you pick will be related to each other) actually leads to the opposite effect, falsely retaining the null. If you find yourself in a situation where independence is violated, it may be possible to use the McNemar test. Similarly, if your expected cell counts are too small, check out the Fisher exact test. 10.6 The Fisher exact test What should you do if your cell counts are too small, but you’d still like to test the null hypothesis that the two variables are independent? One answer would be “collect more data”, but that’s far too glib: there are a lot of situations in which it would be either infeasible or unethical to do. If so, statisticians are morally obligated to provide scientists with better tests. In this instance, Fisher (1922) kindly provided the right answer to the question. To illustrate the basic idea, let’s suppose we’re analysing data from a field experiment, looking at the emotional status of people accused of witchcraft. Some of them are currently being burned at the stake.47 Unfortunately for the scientist (but rather fortunately for the general populace), it’s quite hard to find people in the process of being set on fire, so the cell counts are microscopic. The salem.csv file illustrates the point. Figure 10.10: The salem data set Looking at this data, you’d be hard pressed not to suspect that people not on fire are more likely to be happy than people on fire. However, the chi-square test (even with the Yates correction for the 2x2 data) makes this very hard to test because of the small sample size. We’d really like to be able to get a better answer than this provided we really don’t want to be on fire. This is where Fisher’s exact test (Fisher, 1922a) comes in very handy. The Fisher exact test works somewhat differently to the chi-square test (or in fact any of the other hypothesis tests in this book) insofar as it doesn’t have a test statistic; it calculates the pp-value “directly”. Let’s have some notation: Happy Sad Total Set on fire O11O_{11} O12O_{12} R1R_{1} Not set on fire O21O_{21} O22O_{22} R2R_{2} Total C1C_{1} C2C_{2} NN In order to construct the test Fisher treats both the row and column totals (R1R_1, R2R_2, C1C_1 and C2C_2) are known, fixed quantities; and then calculates the probability that we would have obtained the observed frequencies that we did (O11O_{11}, O12O_{12}, O21O_{21} and O22O_{22}) given those totals. In the notation that we developed in Chapter 7 this is written: P(O11,O12,O21,O22|R1,R2,C1,C2) P(O_{11}, O_{12}, O_{21}, O_{22} \\ | \\ R_1, R_2, C_1, C_2) and as you might imagine, it’s a slightly tricky exercise to figure out what this probability is, but it turns out that this probability is described by a distribution known as the hypergeometric distribution. Now that we know this, what we have to do to calculate our pp-value is calculate the probability of observing this particular table or a table that is “more extreme”.48 Back in the 1920s, computing this sum was daunting even in the simplest of situations, but these days it’s pretty easy as long as the tables aren’t too big and the sample size isn’t too large. The conceptually tricky issue is to figure out what it means to say that one contingency table is more “extreme” than another. The easiest solution is to say that the table with the lowest probability is the most extreme. This then gives us the pp-value of 0.035710.03571. The implementation of the test in CogStat is not yet available. The main thing we’re interested in here is the pp-value, which in this case is small enough (p=.036p=.036) to justify rejecting the null hypothesis that people on fire are just as happy as people not on fire. 10.7 The McNemar test Suppose you’ve been hired to work for the Australian Generic Political Party (AGPP), and part of your job is to find out how effective the AGPP political advertisements are. So, what you do, is you put together a sample of N=100N=100 people and ask them to watch the AGPP ads. Before they see anything, you ask them if they intend to vote for the AGPP; after showing the ads, you ask them again to see if anyone has changed their minds. One way to describe your data is via the following contingency table: Before After Total Yes 30 10 40 No 70 90 160 Total 100 100 200 At first pass, you might think that this situation lends itself to the Pearson χ2\\chi^2 test of independence (as per Chapter 10.2). However, we’ve got a problem: we have 100 participants but 200 observations. This is because each person has given us an answer in both the before and after columns. What this means is that the 200 observations aren’t independent of each other: if voter A says “yes” the first time and voter B says “no”, then you’d expect that voter A is more likely to say “yes” the second time than voter B! The consequence of this is that the usual χ2\\chi^2 test won’t give trustworthy answers due to the violation of the independence assumption. Now, if this were a really uncommon situation, I wouldn’t be bothering to waste your time talking about it. But it’s not uncommon at all: this is a standard repeated measures design, and none of the tests we’ve considered so far can handle it. The solution to the problem was published by McNemar (1947). The trick is to start by tabulating your data in a slightly different way: Before: Yes Before: No Total After: Yes 5 5 10 After: No 25 65 90 Total 30 70 100 This is exactly the same data, but it’s been rewritten so that each of our 100 participants appears in only one cell. Because we’ve written our data this way, the independence assumption is now satisfied, and this is a contingency table that we can use to construct an X2X^2 goodness of fit statistic. However, as we’ll see, we need to do it in a slightly nonstandard way. To see what’s going on, it helps to label the entries in our table a little differently: Before: Yes Before: No Total After: Yes aa bb a+ba+b After: No cc dd c+dc+d Total a+ca+c b+db+d nn Next, let’s think about what our null hypothesis is: it’s that the “before” test and the “after” test have the same proportion of people saying, “Yes, I will vote for AGPP”. Because of the way we have rewritten the data, it means that we’re now testing the hypothesis that the row totals and column totals come from the same distribution. Thus, the null hypothesis in McNemar’s test is that we have “marginal homogeneity”. That is, the row totals and column totals have the same distribution: Pa+Pb=Pa+PcP_a + P_b = P_a + P_c, and similarly that Pc+Pd=Pb+PdP_c + P_d = P_b + P_d. Notice that this means that the null hypothesis actually simplifies to Pb=PcP_b = P_c. In other words, as far as the McNemar test is concerned, it’s only the off-diagonal entries in this table (i.e. bb and cc) that matter! After noticing this, the McNemar test of marginal homogeneity is no different to a usual χ2\\chi^2 test. After (automatically) applying the Yates correction, our test statistic becomes: X2=(|b−c|−0.5)2b+c X^2 = \\frac{(|b-c| - 0.5)^2}{b+c} or, to revert to the notation that we used earlier in this chapter: X2=(|O12−O21|−0.5)2O12+O21 X^2 = \\frac{(|O_{12}-O_{21}| - 0.5)^2}{O_{12} + O_{21}} and this statistic has an (approximately) χ2\\chi^2 distribution with df=1df=1. However, remember that – just like the other χ2\\chi^2 tests – it’s only an approximation, so you need to have reasonably large expected cell counts for it to work. Now that you know what the McNemar test is all about, lets actually run one. The agpp.csv file contains the raw data. It contains three variables, an id variable that labels each participant in the data set, a responseBefore variable that records the person’s answer when they were asked the question the first time, and a responseAfter variable that shows the answer that they gave when asked the same question a second time. Let us think what we want to do here. We have the same participants giving us two answers. We want to test whether the two answers (the before and the after) are independent of each other. Or, in other words, we want to compare a reapeated measure. In CogStat, we need to select Compare repeated measures variables and add the responseBefore and responseAfter variables to the Selected variables box to run an analysis (Figure 10.11). The results are shown in Figure 10.12. Figure 10.11: Repeated measures analysis of the AGPP data in CogStat. Figure 10.12: Results of the repeated measures analysis of the AGPP data in CogStat. Hypothesis tests Testing if the distributions are the same. Two variables. Nominal dichotomous variables. &gt;&gt; Running McNemar test. Result of the McNemar test: &#967;2(1, N = 100) = 12.03, p &lt; .001 And we’re done. We’ve just run a McNemar’s test automatically, since our data set was identified by CogStat as categorical data. The results would tell us something like this: The test was significant (χ2(1)=12.03,p&lt;.001\\chi^2(1) = 12.03, p&lt;.001), suggesting that people were not just as likely to vote AGPP after the ads as they were before hand. In fact, the ads had a negative effect: people were less likely to vote AGPP after seeing the ads. 10.8 What’s the difference between McNemar and independence? Let’s go back to the beginning of the chapter and look at the cards data set again. If you recall, the experimental design described involved people making two choices. Because we have information about the first choice and the second choice that everyone made, we can construct the following contingency table that cross-tabulates the first choice against the second choice. Table 10.3: Contingency table for the cards data set as seen in CogStat when runnig Compare repeated measures variables or Explore relation of variable pair. clubs diamonds hearts spades Total clubs 10 9 10 6 35 diamonds 20 4 13 14 51 hearts 20 18 3 23 64 spades 18 13 15 4 50 Total 68 44 41 47 200 First, we wanted to know whether the choice you make the second time is dependent on the choice you made the first time (for this, we’ll run the Explore relation of variable pair analysis). This is where a test of independence is useful, and what we’re trying to do is see if there’s some relationship between the rows and columns of this table. Second, we wanted to know if on average, the frequencies of suit choices were different the second time than the first time. In that situation, we’re trying to see if the row totals in cardChoices (i.e. the frequencies for choice_1) are different from the column totals (i.e. the frequencies for choice_2). That’s when we’d use the McNemar test. However, when running the Compare repeated measures variables analysis, we get an error, as the function for non-dichotomous nominal data is not implemented yet. Here’s the result if we run the Explore relation of variable pair analysis in CogStat: Hypothesis tests Testing if variables are independent. Nominal variables. &gt;&gt; Running Cram&eacute;r's V. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in w: 0.34. Result of the Pearson's chi-squared test: &#967;2(9, N = 200) = 29.24, p &lt; .001 Figure 10.13: Hypothesis test results when running either Compare repeated measures variables or Explore relation of variable pair in CogStat. For the second case, running the McNemar test, the answer would be McNemar’s chi-squared = 16.0316.03, df = 66, p-value = 0.0140.014. This is a significant result, suggesting that the frequencies of suit choices were different the second time than the first time. Notice that the results are different! These aren’t the same test. 10.9 Summary The key ideas discussed in this chapter are: The chi-square goodness of fit test (Section 10.1) is used when you have a table of observed frequencies of different categories; the null hypothesis gives you a set of “known” probabilities to compare them to. The chi-square test of independence (Section 10.2) is used when you have a contingency table (cross-tabulation) of two categorical variables. The null hypothesis is that there is no relationship/association between the variables. Effect size for a contingency table can be measured in several ways (Section 10.4). In particular, we noted the Cramér’s VV statistic. Both versions of the Pearson test rely on two assumptions: that the expected frequencies are sufficiently large and that the observations are independent (Section 10.5). The Fisher exact test (Section 10.6) can be used when the expected frequencies are small. The McNemar test (Section 10.7) can be used for some kinds of violations of independence. If you’re interested in learning more about categorical data analysis, an excellent first choice would be Agresti (1996), which, as the title suggests, provides an Introduction to Categorical Data Analysis. If the introductory book isn’t enough for you (or you can’t solve the problem you’re working on), you could consider Agresti (2002), Categorical Data Analysis. The latter is a more advanced text, so it’s probably not wise to jump straight from this book to that one. References Agresti, A. (1996). An introduction to categorical data analysis. Wiley. Agresti, A. (2002). Categorical data analysis (2nd ed.). Wiley. Cramér, H. (1946). Mathematical methods of statistics. Princeton University Press. Fisher, R. A. (1922a). On the interpretation of χ2\\chi^2 from contingency tables, and the calculation of pp. Journal of the Royal Statistical Society, 84, 87–94. Hogg, R. V., McKean, J. V., &amp; Craig, A. T. (2005). Introduction to mathematical statistics (6th ed.). Pearson. Larntz, K. (1978). Small-sample comparisons of exact levels for chi-squared goodness-of-fit statistics. Journal of the American Statistical Association, 73, 253–263. McNemar, Q. (1947). Note on the sampling error of the difference between correlated proportions or percentages. Psychometrika, 12, 153–157. Pearson, K. (1900). On the criterion that a given system of deviations from the probable in the case of a correlated system of variables is such that it can be reasonably supposed to have arisen from random sampling. Philosophical Magazine, 50, 157–175. Sokal, R. R., &amp; Rohlf, F. J. (1994). Biometry: The principles and practice of statistics in biological research (3rd ed.). Freeman. Yates, F. (1934). Contingency tables involving small numbers and the χ2\\chi^2 test. Supplement to the Journal of the Royal Statistical Society, 1, 217–235. This, again, is an over-simplification. It works nicely for quite a few situations, but every now and then, we’ll come across degrees of freedom values that aren’t whole numbers. Don’t let this worry you too much – when you come across this, just remind yourself that “degrees of freedom” is actually a bit of a messy concept. For an introductory class, it’s usually best to stick to the simple story.↩︎ In practice, the sample size isn’t always fixed… e.g. we might run the experiment over a fixed period of time, and the number of people participating depends on how many people show up. That doesn’t matter for the current purposes.↩︎ To some people, this advice might sound odd or at least in conflict with the “usual” advice on how to write a technical report. Students are typically told that the “results” section of a report is for describing the data and reporting statistical analysis, and the “discussion” section provides interpretation. That’s true as far as it goes, but people often interpret it way too literally. Provide a quick and simple interpretation of the data in the results section so that the reader understands what the data are telling us. Then, in the discussion, try to tell a bigger story; about how my results fit the rest of the scientific literature. In short, don’t let the “interpretation goes in the discussion” advice turn your results section into incomprehensible garbage. Being understood by your reader is much more important.↩︎ Complicating matters, the GG-test is a special case of a whole class of tests that are known as likelihood ratio tests.↩︎ Technically, EijE_{ij} here is an estimate, so we should probably write it Êij\\hat{E}_{ij}.↩︎ A problem many of us worry about in real life.↩︎ Technically, CogStat uses chi2_contingency function from scipy without specifying the correction parameter which defaults to true.↩︎ This example is based on a joke article published in the Journal of Irreproducible Results.↩︎ Not surprisingly, the Fisher exact test is motivated by Fisher’s interpretation of a pp-value, not Neyman’s!↩︎ "],["ttest.html", "Chapter 11 Comparing two means 11.1 The one-sample zz-test 11.2 The one-sample tt-test 11.3 The independent samples tt-test (Student test) 11.4 The independent samples tt-test (Welch test) 11.5 The paired-samples tt-test 11.6 Effect size (Cohen’s dd) 11.7 Normality of a sample 11.8 Testing non-normal data with Wilcoxon tests 11.9 Summary", " Chapter 11 Comparing two means In the previous chapter, we covered the situation when your outcome variable is a nominal scale, and your predictor variable is also a nominal scale. Many real-world situations have that character, so you’ll find that chi-square tests are widely used. However, you’re much more likely to find yourself in a situation where your outcome variable is interval scale or higher, and you’re interested in whether the outcome variable’s average value is higher in one group or another. For instance, a psychologist might want to know if anxiety levels are higher among parents than non-parents; or if working memory capacity is reduced by listening to music (relative to not listening to music). In a medical context, we might want to know if a new drug increases or decreases blood pressure. An agricultural scientist might want to know whether adding phosphorus to Australian native plants will kill them. In all these situations, our outcome variable is a continuous interval or ratio scale variable; and our predictor is a binary “grouping” variable. In other words, we want to compare the means of the two groups. The standard answer to the problem of comparing means is to use a tt-test, which has several varieties depending on exactly what question you want to solve. As a consequence, the majority of this chapter focuses on different types of tt-test: one-sample tt-tests are discussed in Chapter 11.2, independent samples tt-tests are discussed in Sections 11.3 and 11.4, and paired samples tt-tests are discussed in Chapter 11.5. After that, we’ll talk a bit about Cohen’s dd, which is the standard measure of effect size for a tt-test (Section 11.6). The later sections of the chapter focus on the assumptions of the tt-tests and possible remedies if they are violated. However, before discussing any of these useful things, we’ll start with a discussion of the zz-test. 11.1 The one-sample zz-test In this section, we’ll discuss one of the most useless tests in all of statistics: the zz-test. Seriously – this test is seldom used in real life. Its only real purpose is that, when teaching statistics, it’s a very convenient stepping stone towards the tt-test, which is probably the most (over)used tool in all statistics. Let’s use a simple example to introduce the idea behind the zz-test. A friend of Danielle’s, Dr Zeppo, grades his introductory statistics class on a curve. Let’s suppose that the average grade in his class is 67.5, and the standard deviation is 9.5. Of his many hundreds of students, it turns out that 20 of them also take psychology classes. Out of curiosity: do psychology students tend to get the same grades as everyone else (i.e. mean 67.5), or do they tend to score higher or lower? Let’s explore this by looking at the zeppo.csv data file by loading the file to CogStat. Figure 11.1: The zeppo.csv data file loaded into CogStat. Let’s explore the data a bit by looking at some summary statistics with the Explore variable function. Figure 11.2: The Explore variable function in CogStat. The mean is 72.372.3. Hm. It might be that the psychology students are scoring a bit higher than normal: that sample mean of X‾=72.3\\bar{X} = 72.3 is a fair bit higher than the hypothesised population mean of μ=67.5\\mu = 67.5, but on the other hand, a sample size of N=20N = 20 isn’t all that big. Maybe it’s pure chance. To answer the question, it helps to be able to write down what it is that we know. Firstly, we know that the sample mean is X‾=72.3\\bar{X} = 72.3. If we assume that the psychology students have the same standard deviation as the rest of the class, then we can say that the population standard deviation is σ=9.5\\sigma = 9.5. We’ll also assume that since Dr Zeppo is grading to a curve, the psychology student grades are normally distributed. Next, it helps to be clear about what we want to learn from the data. In this case, the research hypothesis relates to the population mean μ\\mu for the psychology student grades, which is unknown. Specifically, we want to know if μ=67.5\\mu = 67.5 or not. Given that this is what we know, can we devise a hypothesis test to solve our problem? The data, along with the hypothesised distribution from which they are thought to arise, are shown in Figure 11.3. Not entirely obvious what the right answer is, is it? For this, we are going to need some statistics. Figure 11.3: The theoretical distribution (dashed green line) from which the psychology student grades (blue bars) are generated in CogStat at the Population properties section of our result set. The first step in constructing a hypothesis test is to be clear about what the null and alternative hypotheses are. This isn’t too hard to do. Our null hypothesis, H0H_0, is that the true population mean μ\\mu for psychology student grades is 67.5; and our alternative hypothesis is that the population mean isn’t 67.5. If we write this in mathematical notation, these hypotheses become, H0:μ=67.5H1:μ≠67.5 \\begin{array}{ll} H_0: &amp; \\mu = 67.5 \\\\ H_1: &amp; \\mu \\neq 67.5 \\end{array} though to be honest, this notation doesn’t add much to our understanding of the problem, it’s just a compact way of writing down what we’re trying to learn from the data. The null hypotheses H0H_0 and the alternative hypothesis H1H_1 for our test are both illustrated in Figure 11.4. In addition to providing us with these hypotheses, the scenario outlined above provides us with a fair amount of background knowledge that might be useful. Specifically, there are two special pieces of information that we can add: The psychology grades are normally distributed. The true standard deviation of these scores σ\\sigma is known to be 9.5. For the moment, we’ll act as if these are absolutely trustworthy facts. In real life, this kind of absolutely trustworthy background knowledge doesn’t exist, and so if we want to rely on these facts we’ll just have make the assumption that these things are true. However, since these assumptions may or may not be warranted, we might need to check them. For now though, we’ll keep things simple. Figure 11.4: Graphical illustration of the null and alternative hypotheses assumed by the one-sample zz-test (the two sided version, that is). The null and alternative hypotheses both assume that the population distribution is normal, and additionally assumes that the population standard deviation is known (fixed at some value σ0\\sigma_0). The null hypothesis (left) is that the population mean μ\\mu is equal to some specified value μ0\\mu_0. The alternative hypothesis is that the population mean differs from this value, μ≠μ0\\mu \\neq \\mu_0. The next step is to figure out what would be a good choice for a diagnostic test statistic, something that would help us discriminate between H0H_0 and H1H_1. Given that the hypotheses all refer to the population mean μ\\mu, you’d feel confident that the sample mean X‾\\bar{X} would be a helpful place to start. We could look at the difference between the sample mean X‾\\bar{X} and the value that the null hypothesis predicts for the population mean. In our example, that would mean we calculate X‾−67.5\\bar{X} - 67.5. More generally, if we let μ0\\mu_0 refer to the value that the null hypothesis claims is our population mean, then we’d want to calculate X‾−μ0 \\bar{X} - \\mu_0 If this quantity equals or is very close to 0, things are looking good for the null hypothesis. If this quantity is a long way away from 0, then it looks less likely that the null hypothesis is worth retaining. But how far away from zero should it be for us to reject H0H_0? To figure that out, we need to be a bit more sneaky, and we’ll need to rely on those two pieces of background knowledge shared previously, namely that the raw data are normally distributed, and we know the value of the population standard deviation σ\\sigma. If the null hypothesis is actually true, and the true mean is μ0\\mu_0, then these facts together mean that we know the complete population distribution of the data: a normal distribution with mean μ0\\mu_0 and standard deviation σ\\sigma. Adopting the notation from Chapter 7.4.2, a statistician might write this as: X∼Normal(μ0,σ2) X \\sim \\mbox{Normal}(\\mu_0,\\sigma^2) Okay, if that’s true, then what can we say about the distribution of X‾\\bar{X}? Well, as we discussed earlier (see Chapter 8.3.3), the sampling distribution of the mean X‾\\bar{X} is also normal, and has mean μ\\mu. But the standard deviation of this sampling distribution SE(X‾)\\mbox{SE}({\\bar{X}}), which is called the standard error of the mean, is SE(X‾)=σN \\mbox{SE}({\\bar{X}}) = \\frac{\\sigma}{\\sqrt{N}} In other words, if the null hypothesis is true then the sampling distribution of the mean can be written as follows: X‾∼Normal(μ0,SE(X‾)) \\bar{X} \\sim \\mbox{Normal}(\\mu_0,\\mbox{SE}({\\bar{X}})) Now comes the trick. What we can do is convert the sample mean X‾\\bar{X} into a standard score (Section 5.4). This is conventionally written as zz, but for let us refer to it as zX‾z_{\\bar{X}}. (The reason for using this expanded notation is to help you remember that we’re calculating standardised version of a sample mean, not a standardised version of a single observation, which is what a zz-score usually refers to). When we do so, the zz-score for our sample mean is zX‾=X‾−μ0SE(X‾) z_{\\bar{X}} = \\frac{\\bar{X} - \\mu_0}{\\mbox{SE}({\\bar{X}})} or, equivalently zX‾=X‾−μ0σ/N z_{\\bar{X}} = \\frac{\\bar{X} - \\mu_0}{\\sigma / \\sqrt{N}} This zz-score is our test statistic. The nice thing about using this as our test statistic is that like all zz-scores, it has a standard normal distribution: zX‾∼Normal(0,1) z_{\\bar{X}} \\sim \\mbox{Normal}(0,1) In other words, regardless of what scale the original data are on, the zz-statistic itself always has the same interpretation: it’s equal to the number of standard errors that separate the observed sample mean X‾\\bar{X} from the population mean μ0\\mu_0 predicted by the null hypothesis. Better yet, regardless of what the population parameters for the raw scores actually are, the 5% critical regions for zz-test are always the same, as illustrated in Figures 11.5 and 11.6. And what this meant, way back in the days where people did all their statistics by hand, is that someone could publish a table like this: desired α\\alpha level two-sided test one-sided test .1 1.644854 1.281552 .05 1.959964 1.644854 .01 2.575829 2.326348 .001 3.290527 3.090232 which in turn meant that researchers could calculate their zz-statistic by hand, and then look up the critical value in a text book. That was an incredibly handy thing to be able to do back then. Figure 11.5: Rejection regions for the one-sided zz-test Figure 11.6: Rejection regions for the two-sided zz-test Now, as mentioned earlier, the zz-test is almost never used in practice. However, the test is so incredibly simple that it’s really easy to do one manually. Let’s go back to the data from Dr Zeppo’s class. However, we’re not going to use CogStat for the rest of this section, because it will automatically (and correctly) use the population parameter estimates, that will actually come in handy in the tt-test section. So from now on, let’s just follow the logic without the urge to try to replicate it. The sample size is 2020 (we know this from Figure 11.1). The mean is 72.372.3 (we know this from Figure 11.2). The point estimation for standard deviation is 9.59.5 (we have to just believe this for the example’s sake because we said so earlier). The null hypothesis is that the mean is 67.567.5. Next, let’s calculate the (true) standard error of the mean: 9.520=2.1243 \\frac{9.5}{\\sqrt{20}} = 2.1243 And finally, we calculate our zz-score: 72.3−67.52.1243=2.2596 \\frac{72.3-67.5}{2.1243} = 2.2596 At this point, we would traditionally look up the value 2.26 in our table of critical values. Our original hypothesis was two-sided (we didn’t really have any theory about whether psychology students would be better or worse at statistics than other students), so our hypothesis test is two-sided (or two-tailed) also. Looking at the little table shown earlier, we can see that 2.26 is bigger than the critical value of 1.96 that would be required to be significant at α=.05\\alpha = .05 but smaller than the value of 2.58 that would be required to be significant at a level of α=.01\\alpha = .01. Therefore, we can conclude that we have a significant effect, which we might write up by saying something like this: With a mean grade of 73.2 in the sample of psychology students, and assuming a true population standard deviation of 9.5, we can conclude that the psychology students have significantly different statistics scores to the class average (z=2.26z = 2.26, N=20N=20, p&lt;.05p&lt;.05). However, what if want an exact pp-value? Well, back in the day, the tables of critical values were huge, so you could look up your actual zz-value and find the smallest value of α\\alpha for which your data would be significant (which, as discussed earlier, is the very definition of a pp-value). However, we are here just to discuss the zz-test in order for us to understand the tt-test, so we will not go into the details of how to do this. However, if you are interested, you can find a table of critical values here. All in all, our pp-value is 0.02380.0238. All statistical tests make assumptions. Some tests make reasonable assumptions, while other tests do not. The one-sample zz-test makes three basic assumptions: Normality. As usually described, the zz-test assumes that the true population distribution is normal.49 is often pretty reasonable, and not only that, it’s an assumption that we can check if we feel worried about it (see Chapter 11.7). Independence. The second assumption of the test is that the observations in your data set are not correlated with each other or related to each other in some funny way. This isn’t as easy to check statistically: it relies a bit on good experimental design. An obvious example of something that violates this assumption is a data set where you “copy” the same observation over and over again in your data file: so you end up with a massive “sample size” consisting of only one genuine observation. More realistically, you have to ask yourself if it’s really plausible to imagine that each observation is an entirely random sample from the population you’re interested in. In practice, this assumption is never met; but we try our best to design studies that minimise the problems of correlated data. Known standard deviation. The third assumption of the zz-test is that the true standard deviation of the population is known to the researcher. This is just stupid. In no real-world data analysis problem do you know the standard deviation σ\\sigma of some population but are completely ignorant about the mean μ\\mu. In other words, this assumption is always wrong. In view of the stupidity of assuming that σ\\sigma is known, let’s see if we can live without it. This takes us out of the dreary domain of the zz-test and into the magical kingdom of the tt-test, with unicorns, fairies, and leprechauns. 11.2 The one-sample tt-test It might not be safe to assume that the psychology student grades necessarily have the same standard deviation as the other students in Dr Zeppo’s class. After all, if we were entertaining the hypothesis that they don’t have the same mean, why should we assume they have the same standard deviation? In view of this, we must stop assuming we know the true value of σ\\sigma. However, this violates the assumptions of the zz-test, which brings us back to square one. However, we still have the raw data loaded into CogStat, and those can give us an estimate of the population standard deviation. Having loaded the grades data and explored the descriptive statistics, let us take note of a few data points from the Descriptives for the variable and the Population parameter estimations section of the CogStat output. But first, let us re-run the Explore variable option, but now let us tell CogStat to use our null hypothesis of 67.567.5. To do that, we have to fill in 67.5 in our dialogue: Population parameter estimations Present confidence interval values for the mean suppose normality. Point estimation 95% confidence interval (low) 95% confidence interval (high) Mean 72.3 67.8 76.8 Standard deviation 9.5 7.2 13.9 In other words, while we can’t say that we know that σ=9.5\\sigma = 9.5, we can say that σ̂=9.5\\hat\\sigma = 9.5. (Actually, it’s 9.5206159.520615 but CogStat rounds it to one decimal when displayed, but it uses the exact value for any calculation.) Because we are now relying on an estimate of the population standard deviation, we need to make some adjustment for the fact that we have some uncertainty about what the true population standard deviation actually is. Maybe our data are just a fluke, maybe the true population standard deviation is 11, for instance. But if that were actually true, and we ran the zz-test assuming σ=11\\sigma=11, then the result would end up being non-significant. That’s a problem, and it’s one we’re going to have to address. Figure 11.7: Graphical illustration of the null and alternative hypotheses assumed by the (two sided) one-sample tt-test. Note the similarity to the zz-test. The null hypothesis is that the population mean μ\\mu is equal to some specified value μ0\\mu_0, and the alternative hypothesis is that it is not. Like the zz-test, we assume that the data are normally distributed; but we do not assume that the population standard deviation σ\\sigma is known in advance. This ambiguity is annoying, and it was resolved in 1908 by a guy called William Sealy Gosset (Student, 1908), who was working as a chemist for the Guinness brewery at the time (see Box, 1987). Because Guinness took a dim view of its employees publishing statistical analysis (apparently, they felt it was a trade secret), he published the work under the pseudonym “A Student”, and to this day, the full name of the tt-test is actually Student’s tt-test. The critical thing that Gosset figured out is how we should accommodate the fact that we aren’t entirely sure what the true standard deviation is.50 The answer is that it subtly changes the sampling distribution. In the tt-test, our test statistic (now called a tt-statistic) is calculated in exactly the same way as mentioned above. If our null hypothesis is that the true mean is μ\\mu, but our sample has mean X‾\\bar{X} and our estimate of the population standard deviation is σ̂\\hat{\\sigma}, then our tt statistic is: t=X‾−μσ̂/N t = \\frac{\\bar{X} - \\mu}{\\hat{\\sigma}/\\sqrt{N} } The only thing that has changed in the equation is that instead of using the known true value σ\\sigma, we use the estimate σ̂\\hat{\\sigma}. And if this estimate has been constructed from NN observations, then the sampling distribution turns into a tt-distribution with N−1N-1 degrees of freedom (df). The tt distribution is very similar to the normal distribution but has “heavier” tails, as discussed earlier in Chapter 7.4.4 and illustrated in Figure 11.8. Notice, though, that as df gets larger, the tt-distribution starts to look identical to the standard normal distribution. This is as it should be: if you have a sample size of N=70000000N = 70000000, then your “estimate” of the standard deviation would be pretty much perfect, right? So, you should expect that for large NN, the tt-test would behave the same way as a zz-test. And that’s exactly what happens! Figure 11.8: The tt distribution with 2 degrees of freedom (left) and 10 degrees of freedom (right), with a standard normal distribution (i.e., mean 0 and std dev 1) plotted as dotted lines for comparison purposes. Notice that the tt distribution has heavier tails (higher kurtosis) than the normal distribution; this effect is quite exaggerated when the degrees of freedom are very small, but negligible for larger values. In other words, for large dfdf the tt distribution is essentially identical to a normal distribution. As you might expect, the mechanics of the tt-test are almost identical to the mechanics of the zz-test. So there’s not much point in going through the tedious exercise of showing you how to do the calculations: it’s pretty much identical to the calculations that we did earlier, except that we use the estimated standard deviation, and then we test our hypothesis using the tt distribution rather than the normal distribution. So let’s just do it quickly in CogStat: let’s just go through the output. You can see that the Population parameter estimations stayed the same, so no need to quote them here again. However, let’s see the Hypothesis tests results. Hypothesis tests Testing if mean deviates from the value 67.5. Interval variable. &gt;&gt; Choosing one-sample t-test or Wilcoxon signed-rank test depending on the assumption. Checking for normality. Shapiro-Wilk normality test in variable x: W = 0.96, p = .586 Normality is not violated. &gt;&gt; Running one-sample t-test. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in d: 0.85. One sample t-test against 67.5: t(19) = 2.25, p = .036 Result of the Bayesian one sample t-test: BF10 = 1.80, BF01 = 0.56 Let us go through them line by line. Testing if mean deviates from the value 67.5.: good, we are made sure we are testing against a null hypothesis of μ=67.5\\mu = 67.5. Interval variable. &gt;&gt; Choosing one-sample t-test or Wilcoxon signed-rank test depending on the assumption.: this means that depending on normality (which is an assumption of both zz and tt-tests), CogStat will choose either the tt-test or the Wilcoxon signed-rank test. We will discuss the Wilcoxon signed-rank test later on. Normality is not violated. &gt;&gt; Running one-sample t-test.: this is good, because we know that the tt-test is only valid if the data are normally distributed. one-sample t-test against 67.5: t(19) = 2.25, p &lt; .036: this is the result of the tt-test. The tt-statistic is 2.25, and the pp-value is 0.036. This means that we can reject the null hypothesis that μ=67.5\\mu = 67.5 at the 5% level of significance. In other words, we can conclude that the mean of the sample is significantly different from 67.5. Don’t forget to take note of the Mean’s 95% confidence interval values from the Population parameter estimations, and now we could report the result by saying something like this: With a mean grade of 72.3, the psychology students scored slightly higher than the average grade of 67.5 (t(19)=2.25t(19) = 2.25, p&lt;.05p&lt;.05); the 95% confidence interval is [67.8, 76.8]. t(19)t(19) is shorthand notation for a tt-statistic that has 19 degrees of freedom. That said, it’s often the case that people don’t report the confidence interval, or do so using a much more compressed form. For instance, it’s not uncommon to see the confidence interval included as part of the stat block, like this: t(19)=2.25t(19) = 2.25, p&lt;.05p&lt;.05, CI95=[67.8,76.8]_{95} = [67.8, 76.8] With that much jargon crammed into half a line, you know it must be really smart. Okay, so what assumptions does the one-sample tt-test make? Well, since the tt-test is a zz-test with the premise of known standard deviation removed, you shouldn’t be surprised to see that it makes the same assumptions as the zz-test, minus the one about the known standard deviation. That is Normality. We’re still assuming that the population distribution is normal. Independence. Once again, we have to assume that the observations in our sample are generated independently of one another. Overall, these two assumptions aren’t terribly unreasonable, and as a consequence, the one-sample tt-test is pretty widely used in practice as a way of comparing a sample mean against a hypothesised population mean. 11.3 The independent samples tt-test (Student test) Although the one-sample tt-test has its uses, it’s not the most typical example of a tt-test. A much more common situation arises when you’ve got two different groups of observations. In psychology, this tends to correspond to two different groups of participants, where each group corresponds to a different condition in your study. For each person in the study, you measure some outcome variable of interest, and the research question that you’re asking is whether or not the two groups have the same population mean. This is the situation that the independent samples tt-test is designed for. Suppose we have 33 students taking Dr Harpo’s statistics lectures, and Dr Harpo doesn’t grade to a curve. Actually, Dr Harpo’s grading is a bit of a mystery, so we don’t really know anything about what the average grade is for the class as a whole. There are two tutors for the class, Anastasia and Bernadette. There are N1=15N_1 = 15 students in Anastasia’s tutorials, and N2=18N_2 = 18 in Bernadette’s tutorials. The research question we’re interested in is whether Anastasia or Bernadette is a better tutor, or if it doesn’t make much of a difference. As usual, let’s load the file harpo.csv. As we can see, we have two variables: grade and tutor. The grade variable is a numeric interval variable, containing the grades for all N=33N = 33 students taking Dr Harpo’s class; the tutor variable is a categorical (nominal) data that indicates who each student’s tutor was. Let’s run the Compare groups function so we can get some information about the grades by tutor. Figure 11.9: Comparing grades by tutor in CogStat for our harpo data set. In the boxplot generated by CogStat, we have the grades, the means and corresponding upper and lower quartiles. We can see that the grades for Anastasia’s students are slightly higher than those for Bernadette’s students. We can also see that the variance of the grades for Bernadette’s students is slightly higher than that for Anastasia’s students. The independent samples tt-test comes in two different forms, Student’s and Welch’s. The original Student tt-test – which is the one we’ll describe in this section – is the simpler of the two but relies on much more restrictive assumptions than the Welch tt-test. Assuming for the moment that you want to run a two-sided test, the goal is to determine whether two “independent samples” of data are drawn from populations with the same mean (the null hypothesis) or different means (the alternative hypothesis). When we say “independent” samples, what we really mean here is that there’s no special relationship between observations in the two samples. This probably doesn’t make a lot of sense right now, but it will be clearer when we come to talk about the paired samples tt-test later on. For now, let’s just point out that if we have an experimental design where participants are randomly allocated to one of two groups, and we want to compare the two groups’ mean performance on some outcome measure, then an independent samples tt-test (rather than a paired samples tt-test) is what we’re after. Okay, so let’s let μ1\\mu_1 denote the true population mean for group 1 (e.g., Anastasia’s students), and μ2\\mu_2 will be the true population mean for group 2 (e.g., Bernadette’s students),51 and as usual, we’ll let X‾1\\bar{X}_1 and X‾2\\bar{X}_2 denote the observed sample means for both of these groups. Our null hypothesis states that the two population means are identical (μ1=μ2\\mu_1 = \\mu_2), and the alternative to this is that they are not (μ1≠μ2\\mu_1 \\neq \\mu_2). H0:μ1=μ2H1:μ1≠μ2 \\begin{array}{ll} H_0: &amp; \\mu_1 = \\mu_2 \\\\ H_1: &amp; \\mu_1 \\neq \\mu_2 \\end{array} Figure 11.10: Graphical illustration of the null and alternative hypotheses assumed by the Student tt-test. The null hypothesis assumes that both groups have the same mean μ\\mu, whereas the alternative assumes that they have different means μ1\\mu_1 and μ2\\mu_2. Notice that it is assumed that the population distributions are normal, and that, although the alternative hypothesis allows the group to have different means, it assumes they have the same standard deviation To construct a hypothesis test that handles this scenario, we start by noting that if the null hypothesis is true, then the difference between the population means is exactly zero, μ1−μ2=0\\mu_1 - \\mu_2 = 0 As a consequence, a diagnostic test statistic will be based on the difference between the two sample means. Because if the null hypothesis is true, then we’d expect X‾1−X‾2 \\bar{X}_1 - \\bar{X}_2 to be pretty close to zero. However, just like we saw with our one-sample tests (i.e. the one-sample zz-test and the one-sample tt-test) we have to be precise about exactly how close to zero this difference should be. And the solution to the problem is more or less the same one: we calculate a standard error estimate (SE), just like last time, and then divide the difference between means by this estimate. So our tt-statistic will be of the form t=X‾1−X‾2SE t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\mbox{SE}} We just need to figure out what this standard error estimate actually is. This is a bit trickier than was the case for either of the two tests we’ve looked at so far, so we need to go through it a lot more carefully to understand how it works. In the original “Student tt-test”, we make the assumption that the two groups have the same population standard deviation: that is, regardless of whether the population means are the same, we assume that the population standard deviations are identical, σ1=σ2\\sigma_1 = \\sigma_2. Since we’re assuming that the two standard deviations are the same, we drop the subscripts and refer to both of them as σ\\sigma. How should we estimate this? How should we construct a single estimate of a standard deviation when we have two samples? The answer is, we take a weighed average of the variance estimates, which we use as our pooled estimate of the variance. The weight assigned to each sample is equal to the number of observations in that sample, minus 1. w1=N1−1w2=N2−1 \\begin{array}{rcl} w_1 &amp;=&amp; N_1 - 1\\\\ w_2 &amp;=&amp; N_2 - 1 \\end{array} Now that we’ve assigned weights to each sample, we calculate the pooled estimate of the variance by taking the weighted average of the two variance estimates, σ̂12{\\hat\\sigma_1}^2 and σ̂22{\\hat\\sigma_2}^2. σ̂p2=w1σ̂12+w2σ̂22w1+w2 \\hat\\sigma^2_p = \\frac{w_1 {\\hat\\sigma_1}^2 + w_2 {\\hat\\sigma_2}^2}{w_1 + w_2} Finally, we convert the pooled variance estimate to a pooled standard deviation estimate, by taking the square root. This gives us the following formula for σ̂p\\hat\\sigma_p, σ̂p=w1σ̂12+w2σ̂22w1+w2 \\hat\\sigma_p = \\sqrt{\\frac{w_1 {\\hat\\sigma_1}^2 + w_2 {\\hat\\sigma_2}^2}{w_1 + w_2}} And if you mentally substitute w1=N1−1w_1 = N_1 -1 and w2=N2−1w_2 = N_2 -1 into this equation, you get a very ugly formula that actually seems to be the “standard” way of describing the pooled standard deviation estimate. But let us describe it a bit differently: Our data set actually corresponds to a set of NN observations, which are sorted into two groups. So let’s use the notation XikX_{ik} to refer to the grade received by the ii-th student in the kk-th tutorial group: that is, X11X_{11} is the grade received by the first student in Anastasia’s class, X21X_{21} is her second student, and so on. And we have two separate group means X‾1\\bar{X}_1 and X‾2\\bar{X}_2, which we could “generically” refer to using the notation X‾k\\bar{X}_k, i.e.,the mean grade for the kk-th tutorial group. Since every single student falls into one of the two tutorials, and so we can describe their deviation from the group mean as the difference Xik−X‾k X_{ik} - \\bar{X}_k So why not just use these deviations (i.e. the extent to which each student’s grade differs from the mean grade in their tutorial)? Remember, a variance is just the average of a bunch of squared deviations. ∑ik(Xik−X‾k)2N \\frac{\\sum_{ik} \\left( X_{ik} - \\bar{X}_k \\right)^2}{N} where the notation “∑ik\\sum_{ik}” is a lazy way of saying “calculate a sum by looking at all students in all tutorials”, since each “ikik” corresponds to one student. But, as we saw in Chapter 8, calculating the variance by dividing by NN produces a biased estimate of the population variance. And previously, we needed to divide by N−1N-1 to fix this. However, the reason why this bias exists is because the variance estimate relies on the sample mean; and to the extent that the sample mean isn’t equal to the population mean, it can systematically bias our estimate of the variance. But this time we’re relying on two sample means! Does this mean that we’ve got more bias? Yes, yes it does. And does this mean we now need to divide by N−2N-2 instead of N−1N-1, in order to calculate our pooled variance estimate? Why, yes… σ̂p2=∑ik(Xik−X‾k)2N−2 \\hat\\sigma^2_p = \\frac{\\sum_{ik} \\left( X_{ik} - \\bar{X}_k \\right)^2}{N -2} Oh, and if you take the square root of this then you get σ̂p\\hat{\\sigma}_p, the pooled standard deviation estimate. In other words, the pooled standard deviation calculation is nothing special: it’s not terribly different to the regular standard deviation calculation. Regardless of which way you want to think about it, we now have our pooled estimate of the standard deviation. From now on, we’ll refer to this estimate as σ̂\\hat\\sigma. Let’s now go back to thinking about the hypothesis test. Our whole reason for calculating this pooled estimate was that we knew it would be helpful when calculating our standard error estimate. But, standard error of what? In the one-sample tt-test, it was the standard error of the sample mean, SE(X‾)\\mbox{SE}({\\bar{X}}), and since SE(X‾)=σ/N\\mbox{SE}({\\bar{X}}) = \\sigma / \\sqrt{N} that’s what the denominator of our tt-statistic looked like. This time around, however, we have two sample means. And what we’re interested in, specifically, is the the difference between the two X‾1−X‾2\\bar{X}_1 - \\bar{X}_2. Consequently, the standard error that we need to divide by is in fact the standard error of the difference between means. As long as the two variables really do have the same standard deviation, then our estimate for the standard error is SE(X‾1−X‾2)=σ̂1N1+1N2 \\mbox{SE}({\\bar{X}_1 - \\bar{X}_2}) = \\hat\\sigma \\sqrt{\\frac{1}{N_1} + \\frac{1}{N_2}} and our tt-statistic is therefore t=X‾1−X‾2SE(X‾1−X‾2) t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\mbox{SE}({\\bar{X}_1 - \\bar{X}_2})} Just as we saw with our one-sample test, the sampling distribution of this tt-statistic is a tt-distribution as long as the null hypothesis is true, and all of the assumptions of the test are met. The degrees of freedom, however, is slightly different. As usual, we can think of the degrees of freedom to be equal to the number of data points minus the number of constraints. In this case, we have NN observations (N1N_1 in sample 1, and N2N_2 in sample 2), and 2 constraints (the sample means). So the total degrees of freedom for this test are N−2N-2. The output from CogStat has a very familiar form. Let’s start to talk about the confidence interval, and for that, let’s circle back to our Population parameter estimations: Population parameter estimations MeansPresent confidence interval values suppose normality. tutor Point estimation 95% CI (low) 95% CI (high) Anastasia 74.5 69.5 79.5 Bernadette 69.1 66.2 71.9 Difference between the two groups: 5.5 0.2 10.8 It’s pretty important to be clear on what this confidence interval actually refers to: it is a confidence interval for the difference between the group means. In our example, Anastasia’s students had an average grade of 74.5, and Bernadette’s students had an average grade of 69.1, so the difference between the two sample means is 5.5 (due to rounding). But of course the difference between population means might be bigger or smaller than this. The confidence interval reported tells you that there’s a 95% chance that the true difference between means lies between 0.2 and 10.8. In any case, the difference between the two groups is significant (just barely), so we might write up the result using text like this: The mean grade in Anastasia’s class was 74.5 (SD = 8.7), whereas the mean in Bernadette’s class was 69.1 (SD = 5.6). A Student’s independent samples tt-test showed that this 5.5 difference was significant (t(31)=2.12t(31) = 2.12, p&lt;.05p&lt;.05, CI95=[0.2,10.8]CI_{95} = [0.2, 10.8]), suggesting that a genuine difference in learning outcomes has occurred. At a bare minimum, you’d expect to see the tt-statistic, the degrees of freedom and the pp value. So you should include something like this at a minimum: t(31)=2.1t(31) = 2.1, p&lt;.05p&lt;.05. If statisticians had their way, everyone would also report the confidence interval and probably the effect size measure too, because they are useful things to know. But real life doesn’t always work the way statisticians want it to: you should make a judgment based on whether you think it will help your readers, and (if you’re writing a scientific paper) the editorial standard for the journal in question. Some journals expect you to report effect sizes, others don’t. Within some scientific communities it is standard practice to report confidence intervals, in other it is not. You’ll need to figure out what your audience expects. Before moving on to talk about the assumptions of the tt-test, there’s one additional point to make about the use of tt-tests in practice. The first one relates to the sign of the tt-statistic (that is, whether it is a positive number or a negative one). One very common worry that students have when they start running their first tt-test is that they often end up with negative values for the tt-statistic, and don’t know how to interpret it. On closer inspection, the students will notice that the confidence intervals also have the opposite signs. This is perfectly okay. The tt-statistic calculated in CogStat is always of the form t=(mean 1)−(mean 2)(SE) t = \\frac{\\mbox{(mean 1)} -\\mbox{(mean 2)}}{ \\mbox{(SE)}} If “mean 1” is larger than “mean 2” the tt statistic will be positive, whereas if “mean 2” is larger then the tt statistic will be negative. Similarly, the confidence interval is the confidence interval for the difference “(mean 1) minus (mean 2)”, which will be the reverse of what you’d get if you were calculating the confidence interval for the difference “(mean 2) minus (mean 1)”. Okay, that’s pretty straightforward when you think about it, but now consider our tt-test comparing Anastasia’s class to Bernadette’s class. Which one does CogStat call “mean 1” and which one should we call “mean 2”? Let’s look at the order of how the data is presented. Anastasia goes first in all the result outputs. So, we would write Anastasia’s class had higher grades than Bernadette’s class (t(31)=2.1,p=.04t(31)= 2.1, p=.04). On the other hand, suppose the phrasing we wanted to use has Bernadette’s class listed first. If so, it makes more sense to treat her class as group 1, and if so, the write up looks like this: Bernadette’s class had lower grades than Anastasia’s class (t(31)=−2.1,p=.04t(31)= -2.1, p=.04). Because we’re talking about one group having “lower” scores this time around, it is more sensible to use the negative form of the tt-statistic. It just makes it read more cleanly. One last thing: please note that you can’t do this for other types of test statistics. It works for tt-tests, but it wouldn’t be meaningful for chi-square tests, FF-tests. So don’t overgeneralise this advice! As always, our hypothesis test relies on some assumptions. For the Student t-test there are three assumptions, some of which we saw previously in the context of the one-sample tt-test: Normality. Specifically, we assume that both groups are normally distributed. Independence. In the context of the Student test, this has two aspects to it. Firstly, we assume that the observations within each sample are independent of one another (exactly the same as for the one-sample test). However, we also assume that there are no cross-sample dependencies. If, for instance, it turns out that you included some participants in both experimental conditions of your study (e.g. by accidentally allowing the same person to sign up to different conditions), then there are some cross sample dependencies that you’d need to take into account. Homogeneity of variance (also called “homoscedasticity”). The third assumption is that the population standard deviation is the same in both groups. CogStat tests this assumption using the Levene test automatically, as you’ve seen in the result output. But we’ll talk about the test later on in the book (Section 12.6). 11.4 The independent samples tt-test (Welch test) The biggest problem with using the Student test in practice is the third assumption in the previous section: it assumes that both groups have the same standard deviation (i.e. homogeneity of variance). This is rarely true in real life: if two samples don’t have the same means, why should we expect them to have the same standard deviation? There’s no reason to expect this assumption to be true. There is a different form of the tt-test (Welch, 1947) that does not rely on this assumption. A graphical illustration of what the Welch tt test assumes about the data is shown in Figure 11.11, to provide a contrast with the Student test version in Figure 11.10. The Welch test is very similar to the Student test. For example, the tt-statistic that we use in the Welch test is calculated in much the same way as for the Student test. That is, we take the difference between the sample means and then divide it by some estimate of the standard error of that difference: t=X‾1−X‾2SE(X‾1−X‾2) t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\mbox{SE}({\\bar{X}_1 - \\bar{X}_2})} The main difference is that the standard error calculations are different. If the two populations have different standard deviations, then it’s utter nonsense to calculate a pooled standard deviation estimate because you’re averaging apples and oranges. But you can still estimate the standard error of the difference between sample means; it just ends up looking different: SE(X‾1−X‾2)=σ̂12N1+σ̂22N2 \\mbox{SE}({\\bar{X}_1 - \\bar{X}_2}) = \\sqrt{ \\frac{{\\hat{\\sigma}_1}^2}{N_1} + \\frac{{\\hat{\\sigma}_2}^2}{N_2} } The second difference between Welch and Student is how the degrees of freedom are calculated. In the Welch test, the “degrees of freedom” doesn’t have to be a whole number, and it doesn’t correspond all that closely to the “number of data points minus the number of constraints” heuristic used to this point. The degrees of freedom are, in fact: df=(σ̂12/N1+σ̂22/N2)2(σ̂12/N1)2/(N1−1)+(σ̂22/N2)2/(N2−1) \\mbox{df} = \\frac{ ({\\hat{\\sigma}_1}^2 / N_1 + {\\hat{\\sigma}_2}^2 / N_2)^2 }{ ({\\hat{\\sigma}_1}^2 / N_1)^2 / (N_1 -1 ) + ({\\hat{\\sigma}_2}^2 / N_2)^2 / (N_2 -1 ) } What matters is that you’ll see that the “df” value that pops out of a Welch test tends to be a little bit smaller than the one used for the Student test, and it doesn’t have to be a whole number. Figure 11.11: Graphical illustration of the null and alternative hypotheses assumed by the Welch tt-test. Like the Student test, we assume that both samples are drawn from a normal population. However, the alternative hypothesis no longer requires the two populations to have equal variance. In most statistical software, you can choose to use the Welch test instead of the Student test. In CogStat, other parameters will decide whether the Welch test or the Student test is run. If you have two samples with different standard deviations, the Welch test will be run automatically. If you have two samples with the same standard deviation, the Student test will be run automatically. As we mentioned earlier, a Levene test can be used to probe for homogeneity of variance, and CogStat does just that! We generously skipped over calling this out in the previous chapter when discussing the results, but here’s the time to look at those specific lines in the result set. Checking for homogeneity of variance across groups. Levene test: WW = 2.13, pp = .155 If the Levene test is significant (i.e. p&lt;0.05p &lt; 0.05), the Welch test will be run. If the Levene test is not significant (i.e. p&gt;0.05p &gt; 0.05), the Student test will be run. In this case, the Levene test was not significant, so the Student test was run. Should we run a Welch test on the same data, it would not be significant (t(23.03)=2.03t(23.03) = 2.03, p=.054p = .054). What does this mean? Should we panic? Is the sky burning? Probably not. The fact that one test is significant and the other isn’t doesn’t itself mean very much, especially since I kind of rigged the data so that this would happen. As a general rule, it’s not a good idea to go out of your way to try to interpret or explain the difference between a pp-value of .049 and a pp-value of .051. If this sort of thing happens in real life, the difference in these pp-values is almost certainly due to chance. What does matter is that you take a little bit of care in thinking about what test you use. The Student test and the Welch test have different strengths and weaknesses. If the two populations really do have equal variances, then the Student test is slightly more powerful (lower Type II error rate) than the Welch test. However, if they don’t have the same variances, then the assumptions of the Student test are violated and you may not be able to trust it: you might end up with a higher Type I error rate. So it’s a trade-off. However, let us explore what CogStat would display in case the normality was not violated but the homogeneity of variance was! We’ve prepared a tweaked version of the data set, where the variances are different, but the normality is not violated: harpo_welch.csv. Figure 11.12: CogStat result set when the Levene test is significant, hence a Welch test must be run. Note how the degree of freedom is now a decimal and not an integer. The data set however was just tweaked slightly, and not enough for the pp value to be low enough, so the Welch test is not significant. However, we just wanted to demonstrate that the Welch test is run in this case. The assumptions of the Welch test are very similar to those made by the Student tt-test, except that the Welch test does not assume homogeneity of variance. This leaves only the assumption of normality, and the assumption of independence. The specifics of these assumptions are the same for the Welch test as for the Student test. 11.5 The paired-samples tt-test Regardless of whether we’re talking about the Student test or the Welch test, an independent samples tt-test is intended to be used in a situation where you have two samples that are, well, independent of one another. This situation arises naturally when participants are assigned randomly to one of two experimental conditions, but it provides a very poor approximation to other sorts of research designs. In particular, a repeated measures design – in which each participant is measured (with respect to the same outcome variable) in both experimental conditions – is not suited for analysis using independent samples tt-tests. For example, we might be interested in whether listening to music reduces people’s working memory capacity. To that end, we could measure each person’s working memory capacity in two conditions: with music, and without music. In an experimental design such as this one,52 each participant appears in both groups. This requires us to approach the problem in a different way; by using the paired samples tt-test. We’ll use the data set this time from Dr Chico’s class. In her class, students take two very challenging tests, one early in the semester and one later. Her theory is that the first test is a bit of a “wake-up call” for students: when they realise how hard her class really is, they’ll work harder for the second test and get a better mark. Is she right? To test this, let’s load the chico.csv file into CogStat. The data frame chico contains three variables: an id nominal variable that identifies each student in the class, the grade_test1 variable that records the student grade for the first test, and the grade_test2 variable that has the grades for the second test. Let’s take a quick look at the descriptive statistics. Since we are running a before and after test (like we already did in Chapter 10.7), let’s use the Compare repeated measures variables function. Figure 11.13: CogStat descriptives and boxplot for the variables grade_test1 and grade_test2 in the Compare repeated measures variables function. At a glance, it does seem like the class is a hard one (most grades are between 50 and 60), but it does look like there’s an improvement from the first test to the second one. We see that this impression seems to be supported. Across all 20 students, the mean grade for the first test is 56.98, but this rises to 58.38 for the second test. Although, given that the standard deviations are 6.45 and 6.24 respectively, it’s starting to feel like maybe the improvement is just illusory; maybe just random variation. This impression is reinforced when you look at the means (i.e. horizontal blue line in the rectangle) and confidence intervals (i.e. the blue rectangles themselves) plotted in the boxplot. Looking at how wide those confidence intervals are, we’d be tempted to think that the apparent improvement in student performance is pure chance. Nevertheless, this impression is wrong. To see why, take a look at the scatterplot of the grades for test 1 against the grades for test 2. Let us use CogStat’s Explore relation of variable pair function, so we see a scatter plot with a linear regression line (shown in Figure 11.14). Figure 11.14: Scatterplot showing the individual grades for test 1 and test 2 In this plot, each dot corresponds to the two grades for a given student: if their grade for test 1 (xx co-ordinate) equals their grade for test 2 (yy co-ordinate), then the dot falls on the line. Points falling above the line are the students that performed better on the second test. If we were to try to do an independent samples tt-test, we would be conflating the within subject differences (which is what we’re interested in testing) with the between subject variability (which we are not). The solution to the problem, mathematically speaking, is a one-sample tt-test on the within-subject difference variable. To formalise this slightly, if Xi1X_{i1} is the score that the ii-th participant obtained on the first variable, and Xi2X_{i2} is the score that the same person obtained on the second one, then the difference score is: Di=Xi1−Xi2 D_{i} = X_{i1} - X_{i2} Notice that the difference scores is variable 1 minus variable 2 and not the other way around, so if we want improvement to correspond to a positive valued difference, we actually want “test 2” to be our “variable 1”. Equally, we would say that μD=μ1−μ2\\mu_D = \\mu_1 - \\mu_2 is the population mean for this difference variable. So, to convert this to a hypothesis test, our null hypothesis is that this mean difference is zero; the alternative hypothesis is that it is not: H0:μD=0H1:μD≠0 \\begin{array}{ll} H_0: &amp; \\mu_D = 0 \\\\ H_1: &amp; \\mu_D \\neq 0 \\end{array} (this is assuming we’re talking about a two-sided test here). This is more or less identical to the way we described the hypotheses for the one-sample tt-test: the only difference is that the specific value that the null hypothesis predicts is 0. And so our tt-statistic is defined in more or less the same way too. If we let D‾\\bar{D} denote the mean of the difference scores, then t=D‾SE(D‾) t = \\frac{\\bar{D}}{\\mbox{SE}({\\bar{D}})} which is t=D‾σ̂D/N t = \\frac{\\bar{D}}{\\hat\\sigma_D / \\sqrt{N}} where σ̂D\\hat\\sigma_D is the standard deviation of the difference scores. Since this is just an ordinary, one-sample tt-test, with nothing special about it, the degrees of freedom are still N−1N-1. And that’s it: the paired samples tt-test really isn’t a new test at all: it’s a one-sample tt-test, but applied to the difference between two variables. It’s actually very simple; the only reason it merits a discussion as long as this one, is that you need to be able to recognise when a paired samples test is appropriate, and to understand why it’s better than an independent samples tt test. Looking at the CogStat result set, the software automatically decided to run a paired tt-test when we used the Compare repeated measures variables function: Population parameter estimations Present confidence interval values suppose normality. Point estimation 95% CI (low) 95% CI (high) grade_test1 56.98 53.88 60.08 grade_test2 58.38 55.39 61.38 Hypothesis tests Testing if the means are the same. Two variables. Interval variables. &gt;&gt; Choosing paired t-test or paried Wilcoxon test depending on the assumptions. Checking for normality. Shapiro-Wilk normality test in variable Difference of grade_test1 and grade_test2: W = 0.97, p = .678 Normality is not violated. &gt;&gt; Running paired t-test. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in d: 0.85. Result of paired samples t-test: t(19) = -6.48, p &lt; .001 Result of the Bayesian two-samples t-test: BF10 = 5991.58, BF01 = 0.00 From the population paramenter estimations, we know there’s an average improvement of 1.4 from test 1 to test 2 (58.38−56.9858.38 - 56.98), and this is significantly different from 0 (t(19)=−6.48,p&lt;.001t(19)=-6.48, p&lt;.001). 11.6 Effect size (Cohen’s dd) The most commonly used measure of effect size for a tt-test is Cohen’s dd (Cohen, 1988). Cohen himself defined it primarily in the context of an independent samples tt-test, specifically the Student test. In that context, a natural way of defining the effect size is to divide the difference between the means by an estimate of the standard deviation. In other words, we’re looking to calculate something along the lines of this: d=(mean 1)−(mean 2)std dev d = \\frac{\\mbox{(mean 1)} - \\mbox{(mean 2)}}{\\mbox{std dev}} and he suggested a rough guide for interpreting dd in Table 11.1. You’d think that this would be pretty unambiguous, but it’s not; largely because Cohen wasn’t too specific on what he thought should be used as the measure of the standard deviation. As discussed by McGrath &amp; Meyer (2006), there are several different versions in common usage, and each author tends to adopt slightly different notation. Cohen’s dd is automatically produced as part of the output in CogStat whenever it makes sense. Table 11.1: A (very) rough guide to interpreting Cohen’s dd. Do not use these blindly. The dd statistic has a natural interpretation in and of itself: it redescribes the different in means as the number of standard deviations that separates those means. So it’s generally a good idea to think about what that means in practical terms. In some contexts a “small” effect could be of big practical importance. In other situations a “large” effect may not be all that interesting. Cohen’s dd Interpretation about 0.2 small effect about 0.5 moderate effect about 0.8 large effect Let us go back to our examples and see how CogStat calculates effect sizes for us. - One-sample tt-test: CogStat does not calculate Cohen’s dd in the Explore variable function for our zeppo.csv data set. Regarding the other tests, the sample’s Standardised effect sizes will be shown right after the Descriptives for the variables subsection of the result set within the Sample properties section. Independent samples tt-test (Student’s): CogStat calculates Cohen’s dd in the Compare groups function for our harpo.csv data set. The result is d=0.740d=0.740. CogStat also calculates Eta-squared (0.1200.120), which is used for ANOVA, and we’ll discuss it in Chapter 12. Independent samples tt-test (Welch): CogStat calculates Cohen’s dd in the Compare groups function for our harpo_welch.csv data set. The result is Cohen’s d=0.752d=0.752, eta-squared = 0.1240.124. Paired samples tt-test: CogStat calculates Cohen’s dd in the Compare repeated measures variables function for our chico.csv data set. The result is Cohen’s d=−0.216d=-0.216, eta-squared = 0.0120.012. 11.7 Normality of a sample All of the tests that we have discussed so far in this chapter have assumed that the data are normally distributed. This assumption is often quite reasonable because the central limit theorem (Section 8.3.3) does tend to ensure that many real-world quantities are normally distributed. Any time you suspect your variable is actually an average of lots of different things, there’s a good chance that it will be normally distributed; or at least close enough to normal that you can get away with using tt-tests. However, there are lots of ways in which you can end up with variables that are highly non-normal. For example, any time you think that your variable is actually the minimum of lots of different things, there’s a very good chance it will end up quite skewed. In psychology, response time (RT) data is a good example of this. If you suppose that there are lots of things that could trigger a response from a human participant, then the actual response will occur the first time one of these trigger events occurs.53 This means that RT data are systematically non-normal. How can we check the normality of a sample? You might recall seeing this earlier in this chapter, but let’s take another look at a histogram and QQ plot without going back to the beginning. Figure 11.15: Left: a histogram of the data points (observations) in the zeppo.csv data set with a green dashed line showing the normal distribution curve. Right: a QQ plot of the same. One way to check whether a sample violates the normality assumption is to draw a “quantile-quantile” plot (QQ plot). This allows you to visually check whether you see any systematic violations. In a QQ plot, each observation is plotted as a single dot. The x coordinate is the theoretical quantile that the observation should fall in if the data were normally distributed (with mean and variance estimated from the sample), and the y coordinate is the actual quantile of the data within the sample (i.e. sample quantile). If the data are normal, the dots should form a straight line, or rather, should fit onto the green line more-or-less seamlessly. Now, let’s see how the QQ plot would look like, if we had a data set that violates the assumption of normality. You can test for yourself on the aflsmall data set from earlier. Figure 11.16: Left: a histogram of the data points (observations) in the aflsmall.csv data set with a green dashed line showing the normal distribution curve. Right: a QQ plot of the same showing how the data points curve and don’t form a stright line. Although QQ plots provide a simple visual way to check the normality of your data informally, you’ll want to do a formal test to prove it. The Shapiro-Wilk test (Shapiro &amp; Wilk, 1965) is what you’re looking for.54 As you’d expect, the null hypothesis being tested is that a set of NN observations is normally distributed. The test statistic it calculates is conventionally denoted as WW, calculated as follows. First, we sort the observations in order of increasing size and let X1X_1 be the smallest value in the sample, X2X_2 be the second smallest and so on. Then the value of WW is given by W=(∑i=1NaiXi)2∑i=1N(Xi−X‾)2 W = \\frac{ \\left( \\sum_{i = 1}^N a_i X_i \\right)^2 }{ \\sum_{i = 1}^N (X_i - \\bar{X})^2} where X‾\\bar{X} is the mean of the observations, and the aia_i values are something complicated beyond the scope of an introductory text. Unlike most of the test statistics, if the pp-value of a Shapiro-Wilk test is less than 0.050.05, then you can conclude that the data are not normally distributed. If the pp-value is greater than 0.050.05, then you can conclude that the data are normally distributed.55 The sampling distribution for WW – which is not one of the standard ones discussed in Chapter 7 – depends on the sample size NN. To give you a feel for what these sampling distributions look like, we’ve plotted three of them in Figure 11.17. Notice that, as the sample size starts to get large, the sampling distribution becomes very tightly clumped up near W=1W=1, and as a consequence, for larger samples, WW doesn’t have to be much smaller than 1 for the test to be significant. Figure 11.17: Sampling distribution of the Shapiro-Wilk WW statistic, under the null hypothesis that the data are normally distributed, for samples of size 10, 20 and 50. Note that small values of WW indicate departure from normality. When reporting the results for a Shapiro-Wilk test, you should make sure to include the test statistic WW and the pp value, though given that the sampling distribution depends so heavily on NN it would probably be a politeness to include NN as well. 11.8 Testing non-normal data with Wilcoxon tests Suppose your data is non-normal, but you still want to run something like a tt-test. Remember our aflsmall data set which violates the assumption of normality. When exploring the variable, CogStat will state that Normality is violated. The statistics are also given: Shapiro–Wilk normality test in variable aflmargins: W = 0.94, p &lt; .001. This is the situation where you want to use Wilcoxon tests. Unlike the tt-test, the Wilcoxon test doesn’t assume normality. In fact, they don’t make any assumptions about what kind of distribution is involved: in statistical jargon; this makes them nonparametric tests. While avoiding the normality assumption is nice, there’s a drawback: the Wilcoxon test is usually less powerful than the tt-test (i.e., higher Type II error rate). Like the tt-test, the Wilcoxon test comes in two forms, one-sample and two-sample, and they’re used in more or less the exact same situations as the corresponding tt-tests. 11.8.1 Two-sample Wilcoxon test (Mann-Whitney test) Let’s start with the two-sample Wilcoxon test, also known as the Mann-Whitney test, since it’s simpler than the one-sample version. Let us recall our AFL example with the data set called afl24.csv. We want to see if there is any statistically significant difference in the attendance if the game is a final or not (boolean variable name: isfinal). Figure 11.18: AFL final and non-final attendance (Compare groups function used). Once we ran the Compare groups function, the results are given. Our sample size is N=4096N=4096 for non-final games, and N=200N=200 for the final games. The Mann-Whitney test is a non-parametric test, so we don’t need to worry about the normality assumption. Hypothesis tests Testing if the means are the same. One grouping variable. Two groups. Interval variable. &gt;&gt; Choosing two sample t-test, Mann-Whitney test or Welch's t-test depending on assumptions. Checking for normality. Shapiro-Wilk normality test in variable attendance (isfinal: False): W = 0.94, p Shapiro-Wilk normality test in variable attendance (isfinal: True): W = 0.97, p Checking for homogeneity of variance across groups. Levene test: W = 76.47, p Normality is violated in variable attendance, group(s) ('False',), ('True',). &gt;&gt; Running Mann-Whitney test. Result of independent samples Mann-Whitney rank test: U = 97189.00 p &lt; .001 What does this score mean? Suppose we construct a table that compares every observation in group isfinal:True against every observation in group isfinal:False. Whenever the group isfinal:True attendance data is larger, we place a check mark in the table. We then count up the number of checkmarks. This is our test statistic, WW. But how do we interpret this data? Well, we already see from the chart in Figure 11.18 that the median attendance for the final games is higher than the median attendance for the non-final games. Our WW statistic is also a positive number (from isfinal:False &gt; isfinal:True), the pp value is below our α\\alpha level of 0.05. This means that we can reject the null hypothesis that the two groups have the same median attendance. In other words, we can conclude that the final games have a statistically significant higher attendance. When quoting the Mann-Whitney test, you should report the UU statistic and the pp value. 11.8.2 One-sample and paired samples Wilcoxon tests What about the one-sample Wilcoxon test, or equivalently, the paired samples Wilcoxon test? Suppose we’re interested in finding out whether taking a biology class has any effect on the happiness of students. The data is stored in the happiness.csv file. What is measured here is the happiness of each student before taking the class and after taking the class. The change score is the difference between the two. There’s no fundamental difference between doing a paired-samples test using before and after, versus doing a one-sample test using the change scores. Let us run a paired sample Wilcoxon test first in CogStat. Let’s use the Compare repeat measures variables function with the before and after variables. Figure 11.19: Happiness before and after statistics class (Compare repeat measures variables function used). Let’s see the results: Hypothesis tests Testing if the means are the same. Two variables. Interval variables. &gt;&gt; Choosing paired t-test or paired Wilcoxon test depending on the assumptions. Checking for normality. Shapiro-Wilk normality test in variable Difference of before and after: W = 0.80, p = .002 Normality is violated in variable(s) Difference of before and after. &gt;&gt; Running paired Wilcoxon test. Result of Wilcoxon signed-rank test: T = 31.00 p = .031 The pp value is 0.031, which is below our α\\alpha level of 0.05. This means that we can reject the null hypothesis that the two groups have the same median happiness. In other words, we can conclude that taking the biology class has a statistically significant negative effect on the happiness of students. Why negative? While the T value is positive, remember the rule, you have to plot your raw data and look at the descriptives as well, if something doesn’t look right. And as you’ve seen, the median happiness score for the before group is higher than the median happiness score for the after group. Now, you can make sure by running a one-sample Wilcoxon test in CogStat. Let’s use the Explore variable function with the change variable. This will serve two purposes. You’ll see how the one-sample Wilcoxon test works, and you’ll also see how the one-sample and two-sample tests relate to each other. You’ll quickly see in the descriptives, that the Mean change is negative (−9.6-9.6) with a 95% confidence interval of −18.7-18.7 to −0.4-0.4 being both in the negative. Hypothesis tests Testing if mean deviates from the value 0. Interval variable. &gt;&gt; Choosing one-sample t-test or Wilcoxon signed-rank test depending on the assumption. Checking for normality. Shapiro-Wilk normality test in variable change: W = 0.81, p = .002 Normality is violated. &gt;&gt; Running Wilcoxon signed-rank test. Median: -5.5 Result of Wilcoxon signed-rank test: T = 31.50 p = .035 As this shows, we have a significant effect, and of the same size as the paired samples test. (Don’t mind the rounding difference in the T value.) 11.9 Summary A one-sample tt-test is used to compare a single sample mean against a hypothesised value for the population mean. (Section 11.2) An independent samples tt-test is used to compare the means of two groups, and tests the null hypothesis that they have the same mean. It comes in two forms: the Student test (Section 11.3 assumes that the groups have the same standard deviation, the Welch test (Section 11.4) does not. A paired samples tt-test is used when you have two scores from each person, and you want to test the null hypothesis that the two scores have the same mean. It is equivalent to taking the difference between the two scores for each person, and then running a one-sample tt-test on the difference scores. (Section 11.5) Effect size calculations for the difference between means can be calculated via the Cohen’s dd statistic. (Section 11.6). You can check the normality of a sample using QQ plots and the Shapiro-Wilk test. (Section 11.7) If your data are non-normal, you can use Wilcoxon and Mann-Whitney tests instead of tt-tests. (Section 11.8) References Box, J. F. (1987). Guinness, gosset, fisher, and small samples. Statistical Science, 2, 45–52. Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Lawrence Erlbaum. McGrath, R. E., &amp; Meyer, G. J. (2006). When effect sizes disagree: The case of rr and dd. Psychological Methods, 11, 386–401. Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test for normality (complete samples). Biometrika, 52, 591–611. Student, A. (1908). The probable error of a mean. Biometrika, 6, 1–2. Welch, B. L. (1947). The generalization of “Student’s” problem when several different population variances are involved. Biometrika, 34, 28–35. Strictly speaking, the zz test only requires that the sampling distribution of the mean be normally distributed; if the population is normal then it necessarily follows that the sampling distribution of the mean is also normal. However, as we saw when talking about the central limit theorem, it’s entirely possible (even commonplace) for the sampling distribution to be normal even if the population distribution itself is non-normal. However, in light of the sheer ridiculousness of the assumption that the true standard deviation is known, there really isn’t much point in going into details on this front!↩︎ Gosset only provided a partial solution: the general solution to the problem was provided by Sir Ronald Fisher.↩︎ A funny question almost always pops up at this point: what the heck is the population being referred to in this case? Is it the set of students actually taking Dr Harpo’s class (all 33 of them)? The set of people who might take the class (an unknown number) of them? Or something else? Does it matter which of these we pick? Technically yes, it does matter: if you change your definition of what the “real world” population actually is, then the sampling distribution of your observed mean X‾\\bar{X} changes too. The tt-test relies on the assumption that the observations are sampled at random from an infinitely large population, and to the extent that real life isn’t like that, then the tt-test can be wrong. In practice, however, this isn’t usually a big deal: even though the assumption is almost always wrong, it doesn’t lead to a lot of pathological behaviour from the test, so we tend to just ignore it.↩︎ This design is very similar to the one in Chapter 10.7 that motivated the McNemar test. This should be no surprise. Both are standard repeated measures designs involving two measurements. The only difference is that this time our outcome variable is interval scale (working memory capacity) rather than a binary, nominal scale variable (a yes-or-no question).↩︎ This is a massive oversimplification.↩︎ The Kolmogorov-Smirnov test is probably more traditional than the Shapiro-Wilk, though mostly you’ll encounter Shapiro-Wilk in psychology research.↩︎ This is the opposite of what you’d expect from a pp-value, but it’s the way it is.↩︎ "],["anova.html", "Chapter 12 Comparing several means (one-way ANOVA) 12.1 The data 12.2 How ANOVA works 12.3 Interpreting our results in CogStat 12.4 Effect size 12.5 Post hoc tests 12.6 Checking the homogeneity of variance assumption 12.7 Testing for non-normal data with Kruskal-Wallis test 12.8 On the relationship between ANOVA and the Student tt-test 12.9 Summary", " Chapter 12 Comparing several means (one-way ANOVA) This chapter introduces one of the most widely used statistical tools known as “the analysis of variance”, which is usually referred to as ANOVA. Sir Ronald Fisher developed the basic technique in the early 20th century, and it is to him that we owe the rather unfortunate terminology. The term ANOVA is a little misleading in two respects. Firstly, although the technique’s name refers to variances, ANOVA is concerned with investigating differences in means. Secondly, several different things out there are all referred to as ANOVAs, some of which have only a very tenuous connection to one another. Later in the book, we’ll encounter various ANOVA methods that apply in quite different situations. Still, for this chapter, we’ll only consider the simplest form of ANOVA, in which we have several different groups of observations. We’re interested in finding out whether those groups differ in terms of some outcome variable of interest. This is the question that is addressed by a one-way ANOVA. After introducing the data, we’ll describe the mechanics of the one-way ANOVA, how to calculate effect sizes and post hoc tests. We’ll also talk about how to check for normality and homoscedasticity. Now let’s run a clinical trial! 12.1 The data Suppose you’ve become involved in a clinical trial in which you are testing a new antidepressant drug called Joyzepam. In order to construct a fair test of the drug’s effectiveness, the study involves three different medications to be administered. One is a placebo, and the other is an existing antidepressant / anti-anxiety drug called Anxifree. A collection of 18 participants with moderate to severe depression are recruited for your initial testing. Because the drugs are sometimes administered in conjunction with psychological therapy, your study includes 9 people undergoing cognitive behavioural therapy (CBT) and 9 who are not. Participants are randomly assigned (doubly blinded, of course) a treatment, such that there are 3 CBT people and 3 no-therapy people assigned to each of the 3 drugs. A psychologist assesses the mood of each person after a 3 month run with each drug: and the overall improvement in each person’s mood is assessed on a scale ranging from −5-5 to +5+5. With that as the study design, let’s load our data file: clinicaltrial.csv. We have three variables: drug, therapy and mood_gain. Next, let’s print the data frame to get a sense of what the data actually look like. For the purposes of this chapter, what we’re really interested in is the effect of drug on mood_gain. The first thing to do is use the Compare groups function. (But don’t jump ahead by adding both drug and therapy to the Group(s) box. That’s going to be our factorial ANOVA in Chapter 13.) Figure 12.1: Mood gain by drug The results are shown in the boxplot in Figure 12.1, which plots the average mood gain for all three conditions; error bars show upper and lower quartile. As the plot makes clear, there is a larger improvement in mood for participants in the Joyzepam group than for either the Anxifree group or the placebo group. The Anxifree group shows a larger mood gain than the control (i.e. placebo) group, but the difference isn’t as large. The question that we want to answer is: are these difference “real”, or are they just due to chance? 12.2 How ANOVA works In order to answer the question posed by our clinical trial data, we’re going to run a one-way ANOVA. As usual, we’re going to start by showing you how to do it the hard way to make sure you really understand how ANOVA works, but with CogStat, you’ll never ever have do it this way. The experimental design strongly suggests that we’re interested in comparing the average mood change for the three different drugs. In that sense, we’re talking about an analysis similar to the tt-test (Chapter 11), but involving more than two groups. If we let μP\\mu_P denote the population mean for the mood change induced by the placebo, and let μA\\mu_A and μJ\\mu_J denote the corresponding means for our two drugs, Anxifree and Joyzepam, then the (somewhat pessimistic) null hypothesis that we want to test is that all three population means are identical: that is, neither of the two drugs is any more effective than a placebo. Sidenote. This assumption of equal variances is Fisher’s ANOVA. When we are explicitly not assuming equal variances, we should be using Welch’s ANOVA, but that’s covered in this book or in CogStat actually. Back to our Fisher’s one-way ANOVA. Mathematically, we write this null hypothesis like this: H0:it is true that μP=μA=μJ \\begin{array}{rcl} {H}_{0} &amp;:&amp; \\mbox{it is true that } \\mu_P = \\mu_A = \\mu_J \\end{array} As a consequence, our alternative hypothesis is that at least one of the three different treatments is different from the others. It’s a little trickier to write this mathematically, because there are quite a few different ways in which the null hypothesis can be false. So for now we’ll just write the alternative hypothesis like this: H1:it is *not* true that μP=μA=μJ \\begin{array}{rcl} {H}_{1} &amp;:&amp; \\mbox{it is *not* true that } \\mu_P = \\mu_A = \\mu_J \\end{array} This null hypothesis is a lot trickier to test than any of the ones we’ve seen previously. How shall we do it? A sensible guess would be to “do an ANOVA”, since that’s the title of the chapter, but it’s not particularly clear why an “analysis of variances” will help us learn anything useful about the means. In fact, this is one of the greatest conceptual difficulties that people have when first encountering ANOVA. To see how this works, let us talk about variances first. 12.2.1 From variance… We’ll use GG to refer to the total number of groups. For our data set, there are three drugs, so there are G=3G=3 groups. Next, we’ll use NN to refer to the total sample size: there are a total of N=18N=18 people in our data set. Similarly, let’s use NkN_k to denote the number of people in the kk-th group. In our fake clinical trial, the sample size is Nk=6N_k = 6 for all three groups.56 Finally, we’ll use YY to denote the outcome variable (mood change). Specifically, we’ll use YikY_{ik} to refer to the mood change experienced by the ii-th member of the kk-th group. Similarly, we’ll use Y‾\\bar{Y} to be the average mood change, taken across all 18 people in the experiment, and Y‾k\\bar{Y}_k to refer to the average mood change experienced by the 6 people in group kk. Excellent. Now that we’ve got our notation sorted out, we can start writing down formulas. To start with, let’s recall the formula for the variance that we used in Chapter 5.2, way back in those kinder days when we were just doing descriptive statistics. The sample variance of YY is defined as follows: Var(Y)=1N∑k=1G∑i=1Nk(Yik−Y‾)2 \\mbox{Var}(Y) = \\frac{1}{N} \\sum_{k=1}^G \\sum_{i=1}^{N_k} \\left(Y_{ik} - \\bar{Y} \\right)^2 This formula looks pretty much identical to the formula for the variance in Chapter 5.2. The only difference is that we are now summing over groups (i.e. values for kk) and over the people within the groups (i.e. values for ii). Let’s consider a simple table to see how this formula works on our clinical trial data set. The table below shows the person, the drug they were given, and their mood change. Row Drug group Index in group Mood change kk ii YikY_{ik} 1 placebo 1 0.5 2 placebo 2 0.3 3 placebo 3 0.1 4 anxifree 1 0.6 5 anxifree 2 0.4 6 … … … Our average mood change is the mean of all the mood changes in the data set (which you can see if you run Explore variable for mood_gain), which is Y‾=0.88\\bar{Y} = 0.88. The variance of the mood changes is the sum of the squared differences between each mood change and the average mood change, divided by the total number of observations. So our formula filled in would look like this: Var(Y)=118((0.5−0.88)2+(0.3−0.88)2+(0.1−0.88)2+(0.6−0.88)2+(0.4−0.88)2+(0.2−0.88)2+(1.4−0.88)2+(1.7−0.88)2+(1.3−0.88)2+(0.6−0.88)2+(0.9−0.88)2+(0.3−0.88)2+(1.1−0.88)2+(0.8−0.88)2+(1.2−0.88)2+(1.8−0.88)2+(1.3−0.88)2+(1.4−0.88)2) \\begin{array}{ll} {Var}(Y) =&amp; \\frac{1}{18} ( (0.5 - 0.88 )^2 + (0.3 -0.88 )^2 + (0.1 - 0.88 )^2 + \\\\ &amp; (0.6 - 0.88 )^2 + (0.4 - 0.88 )^2 + (0.2 - 0.88 )^2 + (1.4 - 0.88 )^2 + \\\\ &amp; (1.7 - 0.88 )^2 + (1.3 - 0.88 )^2 + (0.6 - 0.88 )^2 + (0.9 - 0.88 )^2 + \\\\ &amp; (0.3 - 0.88 )^2 + (1.1 - 0.88 )^2 + (0.8 - 0.88 )^2 + (1.2 - 0.88 )^2 + \\\\ &amp; (1.8 - 0.88 )^2 + (1.3 - 0.88 )^2 + (1.4 - 0.88 )^2 ) \\end{array} Var(Y)=0.269 \\mbox{Var}(Y) = 0.269 Fortunately, we don’t have to do these manually.57 12.2.2 … to total sum of squares Okay, now that we’ve got a good grasp on how the population variance is calculated, let’s define something called the total sum of squares, which is denoted SStot\\mbox{SS}_{tot}. This is very simple: instead of averaging the squared deviations, which is what we do when calculating the variance, we just add them up. So the formula for the total sum of squares is almost identical to the formula for the variance: SStot=∑k=1G∑i=1Nk(Yik−Y‾)2 \\mbox{SS}_{tot} = \\sum_{k=1}^G \\sum_{i=1}^{N_k} \\left(Y_{ik} - \\bar{Y} \\right)^2 When we talk about analysing variances in the context of ANOVA, what we’re really doing is working with the total sums of squares rather than the actual variance. One very nice thing about the total sum of squares is that we can break it up into two different kinds of variation. Firstly, we can talk about the within-group sum of squares, in which we look to see how different each individual person is from their own group mean: SSw=∑k=1G∑i=1Nk(Yik−Y‾k)2 \\mbox{SS}_w = \\sum_{k=1}^G \\sum_{i=1}^{N_k} \\left( Y_{ik} - \\bar{Y}_k \\right)^2 where Y‾k\\bar{Y}_k is a group mean. In our example, Y‾k\\bar{Y}_k would be the average mood change experienced by those people given the kk-th drug. So, instead of comparing individuals to the average of all people in the experiment, we’re only comparing them to those people in the same group. As a consequence, you’d expect the value of SSw\\mbox{SS}_w to be smaller than the total sum of squares, because it’s completely ignoring any group differences – that is, the fact that the drugs (if they work) will have different effects on people’s moods. Next, we can define a third notion of variation which captures only the differences between groups. We do this by looking at the differences between the group means Y‾k\\bar{Y}_k and grand mean Y‾\\bar{Y}. In order to quantify the extent of this variation, what we do is calculate the between-group sum of squares: SSb=∑k=1G∑i=1Nk(Y‾k−Y‾)2=∑k=1GNk(Y‾k−Y‾)2 \\begin{array}{rcl} \\mbox{SS}_{b} &amp;=&amp; \\sum_{k=1}^G \\sum_{i=1}^{N_k} \\left( \\bar{Y}_k - \\bar{Y} \\right)^2 \\\\ &amp;=&amp; \\sum_{k=1}^G N_k \\left( \\bar{Y}_k - \\bar{Y} \\right)^2 \\end{array} It’s not too difficult to show that the total variation among people in the experiment SStot\\mbox{SS}_{tot} is actually the sum of the differences between the groups SSb\\mbox{SS}_b and the variation inside the groups SSw\\mbox{SS}_w. That is: SSw+SSb=SStot \\mbox{SS}_w + \\mbox{SS}_{b} = \\mbox{SS}_{tot} Yay. Figure 12.2: Graphical illustration of “between-groups” variation Figure 12.3: Graphical illustration of “within groups” variation Okay, so what have we found out? We’ve discovered that the total variability associated with the outcome variable (SStot\\mbox{SS}_ {tot}) can be mathematically carved up into the sum of “the variation due to the differences in the sample means for the different groups” (SSb\\mbox{SS}_ {b}) plus “all the rest of the variation” (SSw\\mbox{SS}_ {w}). Let’s apply the formulas to our clinical trial example, and see what we get. We won’t bother with the calculations in details, because the formula is given, and CogStat will not bore you with these either. SSw=∑k=1G∑i=1Nk(Yik−Y‾k)2=1.3917 \\begin{array}{rcl} \\mbox{SS}_w &amp;=&amp; \\sum_{k=1}^G \\sum_{i=1}^{N_k} \\left( Y_{ik} - \\bar{Y}_k \\right)^2 \\\\ &amp;=&amp; 1.3917 \\end{array} SSb=∑k=1GNk(Y‾k−Y‾)2=3.4533 \\begin{array}{rcl} \\mbox{SS}_b &amp;=&amp; \\sum_{k=1}^G N_k \\left( \\bar{Y}_k - \\bar{Y} \\right)^2 \\\\ &amp;=&amp; 3.4533 \\end{array} How does that help me find out whether the groups have different population means? If the null hypothesis is true, then you’d expect all the sample means to be pretty similar to each other, right? And that would imply that you’d expect SSb\\mbox{SS}_ {b} to be really small, or at least you’d expect it to be a lot smaller than the “the variation associated with everything else”, SSw\\mbox{SS}_{w}. So, let’s do a hypothesis test to validate. 12.2.3 From sums of squares to the FF-test As we saw in the last section, the qualitative idea behind ANOVA is to compare the two sums of squares values SSb\\mbox{SS}_ b and SSw\\mbox{SS}_ w to each other: if the between-group variation SSb\\mbox{SS}_ b is large relative to the within-group variation SSw\\mbox{SS}_ w, then we have reason to suspect that the population means for the different groups aren’t identical to each other. Our test statistic is called an FF-ratio. It’s defined as the ratio of the between-group variation to the within-group variation. In order to convert our SS values into an FF-ratio, the first thing we need to calculate is the degrees of freedom associated with the SSb_b and SSw_w values. As usual, the degrees of freedom corresponds to the number of unique “data points” that contribute to a particular calculation, minus the number of “constraints” that they need to satisfy. For the within-groups variability, what we’re calculating is the variation of the individual observations (NN data points) around the group means (GG constraints). In contrast, for the between-groups variability, we’re interested in the variation of the group means (GG data points) around the grand mean (1 constraint). Therefore, the degrees of freedom here are: dfb=G−1dfw=N−G \\begin{array}{lcl} \\mbox{df}_b &amp;=&amp; G-1 \\\\ \\mbox{df}_w &amp;=&amp; N-G \\\\ \\end{array} What we do next is convert our summed squares value into a “mean squares” value, which we do by dividing by the degrees of freedom: MSb=SSbdfbMSw=SSwdfw \\begin{array}{lcl} \\mbox{MS}_b &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_b }{ \\mbox{df}_b} \\\\ \\mbox{MS}_w &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_w }{ \\mbox{df}_w} \\end{array} Finally, we calculate the FF-ratio by dividing the between-groups MS by the within-groups MS: F=MSbMSw F = \\frac{\\mbox{MS}_b }{ \\mbox{MS}_w } At a very general level, the intuition behind the FF statistic is straightforward: bigger values of FF means that the between-groups variation is large, relative to the within-groups variation. As a consequence, the larger the value of FF, the more evidence we have against the null hypothesis. (To read more on how large does FF have to be to reject the null hypothesis, see the next chapter.) In order to complete our hypothesis test, we need to know the sampling distribution for FF if the null hypothesis is true. Not surprisingly, the sampling distribution for the FF statistic under the null hypothesis is an FF distribution. As seen in Chapter 7, the FF distribution has two parameters, corresponding to the two degrees of freedom involved: the first one df1_1 is the between-groups degrees of freedom dfb_b, and the second one df2_2 is the within-groups degrees of freedom dfw_w. A summary of all the key quantities involved in a one-way ANOVA, including the formulas showing how they are calculated, is shown in Table 12.1. Table 12.1: All of the key quantities involved in an ANOVA, organised into a “standard” ANOVA table. The formulas for all quantities (except the pp-value, which has a very ugly formula and would be nightmarishly hard to calculate without a computer) are shown. Between groups Within groups Degrees of freedom dfb=G−1\\mbox{df}_b = G-1 dfw=N−G\\mbox{df}_w = N-G Sum of squares SSb=∑k=1GNk(Y‾k−Y‾)2_b = \\displaystyle\\sum_{k=1}^G N_k (\\bar{Y}_k - \\bar{Y})^2 SSw=∑k=1G∑i=1Nk(Yik−Y‾k)2_w = \\sum_{k=1}^G \\sum_{i = 1}^{N_k} ( {Y}_{ik} - \\bar{Y}_k)^2 Mean squares MSb=SSbdfb\\mbox{MS}_b = \\frac{\\mbox{SS}_b}{\\mbox{df}_b} MSw=SSwdfw\\mbox{MS}_w = \\frac{\\mbox{SS}_w}{\\mbox{df}_w} FF statistic F=MSbMSwF = \\frac{\\mbox{MS}_b }{ \\mbox{MS}_w } - pp value [complicated] - Now let’s calculate these for our clinical trial example, again, behind the scenes. Let’s start with the degrees of freedom. dfb=G−1=3−1=2dfw=N−G=18−3=15 \\begin{array}{lcl} \\mbox{df}_b &amp;=&amp; G-1 \\\\ &amp;=&amp; 3-1 \\\\ &amp;=&amp; 2 \\\\ \\mbox{df}_w &amp;=&amp; N-G \\\\ &amp;=&amp; 18-3 \\\\ &amp;=&amp; 15 \\end{array} Now that that’s done, we can calculate the mean squares values. MSb=SSbdfb=3.45332=1.7267MSw=SSwdfw=1.391715=0.0928 \\begin{array}{lcl} \\mbox{MS}_b &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_b }{ \\mbox{df}_b} \\\\ &amp;=&amp; \\displaystyle\\frac{3.4533}{2} \\\\ &amp;=&amp; 1.7267 \\\\ \\mbox{MS}_w &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_w }{ \\mbox{df}_w} \\\\ &amp;=&amp; \\displaystyle\\frac{1.3917}{15} \\\\ &amp;=&amp; 0.0928 \\end{array} Finally, we can calculate the FF-ratio. F=MSbMSw=1.72670.0928=18.6067 \\begin{array}{lcl} F &amp;=&amp; \\frac{\\mbox{MS}_b }{ \\mbox{MS}_w } \\\\ &amp;=&amp; \\frac{1.7267}{0.0928} \\\\ &amp;=&amp; 18.6067 \\end{array} 12.2.4 Further reading: the meaning of FF (advanced) At a fundamental level, ANOVA is a competition between two different statistical models, H0H_0 and H1H_1. If you recall, our null hypothesis was that all of the group means are identical to one another. If so, then a natural way to think about the outcome variable YikY_{ik} is to describe individual scores in terms of a single population mean μ\\mu, plus the deviation from that population mean. This deviation is usually denoted ϵik\\epsilon_{ik} and is traditionally called the error or residual associated with that observation. Be careful though: just like we saw with the word “significant”, the word “error” has a technical meaning in statistics that isn’t quite the same as its everyday English definition. The word “residual” is a better term than the word “error”. In statistics, both words mean “leftover variability”: that is, “stuff” that the model can’t explain. In any case, here’s what the null hypothesis looks like when we write it as a statistical model: Yik=μ+ϵik Y_{ik} = \\mu + \\epsilon_{ik} where we make the assumption that the residual values ϵik\\epsilon_{ik} are normally distributed, with mean 0 and a standard deviation σ\\sigma that is the same for all groups. To use the notation that we introduced in Chapter 7 we would write this assumption like this: ϵik∼Normal(0,σ2) \\epsilon_{ik} \\sim \\mbox{Normal}(0, \\sigma^2) What about the alternative hypothesis, H1H_1? The only difference between the null hypothesis and the alternative hypothesis is that we allow each group to have a different population mean. So, if we let μk\\mu_k denote the population mean for the kk-th group in our experiment, then the statistical model corresponding to H1H_1 is: Yik=μk+ϵik Y_{ik} = \\mu_k + \\epsilon_{ik} where, once again, we assume that the error terms are normally distributed with mean 0 and standard deviation σ\\sigma. That is, the alternative hypothesis also assumes that ϵ∼Normal(0,σ2) \\epsilon \\sim \\mbox{Normal}(0, \\sigma^2) Okay, now that we’ve described the statistical models underpinning H0H_0 and H1H_1 in more detail, it’s now pretty straightforward to say what the mean square values are measuring and what this means for the interpretation of FF. It turns out that the within-groups mean square, MSw_w, can be viewed as an estimator (in the technical sense: Chapter 8) of the error variance σ2\\sigma^2. The between-groups mean square MSb_b is also an estimator; but what it estimates is the error variance plus a quantity that depends on the true differences among the group means. If we call this quantity QQ, then we can see that the FF-statistic is basically F=Q̂+σ̂2σ̂2 F = \\frac{\\hat{Q} + \\hat\\sigma^2}{\\hat\\sigma^2} where the true value Q=0Q=0 if the null hypothesis is true, and Q&gt;0Q &gt; 0 if the alternative hypothesis is true (e.g. ch. 10 Hays, 1994). Therefore, at a bare minimum the FF value must be larger than 1 to have any chance of rejecting the null hypothesis. Note that this doesn’t mean that it’s impossible to get an FF-value less than 1. What it means is that, if the null hypothesis is true the sampling distribution of the FF ratio has a mean of 1,58 and so we need to see FF-values larger than 1 in order to safely reject the null. To be a bit more precise about the sampling distribution, notice that if the null hypothesis is true, both MSb_b and MSw_w are estimators of the variance of the residuals ϵik\\epsilon_{ik}. If those residuals are normally distributed, then you might suspect that the estimate of the variance of ϵik\\epsilon_{ik} is chi-square distributed. Because (as discussed in Chapter 7.4.4) that’s what a chi-square distribution is: it’s what you get when you square a bunch of normally-distributed things and add them up. And since the FF distribution is (again, by definition) what you get when you take the ratio between two things that are χ2\\chi^2 distributed, we have our sampling distribution. 12.3 Interpreting our results in CogStat You already know the answers because we calculated it step by step, but you have a more in-depth understanding of how it all ties together. CogStat will do all of this for you, but it’s good to know what’s going on behind the scenes. Let’s see how CogStat displays our data. So what we had to do, was simply run the Compare groups function with mood_gain by drug. Figure 12.4: CogStat dialogue for Compare groups function with our clinical trial data set with variables mood_gain grouped by drug. Figure 12.5: CogStat result set displaying descriptives and boxplots as a result of Compare groups function with our clinical trial data set with variables mood_gain grouped by drug. Figure 12.6: CogStat result set with hypothesis test results, effect size and post hoc results after running Compare groups function with our clinical trial data set with variables mood_gain grouped by drug. We’ve seen this before. Let us explore the hypothesis test results. Hypothesis tests Testing if the means are the same. One grouping variable. More than two groups. Interval variable. &gt;&gt; Choosing one-way ANOVA or Kruskal-Wallis test depending on the assumptions. Checking for normality. Shapiro-Wilk normality test in variable mood_gain (drug: anxifree): W = 0.96, p = .790 Shapiro-Wilk normality test in variable mood_gain (drug: joyzepam): W = 0.82, p = .096 Shapiro-Wilk normality test in variable mood_gain (drug: placebo): W = 0.96, p = .830 Checking for homogeneity of variance across groups. Levene test: W = 1.47, p = .262 Normality and homogeneity of variance are not violated. &gt;&gt; Running one-way ANOVA. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in eta-square: 0.23. Result of one-way ANOVA: F(2, 15) = 18.61, p &lt; .001 For now, let’s stop here. We’ll come back to the post hoc tests later. For now, let’s just focus on the hypothesis test results. We can see that the Shapiro-Wilk normality test was run on each of the groups. Testing the normality assumption is relatively straightforward. We covered the theory behind it in Chapter 11.7. The Levene test was run to check for homogeneity of variance across groups. The one-way ANOVA was run, and the result was that the FF-value was 18.61, and the pp-value was less than 0.001. At this point, we’re basically done. (If you ran the test with us, you’ve seen something about post hoc tests. We will discuss them later.) Having completed our calculations, it’s traditional to organise all these numbers into an ANOVA table like the one in Table 12.2. For our clinical trial data, the ANOVA table would look like this: Table 12.2: ANOVA table for the mood_gain by drug variable df Sum of squares Mean squares FF-statistic pp-value between groups 2 3.4533 1.7267 18.61 &lt; .001 within groups 15 1.3917 0.0928 – – CogStat doesn’t produce this table for you or give the sums of squares or mean squares. But actually, you don’t need it to understand what the statistic tells you. There’s almost never a good reason to include the whole table in your write-up, but you might see it in other statistical software. A pretty standard way of reporting this result would be to write something like this: One-way ANOVA showed a significant effect of drug on mood gain (F(2,15) = 18.61, p &lt; .001). Sigh. So much work for one short sentence (if you do it manually). 12.4 Effect size There’s a few different ways you could measure the effect size in an ANOVA. 12.4.1 Eta-squared One of the most commonly used measures are η2\\eta^2 (eta-squared). The definition of η2\\eta^2 is actually really simple: η2=SSbSStot \\eta^2 = \\frac{\\mbox{SS}_b}{\\mbox{SS}_{tot}} That’s all it is. So when looking at the ANOVA table above, we see that SSb=3.45\\mbox{SS}_b = 3.45 and SStot=3.45+1.39=4.84\\mbox{SS}_{tot} = 3.45 + 1.39 = 4.84. Thus we get an η2\\eta^2 value of η2=3.454.84=0.71 \\eta^2 = \\frac{3.45}{4.84} = 0.71 The interpretation of η2\\eta^2 is equally straightforward: it refers to the proportion of the variability in the outcome variable (mood_gain) that can be explained in terms of the predictor (drug). A value of η2=0\\eta^2 = 0 means that there is no relationship at all between the two, whereas a value of η2=1\\eta^2 = 1 means that the relationship is perfect. Better yet, the η2\\eta^2 value is very closely related to a squared correlation (i.e. r2r^2). So, if you’re trying to figure out whether a particular value of η2\\eta^2 is big or small, it’s sometimes useful to remember that η=SSbSStot \\eta= \\sqrt{\\frac{\\mbox{SS}_b}{\\mbox{SS}_{tot}}} can be interpreted as if it referred to the magnitude of a Pearson correlation. So in our drugs example, the η2\\eta^2 value of 0.71 corresponds to an η\\eta value of .71=.84\\sqrt{.71} = .84. If we think about this as being equivalent to a correlation of about .84, we’d conclude that the relationship between drug and mood.gain is strong. 12.4.2 Omega-squared There’s an interesting blog post59 by Daniel Lakens suggesting that eta-squared itself is perhaps not the best measure of effect size in real world data analysis, but rather omega-squared (ω2\\omega^2) is. CogStat also opts for omega-squared as the default measure of effect size in one-way ANOVA. The formula for ω2\\omega^2 is a little more complicated than for η2\\eta^2, because it takes into account the degrees of freedom of the two sums of squares. The formula is specific for between-subjects, fixed effects designs. The formula is: ω2=SSb−dfb×MSwSStot+MSw \\omega^2 = \\frac{\\mbox{SS}_b - \\mbox{df}_b \\times \\mbox{MS}_w}{\\mbox{SS}_{tot} + \\mbox{MS}_w} where dfb\\mbox{df}_b is the degrees of freedom for the between-subjects factor, and MSw\\mbox{MS}_w is the mean square for the within-subjects factor, SStot\\mbox{SS}_{tot} is the total sum of squares, and SSb\\mbox{SS}_b is the between-subjects sum of squares. Filled in, we get: ω2=SSb−dfb×MSwSStot+MSw=3.4533−2×0.09284.845+0.0928=0.662 \\begin{array}{rcl} \\omega^2 &amp;=&amp; \\frac{\\mbox{SS}_b - \\mbox{df}_b \\times \\mbox{MS}_w}{\\mbox{SS}_{tot} + \\mbox{MS}_w} \\\\ &amp;=&amp; \\frac{3.4533 - 2 \\times 0.0928}{4.845 + 0.0928} \\\\ &amp;=&amp; 0.662 \\end{array} CogStat will give you this exact omega-squared value when running the one-way ANOVA inside the Compare groups function (see result set in Figure 12.6). ω2\\omega^2 will take on values between 00 and 11, where 0 indicates there is no effect whatsoever. It is wise to quote the effect size when writing up our results in APA-styled psychology research60. For example, we could write: One-way ANOVA showed a significant effect of drug on mood gain (F(2,15) = 18.61, p &lt; .001, ω2\\omega^2 = 0.662). 12.5 Post hoc tests Any time you run an ANOVA with more than two groups, and you end up with a significant effect, the first thing you’ll probably want to ask is which groups are actually different from one another. In our drugs example, our null hypothesis was that all three drugs (placebo, Anxifree and Joyzepam) have the exact same effect on mood. But if you think about it, the null hypothesis is actually claiming three different things all at once here. Specifically, it claims that: Your competitor’s drug (Anxifree) is no better than a placebo (i.e., μA=μP\\mu_A = \\mu_P) Your drug (Joyzepam) is no better than a placebo (i.e., μJ=μP\\mu_J = \\mu_P) Anxifree and Joyzepam are equally effective (i.e., μJ=μA\\mu_J = \\mu_A) If any one of those three claims is false, then the null hypothesis is also false. So, now that we’ve rejected our null hypothesis, we’re thinking that at least one of those things isn’t true. But which ones? All three of these propositions are of interest: you certainly want to know if your new drug Joyzepam is better than a placebo, and it would be nice to know how well it stacks up against an existing commercial alternative (i.e., Anxifree). It would even be useful to check the performance of Anxifree against the placebo: even if Anxifree has already been extensively tested against placebos by other researchers, it can still be very useful to check that your study is producing similar results to earlier work. When we characterise the null hypothesis in terms of these three distinct propositions, it becomes clear that there are eight possible “states of the world” that we need to distinguish between: possibility: is μP=μA\\mu_P = \\mu_A? is μP=μJ\\mu_P = \\mu_J? is μA=μJ\\mu_A = \\mu_J? which hypothesis? 1 ✓\\checkmark ✓\\checkmark ✓\\checkmark null 2 ✓\\checkmark ✓\\checkmark alternative 3 ✓\\checkmark ✓\\checkmark alternative 4 ✓\\checkmark alternative 5 ✓\\checkmark ✓\\checkmark alternative 6 ✓\\checkmark alternative 7 ✓\\checkmark alternative 8 alternative By rejecting the null hypothesis, we’ve decided that we don’t believe that #1 is the true state of the world. The next question to ask is, which of the other seven possibilities do we think is right? When faced with this situation, it usually helps to look at the data. For instance, if we look at the plots in Figure 12.1, it’s tempting to conclude that Joyzepam is better than the placebo and better than Anxifree, but there’s no real difference between Anxifree and the placebo. However, if we want to get a clearer answer about this, it might help to run some tests. There are actually quite a lot of different methods for performing multiple comparisons in the statistics literature (Hsu, 1996), and it would be beyond the scope of an introductory text like this one to discuss all of them in any detail. That being said, there’s one tool of importance, namely Tukey’s “Honestly Significant Difference”, or Tukey’s HSD for short. While there is the possibility to run “pairwise” tt-tests manually in other statistical software, CogStat opts for Tukey’s HSD test as a robust tool for running post hoc tests. The basic idea of Tukey’s HSD is to examine all relevant pairwise comparisons between groups, and it’s only really appropriate to use Tukey’s HSD if it is pairwise differences that you’re interested in. If, for instance, you actually would find yourself interested to know if Group A is significantly different from the mean of Group B and Group C, then you need to use a different tool (e.g., Scheffe’s method, which is more conservative, and beyond the scope this book). Tukey’s HSD constructs simultaneous confidence intervals for all the comparisons. What we mean by 95% “simultaneous” confidence interval is that there is a 95% probability that all of these confidence intervals contain the relevant true value. Moreover, we can use these confidence intervals to calculate an adjusted pp value for any specific comparison. Let’s look at the post hoc test result coming from CogStat, as seen in Figure 12.6. Table 12.3: Multiple Comparison of Means - Tukey HSD, FWER=0.05 group1 group2 meandiff p-adj lower upper reject anxifree joyzepam 0.7667 0.0015 0.3099 1.2235 True anxifree placebo -0.2667 0.3115 -0.7235 0.1901 False joyzepam placebo -1.0333 0.0001 -1.4901 -0.5765 True The first column shows one of the groups in our comparison, namely the drug. The second column shows which other group we are comparing against in pairs. The third column is our statistic (the mean difference), and the fourth column is the adjusted pp value. The fifth and sixth columns show the lower and upper bounds of the 95% confidence interval for the mean difference. The final column shows whether or not we reject the null hypothesis that the mean difference is zero. The easiest way to interpret the results is to look at what pairs have rejected the null hypothesis (of not having a significant difference). In our case, we see in the first result line that Joyzepam is significantly better than Anxifree, because the mean difference is positive (meaning an improvement from Anxifree to Joyzepam), our pp-value is less than 0.05, and the confidence interval does not include zero. The last column indicates we rejected the null hypothesis. We also see in the third line that Joyzepam is significantly better than the placebo because the mean difference is negative from Joyzepam to placebo. The pp-value is less than 0.05, and the confidence interval does not include zero, and the last column indicates we rejected the null hypothesis. In the second line, from Anxifree to the placebo, we see a negative mean difference, meaning that while Anxifree looks like it’s performing better than the placebo (as we’ve seen in the boxplot as well), the confidence interval does include zero, and the pp-value is greater than 0.05, so we fail to reject the null hypothesis. What we would write up next to our ANOVA result is the following: Post hoc tests indicated that Joyzepam produced a significantly larger mood change than both Anxifree (p = .002) and the placebo (p &lt; .001). We found no evidence that Anxifree performed better than the placebo (p = .31). 12.6 Checking the homogeneity of variance assumption There’s more than one way to skin a cat, as the saying goes, and more than one way to test the homogeneity of variance assumption, too. The most commonly used test for this is the Levene test (Levene, 1960), which CogStat uses.61 Levene’s test is shockingly simple. Suppose we have our outcome variable YikY_{ik}. All we do is define a new variable, say, ZikZ_{ik}, corresponding to the absolute deviation from the group mean: Zik=|Yik−Y‾k| Z_{ik} = \\left| Y_{ik} - \\bar{Y}_k \\right| The value of ZikZ_{ik} is a measure of how the ii-th observation in the kk-th group deviates from its group mean. And our null hypothesis is that all groups have the same variance; that is, the same overall deviations from the group means. So the null hypothesis in a Levene’s test is that the population means of ZZ are identical for all groups. Isn’t that what ANOVA is? Yes. All that the Levene’s test does is run an ANOVA on the new variable ZikZ_{ik}62. If we look at the output from Cogstat (Figure 12.6), we see that the test is non-significant W=1.47,p=.262W = 1.47, p = .262. So it looks like the homogeneity of variance assumption is fine. 12.7 Testing for non-normal data with Kruskal-Wallis test CogStat automatically checked for normality, and we covered the Shapiro-Wilk test in Chapter 11.7. However, let’s talk about removing the normality assumption. In the context of a one-way ANOVA, the easiest solution is probably to switch to a non-parametric test (i.e. one that doesn’t rely on any particular assumption about the kind of distribution involved). We’ve seen non-parametric tests before, in Chapter 11: when you only have two groups, the Wilcoxon test provides the non-parametric alternative that you need. When you’ve got three or more groups, though, you can use the Kruskal-Wallis rank sum test (Kruskal &amp; Wallis, 1952). The Kruskal-Wallis test is a non-parametric alternative to the one-way ANOVA, and it is surprisingly similar to it in some ways. It is a rank-based test, meaning that it doesn’t actually look at the values of the data, but rather at the order of the data. In ANOVA, we started with YikY_{ik}, the value of the outcome variable for the iith person in the kkth group. For the Kruskal-Wallis test, what we’ll do is rank order all of these YikY_{ik} values and conduct our analysis on the ranked data. So let’s let RikR_{ik} refer to the ranking given to the iith member of the kkth group. Now, let’s calculate R‾k\\bar{R}_k, the average rank given to observations in the kkth group: R‾k=1NK∑iRik \\bar{R}_k = \\frac{1}{N_K} \\sum_{i} R_{ik} and let’s also calculate R‾\\bar{R}, the grand mean rank: R‾=1N∑i∑kRik \\bar{R} = \\frac{1}{N} \\sum_{i} \\sum_{k} R_{ik} Now that we’ve done this, we can calculate the squared deviations from the grand mean rank R‾\\bar{R}. When we do this for the individual scores – i.e., if we calculate (Rik−R‾)2(R_{ik} - \\bar{R})^2 – what we have is a “non-parametric” measure of how far the ikik-th observation deviates from the grand mean rank. When we calculate the squared deviation of the group means from the grand means – i.e., if we calculate (R‾k−R‾)2(\\bar{R}_k - \\bar{R} )^2 – then what we have is a non-parametric measure of how much the group deviates from the grand mean rank. With this in mind, let’s follow the same logic that we did with ANOVA, and define our ranked sums of squares measures in much the same way that we did earlier. First, we have our “total ranked sums of squares”: RSStot=∑k∑i(Rik−R‾)2 \\mbox{RSS}_{tot} = \\sum_k \\sum_i ( R_{ik} - \\bar{R} )^2 and we can define the “between-groups ranked sums of squares” like this: RSSb=∑k∑i(R‾k−R‾)2=∑kNk(R‾k−R‾)2 \\begin{array}{rcl} \\mbox{RSS}_{b} &amp;=&amp; \\sum_k \\sum_i ( \\bar{R}_k - \\bar{R} )^2 \\\\ &amp;=&amp; \\sum_k N_k ( \\bar{R}_k - \\bar{R} )^2 \\end{array} So, if the null hypothesis is true and there are no true group differences at all, you’d expect the between group rank sums RSSb\\mbox{RSS}_{b} to be very small, much smaller than the total rank sums RSStot\\mbox{RSS}_{tot}. Qualitatively this is very much the same as what we found when we went about constructing the ANOVA FF-statistic; but for technical reasons the Kruskal-Wallis test statistic, usually denoted HH (but let’s not conflate with “hypothesis”!). In CogStat, you’ll see χ2\\chi^2. The official formula is: H=(N−1)×RSSbRSStot H = (N - 1) \\times \\frac{\\mbox{RSS}_b}{\\mbox{RSS}_{tot}} and, if the null hypothesis is true, then the sampling distribution of HH is approximately chi-square with G−1G-1 degrees of freedom (where GG is the number of groups). The larger the value of HH, the less consistent the data are with null hypothesis, so this is a one-sided test: we reject our null hypothesis when HH is sufficiently large. At a conceptual level, this is the right way to think about how the test works. However, from a purely mathematical perspective, it’s needlessly complicated. The equation for HH can be rewritten as H=12N(N−1)∑kNkR‾k2−3(N+1) H = \\frac{12}{N(N-1)} \\sum_k N_k {\\bar{R}_k}^2 - 3(N+1) The story is true when there are no ties in the raw data. That is, if there are no two observations that have exactly the same value. If there are ties, then we have to introduce a correction factor to these calculations. At this point, even the most diligent reader might have stopped caring (or at least formed the opinion that the tie-correction factor is something that doesn’t require their immediate attention). So let us omit the tedious details about why it’s done this way. We can look at a frequency table for the raw data (under Explore variable), and let fjf_j be the number of observations that have the jj-th unique value. Figure 12.7: Frequency table for the raw data (mood_gain). Looking at this table, notice that the value of 0.30.3 (and 0.60.6, 1.31.3, 1.41.4) has a frequency of 2. This is telling us that two people’s mood increased by 0.3 (and 0.6…). More to the point, note that we can say f3=2f_3 = 2, where 3 is the index of the value (i.e. row number 3). Yay. So, now that we know this, the tie correction factor (TCF) is: TCF=1−∑jfj3−fjN3−N \\mbox{TCF} = 1 - \\frac{\\sum_j {f_j}^3 - f_j}{N^3 - N} The tie-corrected value of the Kruskal-Wallis statistic obtained by dividing the value of HH by this quantity. If the data was non-normal, CogStat would automatically calculate the non-parametric test. However, it’s normal, so you’ll just have to trust us that the results are H=12.076 H = 12.076 However, it’s good to take a look at how CogStat would display the results for non-normal data, particularly because the post hoc test results are different. So, here’s some tweaking of our clinical trial data with the placebo results not meeting the normality assumption: clinical_nonnormal.csv (the placebo group’s data is more “flat” when plotted). Let’s load it in CogStat and explore the Compare groups result set. Figure 12.8: CogStat results for the non-normal data. The boxplot shows we have a similar setup to our original data, but we see that the placebo group’s mood_gain is not normally distributed (because the Shapiro-Wilk test is significant with p&lt;0.05p &lt; 0.05, and also the mood gain is now flattened on purpose for the sake of the exercise), so CogStat automatically calculates the non-parametric test. The results are: Result of the Kruskal-Wallis test: χ2(2,N=18)=13.31,p=.001 \\chi^2(2, N = 18) = 13.31, p = .001 This is pretty straightforward: the test statistic proves that the null hypothesis is false. Now let’s look at the post hoc results: We see that CogStat ran the Dunn’s Multiple Comparison Test for the non-normal data post hoc analysis. This is a pairwise comparison with 5% α\\alpha significance level. From the table, you cannot read a specific statistic to show what are the differences between the groups and what is their direction, but you see a pp-value of significance. So what you can do, is list all the pairs where pp is significant, and then you can look at the boxplot to see the direction of the difference (or more scientifically, the descriptive statistics results where you have the means for each group). For example, we see two pairs, where the pp is significant (p&lt;0.05p &lt; 0.05): The first pair is Joyzepam and Anxifree, where p=0.024p = 0.024 (regardless if you read it by column or row). This means that the difference between the two groups is significant, but we don’t know the direction of the difference. We can look at the boxplot to see that the Joyzepam group has a higher mean than the Anxifree group, and we can quantify it by looking at the means: 0.720.72 for Anxifree, and 1.481.48 for Joyzepam. So Joyzepam is more effective than Anxifree, and the result is significant. The second (and final) pair is Joyzepam and the placebo, where p=0.000p = 0.000, or more formally, p&lt;0.001p &lt; 0.001. This means that the difference between the two groups is significant, and we can see that Joyzepam (1.481.48) has a higher mean than the placebo (0.280.28). So Joyzepam is more effective than the placebo, and the result is significant. Our effect size is calculated with omega-squared as before, which, for this altered data set is: 0.7470.747. Our write-up would be something along the lines of: The Kruskal-Wallis test showed a significant effect of drug on mood gain (H(2, N=18) = 13.31, p = .001, ω2\\omega^2 = .747$). Post hoc tests indicated that Joyzepam produced a significantly larger mood change than both Anxifree (p = .024) and the placebo (p &lt; .001). We found no evidence that Anxifree performed better than the placebo (p = .175). And we’re done. 12.8 On the relationship between ANOVA and the Student tt-test It’s something that a lot of people find kind of surprising but it’s worth knowing about: an ANOVA with two groups is identical to the Student tt-test. It’s not just that they are similar, but they are actually equivalent in every meaningful way. Suppose that, instead of running an ANOVA on our mood_gain ~ drug model, let’s instead do it using therapy as the predictor. If we run this in Compare group, CogStat automatically selects the independent sample tt-test, as we’ve seen in Chapter 11. Here’s the result when running the therapy model: Figure 12.9: CogStat results for the therapy model. Having run a tt-test, we get t(16)=1.31t(16) = 1.31 (or more precisely, 1.30681.3068 – you’ll see why this is important). The pp-value is .210.210. Should we run a one-way ANOVA FF-statistic in another software, we’d see F(1,16)=1.71F(1,16) = 1.71, and the pp-value, which is – not surprisingly – .210.210. But hang on, what is the story with the FF and tt statistics? Actually, there is a fairly straightforward relationship here. If we square the tt-statistic: 1.30682 1.3068 ^ 2 we get the FF-statistic from before: 1.71 1.71 Such fun! 12.9 Summary Like any statistical test, analysis of variance relies on some assumptions about the data. Normality. The residuals are assumed to be normally distributed. As we saw in Chapter 11.7, we can assess this by looking at QQ plots or running a Shapiro-Wilk test. If normality fails, we can run a Kruskal-Wallis test instead (see Chapter 12.7). Homogeneity of variance. Notice that we’ve only got the one value for the population standard deviation (i.e. σ\\sigma), rather than allowing each group to have its own value (i.e. σk\\sigma_k). This is referred to as the homogeneity of variance or homoscedasticity assumption. ANOVA assumes that the population standard deviation is the same for all groups. See Chapter 12.6. If the homogeneity of variance assumption fails, CogStat runs the Kruskal-Wallis test instead (see Chapter 12.7), similarly to when the normality assumption is violated. Independence. The independence assumption is a little trickier. What it basically means is that, knowing one residual tells you nothing about any other residual. All of the ϵik\\epsilon_{ik} values are assumed to have been generated without any “regard for” or “relationship to” any of the other ones. There’s not an obvious or simple way to test for this, but there are some situations that are clear violations of this: for instance, if you have a repeated measures design, where each participant in your study appears in more than one condition, then independence doesn’t hold. When that happens, you need to use repeated measures ANOVA (accessible in Compare repeated measures variable). Some parts of this chapter was influenced by Sahai &amp; Ageel (2000), which is an excellent book for more advanced readers who are interested in understanding the mathematics behind ANOVA. References Brown, M. B., &amp; Forsythe, A. B. (1974). Robust tests for equality of variances. Journal of the American Statistical Association, 69, 364–367. Hays, W. L. (1994). Statistics (5th ed.). Harcourt Brace. Hsu, J. C. (1996). Multiple comparisons: Theory and methods. Chapman; Hall. Kruskal, W. H., &amp; Wallis, W. A. (1952). Use of ranks in one-criterion variance analysis. Journal of the American Statistical Association, 47, 583–621. Levene, H. (1960). Robust tests for equality of variances. In I. O. et al (Ed.), Contributions to probability and statistics: Essays in honor of harold hotelling (pp. 278–292). Stanford University Press. Sahai, H., &amp; Ageel, M. I. (2000). The analysis of variance: Fixed, random and mixed models. Birkhauser. When all groups have the same number of observations, the experimental design is said to be “balanced”. Balance isn’t such a big deal for one-way ANOVA but becomes more important when you start doing more complicated ANOVAs.↩︎ You went into Excel and did it manually, and got the same answer, great! No, you used the VAR.P function and got the same answer. Great! Wait, you used the VAR.S and got 0.2850.285? Something’s not right. You went to jamovi or JASP or SPSS (because you’re fancy) and got 0.2850.285. What happened? There is a difference between population variance and estimated variance. The population variance is the variance of the population based on the fact you know all members of the population – which is the case in our example, as we need the population variance of our trial, not the population to which the trial results will extend to. The estimated variance is always going to be a little bit bigger than the population variance, because it’s an estimate, and uses a slightly different formula. Namely, it multiplies by 1N−1\\frac{1}{N-1}, not 1N\\frac{1}{N}.↩︎ Or, more accurately, 1+2df2−21 + \\frac{2}{df_2 - 2}.↩︎ http://daniellakens.blogspot.com.au/2015/06/why-you-should-use-omega-squared.html↩︎ https://apastyle.apa.org/instructional-aids/numbers-statistics-guide.pdf↩︎ There’s the closely related Brown-Forsythe test (Brown &amp; Forsythe, 1974) as well, which is what CogStat uses.↩︎ What about the Brown-Forsythe test? Does that do anything particularly different? Nope. The only change from the Levene’s test is that it constructs the transformed variable ZZ in a slightly different way, using deviations from the group medians rather than deviations from the group means.↩︎ "],["anova2.html", "Chapter 13 Comparing several groups (factorial ANOVA) 13.1 Balanced designs 13.2 Effect size 13.3 Estimated group means and confidence intervals 13.4 Post hoc tests 13.5 Unbalanced designs and types of sums of squares", " Chapter 13 Comparing several groups (factorial ANOVA) In past chapters, we compared two groups for the same variable (Chapter 12), or we compared two variables (Chapter 11). In this chapter, we are going to look at more than one grouping variables, which we sometimes refer to as factorial ANOVA. 13.1 Balanced designs When we discussed the analysis of variance in Chapter 12, we assumed a fairly simple experimental design: each person falls into one of several groups, and we want to know whether these groups have different means on some outcome variable. In this section, we will look at a broader class of experimental designs, known as factorial designs, where we have more than one grouping variable. Let’s take the example that appears in Chapter 12, in which we were looking at the effect of different drugs on the mood_gain experienced by each person. In that chapter, we did find a significant effect of drug (Chapter 12.3), but at the end of the chapter we also ran an analysis to see if there was an effect of therapy (Chapter 12.8). We didn’t find one, but there’s something a bit worrying about trying to run two separate analyses trying to predict the same outcome. Maybe there actually is an effect of therapy on mood gain, but we couldn’t find it because it was being “hidden” by the effect of drug? In other words, we’re going to want to run a single analysis that includes both drug and therapy as predictors. For this analysis, each person is cross-classified by the drug they were given (a factor with 3 levels) and what therapy they received (a factor with 2 levels). We refer to this as a 3×23 \\times 2 factorial design. Let’s load the clinicaltrial.csv data set again to CogStat, and run the Compare groups function with both drug and therapy as grouping variables. We get the following table: As you can see, not only do we have participants corresponding to all possible combinations of the two factors, indicating that our design is completely crossed, it turns out that there are an equal number of people in each group. In other words, we have a balanced design. 13.1.1 What hypotheses are we testing? Like one-way ANOVA, factorial ANOVA is a tool for testing certain types of hypotheses about population means. So a sensible place to start would be to be explicit about what our hypotheses actually are. However, before we can even get to that point, it’s really useful to have some clean and simple ways to describe the means. Because of the fact that observations are cross-classified in terms of two different factors, we’ll need a cross-tabulation of sorts. Now, this output by CogStat shows a cross-tabulation of the group means and other descriptive statistics for all possible combinations of the two factors (e.g. people who received the placebo and no therapy, people who received the placebo while getting CBT etc.), and it also shows a boxplot comparing these combinations. But sometimes, we want to dissect our data in a different output format. To do that, we have the Pivot table function in CogStat. Let’s use it to create a cross-tabulation of the means of mood_gain for each combination of drug and therapy. Figure 13.1: Cross-tabulation of the means of mood_gain for each combination of drug and therapy in Pivot table function. You can select different functions to tabulate: N (count), Sum, Mean, Median, Lower and Upper quartile, Standard deviation, and Variance. Let’s use some mathematical notation and the symbol μ\\mu to denote a population mean. However, because there are lots of different means, we’ll need to use subscripts to distinguish between them. Here’s how the notation works. Our table is defined in terms of two factors: each row corresponds to a different level of Factor A (in this case, drug), and each column corresponds to a different level of Factor B (in this case, therapy). If we let RR denote the number of rows in the table, and CC denote the number of columns, we can refer to this as an R×CR \\times C factorial ANOVA. In this case R=3R=3 and C=2C=2. We’ll use lowercase letters to refer to specific rows and columns, so μrc\\mu_{rc} refers to the population mean associated with the rrth level of Factor A (i.e. row number rr) and the ccth level of Factor B (column number cc).63 We use the “dot” notation to express averages across rows and columns. In the case of Joyzepam, notice that we’re talking about the mean associated with the third row in the table. That is, we’re averaging across two cell means (i.e., μ31\\mu_{31} and μ32\\mu_{32}). The result of this averaging is referred to as a marginal mean, and would be denoted μ3.\\mu_{3.} in this case. The marginal mean for CBT corresponds to the population mean associated with the second column in the table, so we use the notation μ.2\\mu_{.2} to describe it. The grand mean is denoted μ..\\mu_{..} because it is the mean obtained by averaging (marginalising64) over both. So our full table of population means can be written down like this: Table 13.1: Population means in factorial ANOVA. No therapy CBT Total Placebo μ11\\mu_{11} μ12\\mu_{12} μ1.\\mu_{1.} Anxifree μ21\\mu_{21} μ21\\mu_{21} μ2.\\mu_{2.} Joyzepam μ31\\mu_{31} μ32\\mu_{32} μ3.\\mu_{3.} Total μ.1\\mu_{.1} μ.2\\mu_{.2} μ..\\mu_{..} Now that we have this notation, it is straightforward to formulate and express some hypotheses. Let’s suppose that the goal is to find out two things: firstly, does the drug choice have any effect on mood, and secondly, does CBT have any effect on mood? These aren’t the only hypotheses that we could formulate of course, but these are the two simplest hypotheses to test, and so we’ll start there. Consider the first test. If the drug has no effect, then we would expect all of the row means to be identical, right? So that’s our null hypothesis. On the other hand, if the drug does matter, then we should expect these row means to be different. Formally, we write down our null and alternative hypotheses in terms of the equality of marginal means: Null hypothesis H0H_0: row means are the same i.e. μ1.=μ2.=μ3.\\mu_{1.} = \\mu_{2.} = \\mu_{3.} Alternative hypothesis H1H_1: at least one row mean is different. It’s worth noting that these are exactly the same statistical hypotheses that we formed when we ran a one-way ANOVA on these data back in Chapter 12. Back then, we used the notation μP\\mu_P to refer to the mean mood gain for the placebo group, with μA\\mu_A and μJ\\mu_J corresponding to the group means for the two drugs, and the null hypothesis was μP=μA=μJ\\mu_P = \\mu_A = \\mu_J. So we’re actually talking about the same hypothesis: it’s just that the more complicated ANOVA requires more careful notation due to the presence of multiple grouping variables, so we’re now referring to this hypothesis as μ1.=μ2.=μ3.\\mu_{1.} = \\mu_{2.} = \\mu_{3.}. However, as we’ll see shortly, although the hypothesis is identical, the test of that hypothesis is subtly different due to the fact that we’re now acknowledging the existence of the second grouping variable. Speaking of the other grouping variable, you won’t be surprised to discover that our second hypothesis test is formulated the same way. However, since we’re talking about the psychological therapy rather than drugs, our null hypothesis now corresponds to the equality of the column means: Null hypothesis H0H_0: column means are the same, i.e., μ.1=μ.2\\mu_{.1} = \\mu_{.2} Alternative hypothesis H1H_1: column means are different, i.e., μ.1≠μ.2\\mu_{.1} \\neq \\mu_{.2} 13.1.2 Means, sums of squares, and degrees of freedom The null and alternative hypotheses might seem awfully familiar: they’re basically the same as the hypotheses that we were testing in our simpler one-way ANOVAs in Chapter 12. So you’re probably expecting that the hypothesis tests that are used in factorial ANOVA will be essentially the same as the FF-test from Chapter 12. You’re expecting to see references to sums of squares (SS), mean squares (MS), degrees of freedom (df), and finally an FF-statistic that we can convert into a pp-value, right? Well, you’re absolutely and completely right. We used μ\\mu for population means, but we’ll use Y‾\\bar{Y} to refer to a sample mean. For the rest of the formulas, we can use the same notation as before to refer to group means, marginal means and grand means: that is, Y‾rc\\bar{Y}_{rc} is the sample mean associated with the rrth level of Factor A and the ccth level of Factor B, Y‾r.\\bar{Y}_{r.} would be the marginal mean for the rrth level of Factor A, Y‾.c\\bar{Y}_{.c} would be the marginal mean for the ccth level of Factor B, and Y‾..\\bar{Y}_{..} is the grand mean. In other words, our sample means can be organised into the same table as the population means. For our clinical trial data, that table looks like this: No therapy CBT Total Placebo Y‾11\\bar{Y}_{11} Y‾12\\bar{Y}_{12} Y‾1.\\bar{Y}_{1.} Anxifree Y‾21\\bar{Y}_{21} Y‾21\\bar{Y}_{21} Y‾2.\\bar{Y}_{2.} Joyzepam Y‾31\\bar{Y}_{31} Y‾32\\bar{Y}_{32} Y‾3.\\bar{Y}_{3.} Total Y‾.1\\bar{Y}_{.1} Y‾.2\\bar{Y}_{.2} Y‾..\\bar{Y}_{..} If we look at the sample means from earlier (Figure 13.1), we have Y‾11=0.30\\bar{Y}_{11} = 0.30, Y‾12=0.60\\bar{Y}_{12} = 0.60 etc. In our clinical trial example, the drugs factor has 3 levels and the therapy factor has 2 levels, and so what we’re trying to run is a 3×23 \\times 2 factorial ANOVA. To be a little more general, we can say that Factor A (the row factor) has RR levels and Factor B (the column factor) has CC levels, and so what we’re running here is an R×CR \\times C factorial ANOVA. The formula for the sum of squares values for each of the two factors is relatively familiar. For Factor A, our between group sum of squares is calculated by assessing the extent to which the (row) marginal means Y‾1.\\bar{Y}_{1.}, Y‾2.\\bar{Y}_{2.} etc, are different from the grand mean Y‾..\\bar{Y}_{..}: SSA=(N×C)∑r=1R(Y‾r.−Y‾..)2 \\mbox{SS}_{A} = (N \\times C) \\sum_{r=1}^R \\left( \\bar{Y}_{r.} - \\bar{Y}_{..} \\right)^2 The formula for factor B is, of course, the same thing, just with some subscripts shuffled around: SSB=(N×R)∑c=1C(Y‾.c−Y‾..)2 \\mbox{SS}_{B} = (N \\times R) \\sum_{c=1}^C \\left( \\bar{Y}_{.c} - \\bar{Y}_{..} \\right)^2 Okay, now let’s calculate the sum of squares associated with the main effect of drug. There are a total of N=3N=3 people in each group, and C=2C=2 different types of therapy. Or, to put it another way, there are 3×2=63 \\times 2 = 6 people who received any particular drug. So our calculations are: SSdrug=(N×C)∑r=1R(Y‾r.−Y‾..)2=3.453333 \\begin{array}{rcl} \\mbox{SS}_{drug} &amp;=&amp; (N \\times C) \\sum_{r=1}^R \\left( \\bar{Y}_{r.} - \\bar{Y}_{..} \\right)^2 \\\\ &amp;=&amp; 3.453333 \\end{array} We can repeat the same kind of calculation for the effect of therapy. Again there are N=3N=3 people in each group, but since there are R=3R=3 different drugs, this time around we note that there are 3×3=93 \\times 3 = 9 people who received CBT, and an additional 9 people who received the placebo. So our calculation is now: SStherapy=(N×C)∑r=1R(Y‾r.−Y‾..)2=0.467222 \\begin{array}{rcl} \\mbox{SS}_{therapy} &amp;=&amp; (N \\times C) \\sum_{r=1}^R \\left( \\bar{Y}_{r.} - \\bar{Y}_{..} \\right)^2 \\\\ &amp;=&amp; 0.467222 \\end{array} So that’s how you calculate the SS values for the two main effects. These SS values are analogous to the between-group sum of squares values that we calculated when doing one-way ANOVA in Chapter 12. However, it’s not a good idea to think of them as between-groups SS values anymore, just because we have two different grouping variables and it’s easy to get confused. In order to construct an FF test, however, we also need to calculate the within-groups sum of squares. We will refer to the within-groups SS value as the residual65 sum of squares SSR_R. The easiest way to think about the residual SS values in this context, is to think of it as the leftover variation in the outcome variable after you take into account the differences in the marginal means (i.e. after you remove SSdrug_{drug} and SStherapy_{therapy}). What I mean by that is we can start by calculating the total sum of squares (SST_T). We take the difference between each observation YrciY_{rci} and the grand mean Y‾..\\bar{Y}_{..}, square the differences, and add them all up SST=∑r=1R∑c=1C∑i=1N(Yrci−Y‾..)2=4.845 \\begin{array}{rcl} \\mbox{SS}_T &amp;=&amp; \\sum_{r=1}^R \\sum_{c=1}^C \\sum_{i=1}^N \\left( Y_{rci} - \\bar{Y}_{..}\\right)^2 \\\\ &amp;=&amp; 4.845 \\end{array} The “triple summation” here looks more complicated than it is. In the first two summations, we’re summing across all levels of Factor A (i.e., over all possible rows rr in our table), across all levels of Factor B (i.e. all possible columns cc). Each rcrc combination corresponds to a single group, and each group contains NN people: so we have to sum across all those people (i.e. all ii values) too. In other words, all we’re doing here is summing across all observations in the data set (i.e. all possible rcirci combinations). The residual sum of squares is thus defined to be the variability in YY that can’t be attributed to either of our two factors. In other words: SSR=SST−(SSA+SSB)=4.845−(3.45333+0.46722)=0.92445 \\begin{array}{rcl} \\mbox{SS}_R &amp;=&amp; \\mbox{SS}_T - (\\mbox{SS}_A + \\mbox{SS}_B) \\\\ &amp;=&amp; 4.845 - (3.45333 + 0.46722) \\\\ &amp;=&amp; 0.92445 \\end{array} It is commonplace to refer to SSA+SSB\\mbox{SS}_A + \\mbox{SS}_B as the variance attributable to the “ANOVA model”, denoted SSM_M, and so we often say that the total sum of squares is equal to the model sum of squares plus the residual sum of squares. The degrees of freedom are calculated in much the same way as for one-way ANOVA. The degrees of freedom equals the number of quantities that are observed, minus the number of constraints. So, for the drugs factor, we observe 3 separate group means, but these are constrained by 1 grand mean; and therefore the degrees of freedom is df=2df = 2. For the therapy factor we obtain df=1df=1. For the residuals, the logic is similar, but not quite the same. The total number of observations in our experiment is 18. The constraints correspond to the 1 grand mean, the 2 additional group means that the drug factor introduces, and the 1 additional group mean that the the therapy factor introduces, and so our degrees of freedom is 14. As a formula, this is N−1−(R−1)−(C−1)N-1 -(R-1)-(C-1), which simplifies to N−R−C+1N-R-C+1. Just like we saw with the original one-way ANOVA, note that the mean square value is calculated by dividing SS by the corresponding dfdf. That is, it’s still true that MS=SSdf \\mbox{MS} = \\frac{\\mbox{SS}}{df} regardless of whether we’re talking about drug, therapy or the residuals. To see this, let’s not worry about how the sums of squares values are calculated. So for the drug factor, we divide 3.453333.45333 by 22, and end up with a mean square value of 1.731.73. For the therapy factor, there’s only 1 degree of freedom, so our calculations are even simpler: dividing 0.467220.46722 (the SS value) by 1 gives us an answer of 0.470.47 (the MS value). Turning to the FF statistics and the pp values, notice that we have two of each: one corresponding to the drug factor and the other corresponding to the therapy factor. Regardless of which one we’re talking about, the FF statistic is calculated by dividing the mean square value associated with the factor by the mean square value associated with the residuals: FA=MSAMSR F_{A} = \\frac{\\mbox{MS}_{A}}{\\mbox{MS}_{R}} and an equivalent formula exists for factor B (i.e. therapy). So for the drug factor, we take the mean square of 1.731.73 and divide it by the residual mean square value of 0.070.07, which gives us an FF-statistic of 26.1526.15. The corresponding calculation for the therapy variable would be to divide 0.470.47 by 0.070.07 which gives 7.087.08 as the FF-statistic. Regarding the pp-value, what we’re trying to do is test the null hypothesis that there is no relationship between the factor and the outcome variable. To that end, we’ve followed a similar strategy that we did in the one-way ANOVA, and have calculated an FF-statistic for each of these hypotheses. To convert these to pp values, all we need to do is note that the sampling distribution for the FF statistic under the null hypothesis is an FF distribution, and that two degrees of freedom values are those corresponding to the factor, and those corresponding to the residuals. For the drug factor we’re talking about an FF distribution with 2 and 14 degrees of freedom. In contrast, for the therapy factor sampling distribution is FF with 1 and 14 degrees of freedom. So, for the drug factor, we have an FF-statistic of 26.1526.15 and an FF-distribution with 2 and 14 degrees of freedom. The corresponding pp-value is &lt;0.001&lt;0.001. For the therapy factor, we have an FF-statistic of 7.087.08 and an FF-distribution with 1 and 14 degrees of freedom. The corresponding pp-value is 0.020.02. But hang on! You’ve run the analysis in CogStat and you see something vastly different. That’s okay. Bear with us for a moment. 13.1.3 The interaction The ANOVA model that we’ve been talking about so far covers a range of different patterns that we might observe in our data. For instance, in a two-way ANOVA design, there are four possibilities: (a) only Factor A matters, (b) only Factor B matters, (c) both A and B matter, and (d) neither A nor B matters. An example of each of these four possibilities is plotted in Figure 13.2. Figure 13.2: Factor main effects The four patterns of data shown in Figure 13.2 are all quite realistic: there are a great many data sets that produce exactly those patterns. However, they are not the whole story, and the ANOVA model that we have been talking about up to this point is not sufficient to fully account for a table of group means. Why not? Well, so far we have the ability to talk about the idea that drugs can influence mood, and therapy can influence mood, but no way of talking about the possibility of an interaction between the two. An interaction between A and B is said to occur whenever the effect of Factor A is different, depending on which level of Factor B we’re talking about. Several examples of an interaction effect with the context of a 2 x 2 ANOVA are shown in Figure 13.3. Figure 13.3: Qualitatively different interactions for a 2×22 \\times 2 ANOVA To give a more concrete example, suppose that the operation of Anxifree and Joyzepam is governed quite different physiological mechanisms, and one consequence of this is that while Joyzepam has more or less the same effect on mood regardless of whether one is in therapy, Anxifree is actually much more effective when administered in conjunction with CBT. The ANOVA that we developed manually, does not capture this idea. To get some idea of whether an interaction is actually happening here, it helps to plot the various group means. Figure 13.4: Interaction plot for our clinical trial data Our main concern relates to the fact that the two lines aren’t parallel. The effect of CBT (difference between solid line and dotted line) when the drug is Joyzepam (right side) appears to be near zero, even smaller than the effect of CBT when a placebo is used (left side). However, when Anxifree is administered, the effect of CBT is larger than the placebo (middle). Is this effect real, or is this just random variation due to chance? Our original ANOVA cannot answer this question, because we make no allowances for the idea that interactions even exist! In this section, we’ll fix this problem. Although there are only two factors involved in our model (i.e. drug and therapy), there are actually three distinct terms (i.e. drug, therapy and drug × therapy). That is, in addition to the main effects of drug and therapy, we have a new component to the model, which is our interaction term drug × therapy. Intuitively, the idea behind an interaction effect is fairly simple: it means that the effect of Factor A is different, depending on which level of Factor B we’re talking about. But what does that actually mean in terms of our data? Figure 13.4 depicts several different patterns that, although quite different to each other, would all count as an interaction effect. So it’s not entirely straightforward to translate this qualitative idea into something mathematical that a statistician can work with. As a consequence, the way that the idea of an interaction effect is formalised in terms of null and alternative hypotheses is slightly difficult. To start with, we need to be a little more explicit about our main effects. Consider the main effect of Factor A (drug in our running example). We originally formulated this in terms of the null hypothesis that the two marginal means μr.\\mu_{r.} are all equal to each other. Obviously, if all of these are equal to each other, then they must also be equal to the grand mean μ..\\mu_{..} as well, right? So what we can do is define the effect of Factor A at level rr to be equal to the difference between the marginal mean μr.\\mu_{r.} and the grand mean μ..\\mu_{..}. Let’s denote this effect by αr\\alpha_r, and note that αr=μr.−μ.. \\alpha_r = \\mu_{r.} - \\mu_{..} Now, by definition all of the αr\\alpha_r values must sum to zero, for the same reason that the average of the marginal means μr.\\mu_{r.} must be the grand mean μ..\\mu_{..}. We can similarly define the effect of Factor B at level ii to be the difference between the column marginal mean μ.c\\mu_{.c} and the grand mean μ..\\mu_{..} βc=μ.c−μ.. \\beta_c = \\mu_{.c} - \\mu_{..} and once again, these βc\\beta_c values must sum to zero. The reason that statisticians sometimes like to talk about the main effects in terms of these αr\\alpha_r and βc\\beta_c values is that it allows them to be precise about what it means to say that there is no interaction effect. If there is no interaction at all, then these αr\\alpha_r and βc\\beta_c values will perfectly describe the group means μrc\\mu_{rc}. Specifically, it means that μrc=μ..+αr+βc \\mu_{rc} = \\mu_{..} + \\alpha_r + \\beta_c That is, there’s nothing special about the group means that you couldn’t predict perfectly by knowing all the marginal means. And that’s our null hypothesis, right there. The alternative hypothesis is that μrc≠μ..+αr+βc \\mu_{rc} \\neq \\mu_{..} + \\alpha_r + \\beta_c for at least one group rcrc in our table. However, statisticians often like to write this slightly differently. They’ll usually define the specific interaction associated with group rcrc to be some number, awkwardly referred to as (αβ)rc(\\alpha\\beta)_{rc}, and then they will say that the alternative hypothesis is that μrc=μ..+αr+βc+(αβ)rc\\mu_{rc} = \\mu_{..} + \\alpha_r + \\beta_c + (\\alpha\\beta)_{rc} where (αβ)rc(\\alpha\\beta)_{rc} is non-zero for at least one group. This notation is kind of ugly to look at, but it is handy to calculate the sum of squares. How should we calculate the sum of squares for the interaction terms, SSA:B_{A:B}? For Factor A, a good way to estimate the main effect at level rr as the difference between the sample marginal mean Y‾rc\\bar{Y}_{rc} and the sample grand mean Y‾..\\bar{Y}_{..}. That is, we would use this as our estimate of the effect66: α̂r=Y‾r.−Y‾.. \\hat{\\alpha}_r = \\bar{Y}_{r.} - \\bar{Y}_{..} Similarly, our estimate of the main effect of Factor B at level cc can be defined as follows: β̂c=Y‾.c−Y‾.. \\hat{\\beta}_c = \\bar{Y}_{.c} - \\bar{Y}_{..} Now, if you go back to the formulas of the SS values for the two main effects, you’ll notice that these effect terms are exactly the quantities that we were squaring and summing! So what’s the analogue of this for interaction terms? The answer to this can be found by first rearranging the formula for the group means μrc\\mu_{rc} under the alternative hypothesis, so that we get this: (αβ)rc=μrc−μ..−αr−βc=μrc−μ..−(μr.−μ..)−(μ.c−μ..)=μrc−μr.−μ.c+μ..\\begin{eqnarray*} (\\alpha \\beta)_{rc} &amp;=&amp; \\mu_{rc} - \\mu_{..} - \\alpha_r - \\beta_c \\\\ &amp;=&amp; \\mu_{rc} - \\mu_{..} - (\\mu_{r.} - \\mu_{..}) - (\\mu_{.c} - \\mu_{..}) \\\\ &amp;=&amp; \\mu_{rc} - \\mu_{r.} - \\mu_{.c} + \\mu_{..} \\end{eqnarray*} So, once again, if we substitute our sample statistics in place of the population means, we get the following as our estimate of the interaction effect for group rcrc, which is (αβ)̂rc=Y‾rc−Y‾r.−Y‾.c+Y‾.. \\hat{(\\alpha\\beta)}_{rc} = \\bar{Y}_{rc} - \\bar{Y}_{r.} - \\bar{Y}_{.c} + \\bar{Y}_{..} Now all we have to do is sum all of these estimates across all RR levels of Factor A and all CC levels of Factor B, and we obtain the following formula for the sum of squares associated with the interaction as a whole: SSA:B=N∑r=1R∑c=1C(Y‾rc−Y‾r.−Y‾.c+Y‾..)2 \\mbox{SS}_{A:B} = N \\sum_{r=1}^R \\sum_{c=1}^C \\left( \\bar{Y}_{rc} - \\bar{Y}_{r.} - \\bar{Y}_{.c} + \\bar{Y}_{..} \\right)^2 where, we multiply by NN because there are NN observations in each of the groups, and we want our SS values to reflect the variation among observations accounted for by the interaction, not the variation among groups. Now that we have a formula for calculating SSA:B_{A:B}, it’s important to recognise that the interaction term is part of the model (of course), so the total sum of squares associated with the model, SSM_M is now equal to the sum of the three relevant SS values, SSA+SSB+SSA:B\\mbox{SS}_A + \\mbox{SS}_B + \\mbox{SS}_{A:B}. The residual sum of squares SSR\\mbox{SS}_R is still defined as the leftover variation, namely SST−SSM\\mbox{SS}_T - \\mbox{SS}_M, but now that we have the interaction term this becomes SSR=SST−(SSA+SSB+SSA:B) \\mbox{SS}_R = \\mbox{SS}_T - (\\mbox{SS}_A + \\mbox{SS}_B + \\mbox{SS}_{A:B}) As a consequence, the residual sum of squares SSR_R will be smaller than in our original ANOVA that didn’t include interactions. Calculating the degrees of freedom for the interaction is, once again, slightly trickier than the corresponding calculation for the main effects. To start with, let’s think about the ANOVA model as a whole. Once we include interaction effects in the model, we’re allowing every single group has a unique mean, μrc\\mu_{rc}. For an R×CR \\times C factorial ANOVA, this means that there are R×CR \\times C quantities of interest in the model, and only the one constraint: all of the group means need to average out to the grand mean. So the model as a whole needs to have (R×C)−1(R\\times C) - 1 degrees of freedom. But the main effect of Factor A has R−1R-1 degrees of freedom, and the main effect of Factor B has C−1C-1 degrees of freedom. Which means that the degrees of freedom associated with the interaction is: dfA:B=(R×C−1)−(R−1)−(C−1)=RC−R−C+1=(R−1)(C−1) \\begin{array}{rcl} {df}_{A:B} &amp;=&amp; (R\\times C - 1) - (R - 1) - (C -1 ) \\\\ &amp;=&amp; RC - R - C + 1 \\\\ &amp;=&amp; (R-1)(C-1) \\end{array} which is just the product of the degrees of freedom associated with the row factor and the column factor. What about the residual degrees of freedom? Because we’ve added interaction terms, which absorb some degrees of freedom, there are fewer residual degrees of freedom left over. Specifically, note that if the model with interaction has a total of (R×C)−1(R \\times C) - 1, and there are NN observations in your data set that are constrained to satisfy 1 grand mean, your residual degrees of freedom now become N−(R×C)−1+1N-(R \\times C)-1+1, or just N−(R×C)N-(R \\times C). This means that our residual degrees of freedom are for the model with interaction are: N−(R×C)N-(R \\times C) for the residual degrees of freedom: 18 - (3 ) = 12 (R−1)(C−1)(R-1)(C-1) for the interaction degrees of freedom: (3-1)(2-1) = 2 R−1R-1 for the main effect of Factor A (drug): 3 levels - 1 = 2 C−1C-1 for the main effect of Factor B (therapy): 2 levels - 1 = 1 This changes the FF-statistic for all of the effects in the model. Let’s look at the CogStat results now. Hypothesis tests Testing if the means are the same. At least two grouping variables. Interval variable. &gt;&gt; Choosing factorial ANOVA. Result of multi-way ANOVA: Main effect of drug: F(2, 12) = 31.71, p &lt; .001 Main effect of therapy: F(1, 12) = 8.58, p = .013 Interaction of drug and therapy: F(2, 12) = 2.49, p = .125 13.1.4 How to interpret the results There are a couple of very important things to consider when interpreting the results of factorial ANOVA. Firstly, there’s the same issue that we had with one-way ANOVA, which is that if you obtain a significant main effect of drug, it doesn’t tell you anything about which drugs are different to one another. Knowing that there’s a significant interaction doesn’t tell you anything about what kind of interaction exists. Again, you’ll need to run additional analyses. Secondly, there’s a very peculiar interpretation issue that arises when you obtain a significant interaction effect but no corresponding main effect. This happens sometimes. For instance, in the crossover interaction shown in Figure 13.3, this is exactly what you’d find: in this case, neither of the main effects would be significant, but the interaction effect would be. This is a difficult situation to interpret, and people often get a bit confused about it. The general advice that statisticians like to give in this situation is that you shouldn’t pay much attention to the main effects when an interaction is present. The reason they say this is that, although the tests of the main effects are perfectly valid from a mathematical point of view, when there is a significant interaction effect the main effects rarely test interesting hypotheses. Recall that the null hypothesis for a main effect is that the marginal means are equal to each other, and that a marginal mean is formed by averaging across several different groups. But if you have a significant interaction effect, then you know that the groups that comprise the marginal mean aren’t homogeneous, so it’s not really obvious why you would even care about those marginal means. Here’s what that means. Again, let’s stick with a clinical example. Suppose that we had a 2×22 \\times 2 design comparing two different treatments for phobias (e.g., systematic desensitisation vs flooding), and two different anxiety-reducing drugs (e.g., Anxifree vs Joyzepam). Now suppose what we found was that Anxifree had no effect when desensitisation was the treatment, and Joyzepam had no effect when flooding was the treatment. But both were pretty effective for the other treatment. This is a classic crossover interaction, and what we’d find when running the ANOVA is that there is no main effect of drug, but a significant interaction. Now, what does it actually mean to say that there’s no main effect? Well, it means that, if we average over the two different psychological treatments, then the average effect of Anxifree and Joyzepam is the same. But why would anyone care about that? When treating someone for phobias, it is never the case that a person can be treated using an “average” of flooding and desensitisation: that doesn’t make a lot of sense. You either get one or the other. For one treatment, one drug is effective; and for the other treatment, the other drug is effective. The interaction is the important thing; the main effect is kind of irrelevant. This sort of thing happens a lot: the main effects are tests of marginal means, and when an interaction is present we often find ourselves not being terribly interested in marginal means, because they imply averaging over things that the interaction tells us shouldn’t be averaged! Of course, it’s not always the case that a main effect is meaningless when an interaction is present. Often you can get a big main effect and a very small interaction, in which case you can still say things like “drug A is generally more effective than drug B” (because there was a big effect of drug), but you’d need to modify it a bit by adding that “the difference in effectiveness was different for different psychological treatments”. In any case, the main point here is that whenever you get a significant interaction you should stop and think about what the main effect actually means in this context. Don’t automatically assume that the main effect is interesting. 13.2 Effect size The effect size calculations for a factorial ANOVA should be similar to those used in one-way ANOVA (η2\\eta^2 and ω2\\omega^2). However, when doing a factorial ANOVA, there is a second measure of effect size that people like to report, known as partial η2\\eta^2. The idea behind partial η2\\eta^2 (which is sometimes denoted pη2_p\\eta^2 or ηp2\\eta^2_p) is that, when measuring the effect size for a particular term (e.g. the main effect of Factor A), you want to deliberately ignore the other effects in the model (e.g. the main effect of Factor B). That is, you would pretend that the effect of all these other terms is zero, and then calculate what the η2\\eta^2 value would have been. This is actually pretty easy to calculate. All you have to do is remove the sum of squares associated with the other terms from the denominator. In other words, if you want the partial η2\\eta^2 for the main effect of Factor A, the denominator is just the sum of the SS values for Factor A and the residuals: partial ηA2=SSASSA+SSR \\mbox{partial } \\eta^2_A = \\frac{\\mbox{SS}_{A}}{\\mbox{SS}_{A} + \\mbox{SS}_{R}} This will always give you a larger number than η2\\eta^2, which the cynic in me suspects accounts for the popularity of partial η2\\eta^2. And once again you get a number between 0 and 1, where 0 represents no effect. However, it’s slightly trickier to interpret what a large partial η2\\eta^2 value means. In particular, you can’t actually compare the partial η2\\eta^2 values across terms! Suppose, for instance, there is no within-groups variability at all: if so, SSR=0_R = 0. What that means is that every term has a partial η2\\eta^2 value of 1. But that doesn’t mean that all terms in your model are equally important, or indeed that they are equally large. All it means is that all terms in your model have effect sizes that are large relative to the residual variation. It is not comparable across terms. CogStat currently doesn’t provide effect sizes for multi-way ANOVAs. But if you’re interested in η2\\eta^2 and partial η2\\eta^2, read on. First, let’s have a look at the effect sizes for the original ANOVA without the interaction term: η2\\eta^2 Partial η2\\eta^2 Drug 0.713 0.789 Therapy 0.096 0.336 Looking at the η2\\eta^2 values first, we see that drug accounts for 71.3% of the variance (i.e. η2=0.713\\eta^2 = 0.713) in mood_gain, whereas therapy only accounts for 9.6%. This leaves a total of 19.1% of the variation unaccounted for (i.e. the residuals constitute 19.1% of the variation in the outcome). Overall, this implies that we have a very large effect67 of drug and a modest effect of therapy. Now let’s look at the partial η2\\eta^2 values. Because the effect of therapy isn’t all that large, controlling for it doesn’t make much of a difference, so the partial η2\\eta^2 for drug doesn’t increase very much, and we obtain a value of pη2=0.789_p\\eta^2 = 0.789). In contrast, because the effect of drug was very large, controlling for it makes a big difference, and so when we calculate the partial η2\\eta^2 for therapy you can see that it rises to pη2=0.336_p\\eta^2 = 0.336. The question that we have to ask ourselves is, what does these partial η2\\eta^2 values actually mean? The partial η2\\eta^2 for the main effect of Factor A is a statement about a hypothetical experiment in which only Factor A was being varied. So, even though in this experiment we varied both A and B, we can easily imagine an experiment in which only Factor A was varied: the partial η2\\eta^2 statistic tells you how much of the variance in the outcome variable you would expect to see accounted for in that experiment. However, it should be noted that this interpretation – like many things associated with main effects – doesn’t make a lot of sense when there is a large and significant interaction effect. Speaking of interaction effects, here’s what we get when we calculate the effect sizes for the model that includes the interaction term. As you can see, the η2\\eta^2 values for the main effects don’t change, but the partial η2\\eta^2 values do: η2\\eta^2 Partial η2\\eta^2 Drug 0.713 0.841 Therapy 0.096 0.417 Drug ×\\times Therapy 0.056 0.293 13.3 Estimated group means and confidence intervals You will find yourself wanting to report estimates of all the group means based on the results of your ANOVA, as well as confidence intervals associated with them. If the ANOVA that you have run is a saturated model (i.e. contains all possible main effects and all possible interaction effects), then the estimates of the group means are actually identical to the sample means, though the confidence intervals will use a pooled estimate of the standard errors, rather than use a separate one for each group. If you look at the Population parameter estimations output from CogStat, you see that there are confidence intervals given for each combination of our variables (Figure 13.5). Estimated mean mood gain for the placebo group with no therapy was 0.300.30, with a 95% confidence interval from −0.20-0.20 to 0.800.80. However, that is when you calculate the confidence intervals separately for each group. Figure 13.5: Population parameter estimations: estimated group means – reduced model In a saturated model, the estimated mean mood gain for the placebo group with no therapy should still be 0.300.30, but with a 95% confidence interval from 0.0060.006 to 0.5940.594. Table 13.2: Estimated group means and confidence intervals Mean Std. Error 95% Confidence Interval Lower Bound Upper Bound Placebo No therapy 0.300 0.135 0.006 0.594 CBT 0.600 0.135 0.306 0.894 Anxifree No therapy 0.400 0.135 0.106 0.694 CBT 1.033 0.135 0.740 1.327 Joyzepam No therapy 1.467 0.135 1.173 1.760 CBT 1.500 0.135 1.206 1.794 13.4 Post hoc tests Let’s suppose you’ve done your ANOVA, and it turns out that you obtained some significant effects. Because of the fact that the FF-tests are “omnibus” tests that only really test the null hypothesis that there are no differences among groups, obtaining a significant effect doesn’t tell you which groups are different to which other ones We discussed this issue back in Chapter 12, and in that chapter we mentioned an easy solution to run tt-tests for all possible pairs of groups, but CogStat opts for Tukey’s HSD, which is the right call in terms of ANOVA. We would be interested in the following four comparisons: The difference in mood gain for people given Anxifree versus people given the placebo. The difference in mood gain for people given Joyzepam versus people given the placebo. The difference in mood gain for people given Anxifree versus people given Joyzepam. The difference in mood gain for people treated with CBT and people given no therapy. For any one of these comparisons, we’re interested in the true difference between (population) group means. Tukey’s HSD constructs simultaneous confidence intervals for all four of these comparisons. What we mean by 95% “simultaneous” confidence interval is that there is a 95% probability that all of these confidence intervals contain the relevant true value. Moreover, we can use these confidence intervals to calculate an adjusted pp value for any specific comparison. Currently, CogStat does not do a stacked Tukey’s HSD for multi-way ANOVA. We can run the Compare groups function in CogStat but with only drug as grouping variable, as we did in Chapter 12.5. The confidence intervals would be slightly different, though. For the second variable, namely therapy, we don’t get a Tukey’s HSD, as it’s a two-level factor. But what would be quite interesting, is the situation where your model includes interaction terms. The number of pairwise comparisons that we would need to consider starts to increase. As before, we need to consider the three comparisons that are relevant to the main effect of drug and the one comparison that is relevant to the main effect of therapy. But, if we want to consider the possibility of a significant interaction (and try to find the group differences that underpin that significant interaction), we need to include comparisons such as the following: The difference in mood gain for people given Anxifree and treated with CBT, versus people given the placebo and treated with CBT The difference in mood gain for people given Anxifree and given no therapy, versus people given the placebo and given no therapy. etc There are quite a lot of these comparisons that you need to consider. So, the ideal output of Tukey’s HSD would make a lot of pairwise comparisons (19 in total). This is not yet possible in CogStat, but let’s look at what the result would look like if it were. Table 13.3: Tukey’s HSD for a multi-way ANOVA Pair Difference CI 95% (Lower) CI 95% (Upper) pp … - placebo-no_therapy anxifree-no_therapy 0.100 -0.540 0.740 0.994 joyzepam-no_therapy 1.167 0.527 1.807 0.001 placebo-CBT 0.300 -0.340 0.940 0.628 anxifree-CBT 0.733 0.093 1.373 0.022 joyzepam-CBT 1.200 0.560 1.840 0.000 … - anxifree-no_therapy joyzepam-no_therapy 1.067 0.427 1.707 0.001 placebo-CBT 0.200 -0.440 0.840 0.892 anxifree-CBT 0.633 -0.007 1.273 0.053 joyzepam-CBT 1.100 0.460 1.740 0.001 … - joyzepam-no_therapy placebo-CBT -0.867 -1.507 -0.227 0.007 anxifree-CBT -0.433 -1.073 0.207 0.275 joyzepam-CBT 0.033 -0.607 0.673 1.000 … - placebo-CBT anxifree-CBT 0.433 -0.207 1.073 0.275 joyzepam-CBT 0.900 0.260 1.540 0.005 … - anxifree-CBT joyzepam-CBT 0.467 -0.173 1.107 0.214 13.5 Unbalanced designs and types of sums of squares In real life, we’re rarely lucky enough to have perfectly balanced designs. For one reason or another, it’s typical to end up with more observations in some cells than in others. Or, to put it another way, we have an unbalanced design. Unbalanced designs need to be treated with a lot more care than balanced designs, and the statistical theory that underpins them is a lot messier. But we must not ignore this issue, like a lot of stats textbooks (or psychology students) tend to do. The net result of this is that a lot of active researchers in the field don’t actually know that there are several different “types” of unbalanced ANOVAs, and they produce quite different answers. In fact, reading the psychological literature, it seems that most people don’t even realise that their statistical software package is making a whole lot of substantive data analysis decisions on their behalf. CogStat will also make all decisions for you, but when interpreting the results, it’s important to know what the software is doing and what is the underlying statistical theory. As usual, it will help us to work with some data. The coffee.csv file contains a hypothetical data set that produces an unbalanced 3×23 \\times 2 ANOVA. Suppose we were interested in finding out whether or not the tendency of people to babble when they have too much coffee is purely an effect of the coffee itself, or whether there’s some effect of the milk and sugar that people add to the coffee. Suppose we took 18 people, and gave them some coffee to drink. The amount of coffee / caffeine was held constant, and we varied whether or not milk was added: so milk is a binary factor with two levels, \"yes\" and \"no\". We also varied the kind of sugar involved. The coffee might contain \"real\" sugar, or it might contain \"fake\" sugar (i.e., artificial sweetener), or it might contain \"none\" at all, so the sugar variable is a three-level factor. Our outcome variable is a continuous variable that presumably refers to some psychologically sensible measure of the extent to which someone is “babbling”. The details don’t really matter for our purpose. To get a sense of what the data look like, let’s load it into CogStat and run the Compare groups function. Let’s look at the sample properties: Figure 13.6: The coffee data set Across groups, the standard deviation varies from .10.10 to .62.62, which is fairly small relative to the differences in group means. So far, it’s looking like a straightforward factorial ANOVA, just like we did earlier. Unbalanced designs lead us to the somewhat unsettling discovery that there isn’t really any one thing that we might refer to as a standard ANOVA. In fact, it turns out that there are three fundamentally different ways68 in which you might want to run an ANOVA in an unbalanced design. If you have a balanced design, all three versions produce identical results, with the sums of squares, FF-values and so on. All conforming to the formulas from the start of this chapter. However, when your design is unbalanced they don’t give the same answers. Furthermore, they are not all equally appropriate to every situation: some methods will be more appropriate to your situation than others. Given all this, it’s important to understand what the different types of ANOVA are and how they differ from one another. The first kind of ANOVA is conventionally referred to as Type I sum of squares. You can guess what the other two are called. The “sum of squares” part of the name was introduced by the SAS statistical software package, and has become standard nomenclature, but it’s a bit misleading in some ways. The logic for referring to them as different types of sum of squares is that, when you look at the ANOVA tables that they produce, the key difference in the numbers is the SS values. The degrees of freedom don’t change, the MS values are still defined as SS divided by df, etc. However, what the terminology gets wrong is that it hides the reason why the SS values are different from one another. To that end, it’s a lot more helpful to think of the three different kinds of ANOVA as three different hypothesis testing strategies. These different strategies lead to different SS values, to be sure, but it’s the strategy that is the important thing here, not the SS values themselves. Any particular FF-test is best thought of as a comparison between two linear models. So when you’re looking at an ANOVA result, it helps to remember that each of those FF-tests corresponds to a pair of models that are being compared. Of course, this leads naturally to the question of which pair of models is being compared. This is the fundamental difference between ANOVA Types I, II and III: each one corresponds to a different way of choosing the model pairs for the tests. 13.5.1 Type I sum of squares The Type I method is sometimes referred to as the “sequential” sum of squares, because it involves a process of adding terms to the model one at a time. Consider the coffee data, for instance. Suppose we want to run the full 3×23 \\times 2 factorial ANOVA, including interaction terms. The simplest possible model for the data would be one in which neither milk nor sugar is assumed to have any effect on babbling. The only term that would be included in such a model is the intercept. This is our initial null hypothesis. The next simplest model for the data would be one in which only one of the two main effects is included. In the coffee data, there are two different possible choices here, because we could choose to add milk first or to add sugar first. The order actually matters, but for now, let’s just make a choice arbitrarily, and pick sugar. So the second model in our sequence of models is babble ¦ sugar. This comparison forms our hypothesis test of the main effect of sugar. The next step in our model-building exercise it to add the other main effect term, so the next model in our sequence is babble ¦ sugar + milk. This comparison forms our hypothesis test of the main effect of milk. In one sense, this approach is very elegant: the alternative hypothesis from the first test forms the null hypothesis for the second one. It is in this sense that the Type I method is strictly sequential. Every test builds directly on the results of the last one. However, in another sense, it’s very inelegant because there’s a strong asymmetry between the two tests. The test of the main effect of sugar (the first test) completely ignores milk, whereas the test of the main effect of milk (the second test) does take sugar into account. In any case, the fourth model in our sequence is now the full model, babble ¦ sugar + milk + sugar:milk. Table 13.4: Hypotheses for the Type I Sum of Squares for the coffee dataset (sugar first). Model H0H_0 Null hypothesis H1H_1 Alternative hypothesis Main effect Model 1 babble ¦ 1 babble ¦ sugar sugar Model 2 babble ¦ sugar babble ¦ sugar + milk milk Model 3 babble ¦ sugar + milk babble ¦ sugar + milk + sugar×milk sugar×milk When run (in another statistical software package that allows for selection of Type I, II or III), the results of the analysis are the following: Table 13.5: Test of between-subject effects with Type I Sum of Squares for the coffee dataset (sugar first). Source Type I SS df MS FF pp sugar 3.558 2 1.779 6.749 0.011 milk 0.956 1 0.956 3.628 0.081 sugar×milk 5.944 2 2.972 11.277 0.002 The big problem with using Type I sum of squares is the fact that it really does depend on the order in which you enter the variables. Yet, in many situations, the researcher has no reason to prefer one ordering over another. This is presumably the case for our milk and sugar problem. Should we add milk first, or sugar first? It feels exactly as arbitrary as a data analysis question as it does as a coffee-making question. There may in fact be some people with firm opinions about ordering, but it’s hard to imagine a principled answer to the question. Yet, look what happens when we change the ordering: Table 13.6: Hypotheses for the Type I Sum of Squares for the coffee dataset (milk first). Model H0H_0 Null hypothesis H1H_1 Alternative hypothesis Main effect Model 1 babble ¦ 1 babble ¦ milk milk Model 2 babble ¦ milk babble ¦ milk + sugar sugar Model 3 babble ¦ milk + sugar babble ¦ milk + sugar + milk×sugar milk×sugar Table 13.7: Test of between-subject effects with Type I Sum of Squares for the coffee dataset (milk first) Source Type I SS df MS FF pp milk 1.444 1 1.444 5.479 0.037 sugar 3.070 2 1.535 5.824 0.017 milk×sugar 5.944 2 2.972 11.277 0.002 The pp-values for both main effect terms have changed, and fairly dramatically. Among other things, the effect of milk has become significant (though one should avoid drawing any strong conclusions about this, as I’ve mentioned previously). Which of these two ANOVAs should one report? It’s not immediately obvious. When you look at the hypothesis tests that are used to define the “first” main effect and the “second” one, it’s clear that they’re qualitatively different from one another. In our initial example, we saw that the test for the main effect of sugar completely ignores milk, whereas the test of the main effect of milk does take sugar into account. As such, the Type I testing strategy really does treat the first main effect as if it had a kind of theoretical primacy over the second one. There is very rarely if ever any theoretically primacy of this kind that would justify treating any two main effects asymmetrically. The consequence of all this is that Type I tests are very rarely of much interest. 13.5.2 Type III sum of squares Having just finished talking about Type I tests, you might think that the natural thing to do next would be to talk about Type II tests. However, it’s actually a bit more natural to discuss Type III tests (which are simple) before talking about Type II tests (which are trickier). The basic idea behind Type III tests is extremely simple: regardless of which term you’re trying to evaluate, run the FF-test in which the alternative hypothesis corresponds to the full ANOVA model as specified by the user, and the null model just deletes that one term that you’re testing. For instance, in the coffee example, the hypotheses would look like this: Table 13.8: Hypotheses for the Type III Sum of Squares for the coffee dataset. Model H0H_0 Null hypothesis H1H_1 Alternative hypothesis Main effect Model 1 babble ¦ milk + sugar×milk babble ¦ sugar + milk + sugar×milk sugar Model 2 babble ¦ sugar + sugar×milk babble ¦ sugar + milk + sugar×milk milk Model 3 babble ¦ sugar + milk babble ¦ sugar + milk + sugar×milk sugar×milk At first pass, Type III tests seem like a nice idea. Firstly, we’ve removed the asymmetry that caused us to have problems when running Type I tests. And because we’re now treating all terms the same way, the results of the hypothesis tests do not depend on the order in which we specify them. This is definitely a good thing. However, there is a big problem when interpreting the results of the tests, especially for main effect terms. Consider the coffee data. Suppose it turns out that the main effect of milk is not significant according to the Type III tests. What this is telling us is that babble ¦ sugar + sugar×milk is a better model for the data than the full model. But what does that even mean? If the interaction term sugar×milk was also non-significant, we’d be tempted to conclude that the data are telling us that the only thing that matters is sugar. But suppose we have a significant interaction term, but a non-significant main effect of milk. In this case, are we to assume that there really is an “effect of sugar”, an “interaction between milk and sugar”, but no “effect of milk”? That seems crazy. The right answer simply must be that it’s meaningless69 to talk about the main effect if the interaction is significant. In general, this seems to be what most statisticians advise us to do. But if it really is meaningless to talk about non-significant main effects in the presence of a significant interaction, then it’s not at all obvious why Type III tests should allow the null hypothesis to rely on a model that includes the interaction but omits one of the main effects that make it up. When characterised in this fashion, the null hypotheses really don’t make much sense at all. Let’s look at the results: Table 13.9: Test of between-subject effects with Type III Sum of Squares for the coffee dataset. Source Type III SS df MS FF pp milk 1.004 1 1.004 3.810 0.075 sugar 2.132 2 1.066 4.045 0.045 milk×sugar 5.944 2 2.972 11.277 0.002 You’ll notice that CogStat will automatically use Type III Sums of Squares. This is exactly the same result set that we get from CogStat whether we put milk or sugar first in the Compare groups dialog’s Group(s) list. With milk first, we get: Hypothesis tests Testing if the means are the same. At least two grouping variables. Interval variable. &gt;&gt; Choosing factorial ANOVA. Result of multi-way ANOVA: Main effect of milk: F(1, 12) = 3.81, p = .075 Main effect of sugar: F(2, 12) = 4.04, p = .045 Interaction of milk and sugar: F(2, 12) = 11.28, p = .002 With sugar first, we get: Hypothesis tests Testing if the means are the same. At least two grouping variables. Interval variable. &gt;&gt; Choosing factorial ANOVA. Result of multi-way ANOVA: Main effect of sugar: F(2, 12) = 4.04, p = .045 Main effect of milk: F(1, 12) = 3.81, p = .075 Interaction of sugar and milk: F(2, 12) = 11.28, p = .002 13.5.3 Type II sum of squares Type II tests are broadly similar to Type III tests: start with a “full” model, and test a particular term by deleting it from that model. However, Type II tests are based on the marginality principle which states that you should not omit a lower order term from your model if there are any higher order ones that depend on it. So, for instance, if your model contains the interaction A:B (a 2nd order term), then it really ought to contain the main effects A and B (1st order terms). Similarly, if it contains a three-way interaction term A:B:C, then the model must also include the main effects A, B and C as well as the simpler interactions A:B, A:C and B:C. Type III tests routinely violate the marginality principle. For instance, consider the test of the main effect of A in the context of a three-way ANOVA that includes all possible interaction terms. According to Type III tests, our null and alternative models are: Null model: outcome ¦ B + C + A:B + A:C + B:C + A:B:C Alternative model: outcome ¦ A + B + C + A:B + A:C + B:C + A:B:C Notice that the null hypothesis omits A, but includes A:B, A:C and A:B:C as part of the model. This, according to the Type II tests, is not a good choice of null hypothesis. What we should do instead, if we want to test the null hypothesis that A is not relevant to our outcome, is to specify the null hypothesis that is the most complicated model that does not rely on A in any form, even as an interaction. The alternative hypothesis corresponds to this null model plus a main effect term of A. This is a lot closer to what most people would intuitively think of as a “main effect of A”, and it yields the following as our Type II test of the main effect of A.70 Null model: outcome ¦ B + C + B:C Alternative model: outcome ¦ A + B + C + B:C In the context of the two way ANOVA that we’ve been using in the coffee data, the hypothesis tests are even simpler. Table 13.10: Hypotheses for the Type II Sum of Squares for the coffee dataset. Model H0H_0 Null hypothesis H1H_1 Alternative hypothesis Main effect Model 1 babble ¦ milk babble ¦ sugar + milk sugar Model 2 babble ¦ sugar babble ¦ sugar + milk milk Model 3 babble ¦ sugar + milk babble ¦ sugar + milk + sugar×milk sugar×milk The results would be: Table 13.11: Test of between-subject effects with Type II Sum of Squares for the coffee dataset. Source Type II SS df MS FF pp milk 0.956 1 0.956 3.628 0.081 sugar 3.070 2 1.535 5.824 0.017 milk×sugar 5.944 2 2.972 11.277 0.002 Type II tests have some clear advantages over Type I and Type III tests: they don’t depend on the order in which you specify factors (unlike Type I), and they don’t depend on the contrasts71 that you use to specify your factors (unlike Type III). For the moment, you only have Type III available in CogStat, and it is also the default setting in SPPS. It is important, though, that in psychological literature, researchers seldom bother to report which Type of tests they ran. Often they don’t report what software they used either. Make sure you indicate what software you used, and if you’re reporting ANOVA results for unbalanced data, then specify what type of tests you ran. Or, even better, do hypotheses tests that correspond to things you really care about, and then report those! The nice thing about the subscript notation is that generalises nicely: if our experiment had involved a third factor, then we could just add a third subscript. In principle, the notation extends to as many factors as you might care to include.↩︎ Technically, marginalising isn’t quite identical to a regular mean: it’s a weighted average, where you take into account the frequency of the different events that you’re averaging over. However, in a balanced design, all of our cell frequencies are equal by definition, so the two are equivalent.↩︎ This will be a term used and explained in Chapter 14.↩︎ Again, we switched μ\\mu to Y‾\\bar{Y} to indicate that we’re using the sample mean instead of the population mean.↩︎ Implausibly large: the artificiality of this data set is really starting to show!↩︎ Actually, this is a bit of a lie. ANOVAs can vary in other ways besides the ones discussed in this book. For instance, we ignored the difference between fixed-effect models, in which the levels of a factor are “fixed” by the experimenter or the world, and random-effect models, in which the levels are random samples from a larger population of possible levels (this book only covers fixed-effect models). Don’t make the mistake of thinking that this book – or any other one – will tell you “everything you need to know” about statistics, any more than a single book could possibly tell you everything you need to know about psychology, physics or philosophy. Life is too complicated for that to ever be true. This isn’t a cause for despair, though. Most researchers get by with a basic working knowledge of ANOVA that doesn’t go any further than this book does. Keep in mind that this book is only the beginning of a very long story, not the whole story.↩︎ Or, at the very least, rarely of interest.↩︎ Note, of course, that this does depend on the model that the user specified. If original ANOVA model doesn’t contain an interaction term for B:C, then obviously it won’t appear in either the null or the alternative. But that’s true for Types I, II and III. They never include any terms that you didn’t include, but they make different choices about how to construct tests for the ones that you did include. ↩︎ Which is something we might discuss in a future version of this book.↩︎ "],["regression.html", "Chapter 14 Linear regression 14.1 What is a linear regression model? 14.2 Estimating a linear regression model 14.3 Interpreting the results of a linear regression 14.4 Quantifying the fit of the regression model 14.5 Hypothesis tests for regression models 14.6 Model checking 14.7 Summary", " Chapter 14 Linear regression In the past few chapters, we discussed how to test whether your outcome variable’s average value is higher in one group or another. In other words, we have been focusing on differences between group means or their standard deviations. The goal of this chapter is to introduce linear regression, the standard tool that statisticians rely on when analysing the relationship between interval scale predictors and interval scale outcomes. Stripped to its bare essentials, linear regression models are basically a slightly fancier version of the Pearson correlation (Chapter 6). Though as we’ll see, regression models are much more powerful tools. You might have seen already in Chapter 6 that CogStat gives you a linear regression result. You might also recall the charts with the regression line and the residuals. In this chapter, we’ll learn how to interpret these results and how to use them to make predictions. 14.1 What is a linear regression model? Since the basic ideas in regression are closely tied to correlation, we’ll return to the parenthood.csv file that we were using to illustrate how correlations work. In this data set, we were analysing babies’, parents’ and their sleep, and the parents’ grumpiness. Let’s go ahead and use Explore relation of a variable pair function with parentsleep and parentgrump variables. Figure 14.1: Scatterplots of parent sleep and grumpiness You’ll notice that you have two charts (scatterplots) which are very similar: there’s one with and one without a line. The line is called a regression line, and it shows the relationship between two variables. It’s a straight line that goes through the data points. But what does this mean? The formula for a straight line is usually written like this: y=mx+c y = mx + c The two variables are xx and yy, and we have two coefficients, mm and cc. The coefficient mm represents the slope of the line (regression coefficient), and the coefficient cc represents the yy-intercept (intercept) of the line. The regression coefficient is the change in the outcome variable for every unit change in the predictor variable. A slope of mm means that if you increase the xx-value by 1 unit, then the yy-value goes up by mm units; a negative slope means that the yy-value would go down rather than up. The intercept is the value of the outcome variable when the predictor variable is zero (x=0x=0). If YY is the outcome variable (the DV) and XX is the predictor variable (the IV), then the formula that describes our regression is written like this: Yî=b1Xi+b0 \\hat{Y_i} = b_1 X_i + b_0 Looks like the same formula, but there are some extra frilly bits in this version. Let’s make sure we understand them. Firstly, notice that we have XiX_i and YiY_i rather than just plain old XX and YY. This is because we want to remember that we’re dealing with actual data. In this equation, XiX_i is the value of the predictor variable for the iith observation (i.e. the number of hours of sleep on day ii), and YiY_i is the corresponding value of the outcome variable (i.e. the grumpiness on that day). We’re assuming that this formula works for all observations in the data set (i.e. for all ii). Secondly, we also have Ŷi\\hat{Y}_i and not YiY_i. This is because we want to make the distinction between the actual data YiY_i, and the estimate Ŷi\\hat{Y}_i (i.e. the prediction that our regression line is making). Thirdly, we changed the letters used to describe the coefficients from mm and cc to b1b_1 and b0b_0. That’s just the way that statisticians like to refer to the coefficients in a regression model. In any case, b0b_0 always refers to the intercept term, and b1b_1 refers to the slope. We see that the data don’t fall perfectly on the line. In other words, the data YiY_i are not identical to the predictions of the regression model Yî\\hat{Y_i}. Since statisticians love to attach letters, names and numbers to everything, let’s refer to the difference between the model prediction and that actual data point as a residual, and we’ll refer to it as ϵi\\epsilon_i.72 The residuals are defined as: ϵi=Yi−Ŷi \\epsilon_i = Y_i - \\hat{Y}_i which in turn means that we can write down the complete linear regression model as: Yi=b1Xi+b0+ϵi Y_i = b_1 X_i + b_0 + \\epsilon_i 14.2 Estimating a linear regression model Let’s redraw the scatterplots just for this example’s sake adding some dotted lines to show the distance of each data point to the regression line. The length of the lines from the points to the regression line is proportional to the size of the residual. Figure 14.2: Scatterplot outputs from CogStat of parentsleep and parentgrump with and without regression lines When the regression line is good, our residuals (the lengths of the dotted black lines) all look pretty small, but when the regression line is a bad one, the residuals are a lot larger. The “best fitting” regression line is the one that has the smallest residuals. Or better yet: The estimated regression coefficients, b̂0\\hat{b}_0 and b̂1\\hat{b}_1 are those that minimise the sum of the squared residuals, which we could either write as ∑i(Yi−Ŷi)2\\sum_i (Y_i - \\hat{Y}_i)^2 or as ∑iϵi2\\sum_i {\\epsilon_i}^2. Do note that our regression coefficients are estimates (we’re trying to guess the parameters that describe a population), which is why he have the little hats, so that we get b̂0\\hat{b}_0 and b̂1\\hat{b}_1 rather than b0b_0 and b1b_1. Since there’s actually more than one way to estimate a regression model, the more technical name for this estimation process is ordinary least squares (OLS) regression. At this point, we now have a concrete definition for what counts as our “best” choice of regression coefficients, b̂0\\hat{b}_0 and b̂1\\hat{b}_1. The natural question to ask next is, if our optimal regression coefficients are those that minimise the sum squared residuals, how do we find these wonderful numbers? The actual answer to this question is complicated, and it doesn’t help you understand the logic of regression.73 As a result, this time we’re just going to interpret the results. 14.3 Interpreting the results of a linear regression We see that CogStat gave us the formula for our line: Sample properties Linear regression: y = -8.937x + 125.956 The most important thing to be able to understand is how to interpret these coefficients. Let’s start with b̂1\\hat{b}_1, the slope. If we remember the definition of the slope, a regression coefficient of b̂1=−8.937\\hat{b}_1 = -8.937 means that if we increase XiX_i by 1, then we are decreasing YiY_i by 8.937. That is, each additional hour of sleep that the parent gains will improve their mood reducing their grumpiness by 8.937 grumpiness points. What about the intercept? Well, since b̂0\\hat{b}_0 corresponds to “the expected value of YiY_i when XiX_i equals 0”, it’s pretty straightforward. It implies that if the parent gets zero hours of sleep (Xi=0X_i =0) then their grumpiness will go off the scale, to an insane value of (Yi=125.956Y_i = 125.956). Best to be avoided. The next section in the output is a Residual analysis. Figure 14.3: Residual analysis plots from CogStat The residual plot shows a horizontal line at zero. The xx axis shows the independent variable (i.e. parentsleep), and the yy axis shows the residual values. Ideally, the points should be all over the place randomly. If they are not, then there is a problem with the model. This can be due to outliers, or you have a nonlinear relationship between the variables. The residual plot is a good way to check for these problems. Next to the residual plot, you see a sideways histogram. It depicts the distribution of the residuals. Ideally, the residuals should be normally distributed. If they are not, then, again, you have a problem with your model. In our example, the residuals are beautifully random, and their distribution is normal. This is a sign that our model is a good one. Within the Population parameter estimations, you’ll see the estimated regression coefficients with their 95% confidence interval given. The confidence interval is a range of values that we are 95% confident that the true value of the parameter lies within. In this case, we are 95% confident that the true value of the slope is between -9.787 and -8.086, and that the true value of the intercept is between 119.971 and 131.942. You’ll also see a chart depicting the confidence intervals for the regression line. You’ll also note that normality and homoscedasticity are checked. These are two assumptions of linear regression. Normality means that the residuals are normally distributed, which we saw earlier. Homoscedasticity means, very simplistically, that the residuals are equally distributed across the range of the independent variable, so there is no big chunk on one side of the residual plot. Figure 14.4: Regression coefficients 14.3.1 Confidence intervals for the coefficients Like any population parameter, the regression coefficients cannot be estimated with complete precision from a sample of data; that’s part of why we need hypothesis tests. Given this, it’s quite useful to be able to report confidence intervals that capture our uncertainty about the true value of bb. This is especially useful when the research question focuses heavily on an attempt to find out how strongly variable XX is related to variable YY, since in those situations the interest is primarily in the regression weight bb. Fortunately, confidence intervals for the regression weights can be constructed in the usual fashion, CI(b)=b̂±(tcrit×SE(b̂)) \\mbox{CI}(b) = \\hat{b} \\pm \\left( t_{crit} \\times \\mbox{SE}({\\hat{b})} \\right) where SE(b̂)\\mbox{SE}({\\hat{b}}) is the standard error of the regression coefficient, and tcritt_{crit} is the relevant critical value of the appropriate tt distribution. For instance, if it’s a 95% confidence interval that we want, then the critical value is the 97.5th quantile of a tt distribution with N−K−1N-K-1 degrees of freedom. In other words, this is basically the same approach to calculating confidence intervals that we’ve used throughout. As you’ve seen on Figure 14.4, CogStat gives us the confidence intervals for the regression coefficients. Simple enough. 14.4 Quantifying the fit of the regression model So we now know how to estimate the coefficients of a linear regression model. The problem is, we don’t yet know if this regression model is any good. For example, the model claims that every hour of sleep will improve the mood (i.e. reduce grumpiness) by quite a lot, but it might just be rubbish. Remember, the regression model only produces a prediction Ŷi\\hat{Y}_i. But the actual mood is YiY_i. If these two are very close, then the regression model has done a good job. If they are very different, then it has done a bad job. Once again, let’s wrap a little bit of mathematics around this. Firstly, we have the sum of the squared residuals: SSres=∑i(Yi−Ŷi)2=1838.722 \\begin{array}{rcl} \\mbox{SS}_{res} &amp;=&amp; \\sum_i (Y_i - \\hat{Y}_i)^2 \\\\ &amp;=&amp; 1838.722 \\end{array} Secondly, we have the total variability in the outcome variable: SStot=∑i(Yi−Y‾)2=9998.59 \\begin{array}{rcl} \\mbox{SS}_{tot} &amp;=&amp; \\sum_i (Y_i - \\bar{Y})^2 \\\\ &amp;=&amp; 9998.59 \\end{array} Well, it’s a much bigger number than the previous one, so this does suggest that our regression model was making good predictions. But it’s not very interpretable. Perhaps we can fix this. What we’d like to do is to convert these two fairly meaningless numbers into one number. A nice, interpretable number, which for no particular reason we’ll call R2R^2. What we would like is for the value of R2R^2 to be equal to 1 if the regression model makes no errors in predicting the data. In other words, if it turns out that the residual errors are zero – that is, if SSres=0\\mbox{SS}_{res} = 0 – then we expect R2=1R^2 = 1. The formula that provides us with our R2R^2 value is pretty simple to write down, R2=1−SSresSStot=1−1838.7229998.59=0.816 \\begin{array}{rcl} R^2 &amp;=&amp; 1 - \\frac{\\mbox{SS}_{res}}{\\mbox{SS}_{tot}} \\\\ &amp;=&amp; 1 - \\frac{1838.722}{9998.59} \\\\ &amp;=&amp; 0.816 \\end{array} The R2R^2 value, sometimes called the coefficient of determination, has a simple interpretation: it is the proportion of the variance in the outcome variable that can be accounted for by the predictor. So in this case, the fact that we have obtained R2=.816R^2 = .816 means that the predictor (parentsleep) explains 81.6% of the variance in the outcome (parentgrump). The R2R^2 value is not currently calculated and displayed by CogStat, so if you need it, you’ll have to hold on to your hat and read on a bit. At this point, we can revisit our claim that regression, in this very simple form, is basically the same thing as a correlation. Previously, we used the symbol rr to denote a Pearson correlation. Might there be some relationship between the value of the correlation coefficient rr and the R2R^2 value from linear regression? Of course there is! The squared correlation r2r^2 is identical to the R2R^2 value for a linear regression with only a single predictor. So when you scroll down to the end of the result set, you can gather the Pearson correlation rr. You can see a more precise value in the Standardised effect sizes section of the output: Point estimation for Pearson's correlation, r is −0.903-0.903 (with a CI 95% interval of −0.934-0.934 to −0.859-0.859). You’ll also see a two-digit rounded version of it in the Hypothesis tests section: Pearson’s correlation: r(98) = -0.90, p &lt; 0.001 So how about you square the Pearson correlation coefficient r=−0.903r = -0.903? r2=(−0.903)2=0.816 \\begin{array}{rcl} r^2 &amp;=&amp; (-0.903)^2 \\\\ &amp;=&amp; 0.816 \\end{array} Voilà, same number. In other words, running a Pearson correlation is more or less equivalent to running a linear regression model that uses only one predictor variable. 14.4.1 The adjusted R2R^2 value One final thing to point out before moving on. It’s quite common for people to report a slightly different measure of model performance, known as “adjusted R2R^2”. The motivation behind calculating the adjusted R2R^2 value is the observation that adding more predictors into the model will always call the R2R^2 value to increase (or at least not decrease). The adjusted R2R^2 value introduces a slight change to the calculation, as follows. For a regression model with KK predictors, fit to a data set containing NN observations, the adjusted R2R^2 is: adj. R2=1−(SSresSStot×N−1N−K−1) \\mbox{adj. } R^2 = 1 - \\left(\\frac{\\mbox{SS}_{res}}{\\mbox{SS}_{tot}} \\times \\frac{N-1}{N-K-1} \\right) This adjustment is an attempt to take the degrees of freedom into account. The big advantage of the adjusted R2R^2 value is that when you add more predictors to the model, the adjusted R2R^2 value will only increase if the new variables improve the model performance more than you’d expect by chance. The big disadvantage is that the adjusted R2R^2 value can’t be interpreted in the elegant way that R2R^2 can. R2R^2 has a simple interpretation as the proportion of variance in the outcome variable that is explained by the regression model but no equivalent interpretation exists for adjusted R2R^2. An obvious question then, is whether you should report R2R^2 or adjusted R2R^2. This is probably a matter of personal preference. If you care more about interpretability, then R2R^2 is better. If you care more about correcting for bias, then adjusted R2R^2 is probably better. This feature is not currently implemented in CogStat. Just for your reference, the statistic for our example is: adj.R2=0.814adj. R^2 = 0.814. Not too big a difference. 14.5 Hypothesis tests for regression models So far, we’ve talked about what a regression model is, how the coefficients of a regression model are estimated, and how we quantify the performance of the model (the last of these, incidentally, is basically our measure of effect size). The next thing we need to talk about is hypothesis tests for the regression models themselves. There are two different (but related) kinds of hypothesis tests that we need to talk about: those in which we test whether the regression model as a whole is performing significantly better than a null model; and those in which we test whether a particular regression coefficient is significantly different from zero. At this point, you’re probably groaning internally, thinking we’re going to introduce a whole new collection of tests. You’re probably sick of hypothesis tests by now, and don’t want to learn any new ones. Well, you’re lucky, because we can shamelessly reuse the FF-test from Chapter 12 as an overall model test, and the tt-test from Chapter 11 as testing the coefficients. Testing the overall regression model is not implemented in CogStat yet. As you’ve seen in the result set, the Hypothesis tests section will show the Pearson’s correlation coefficient and the Spearman’s rank-order correlation coefficient. To be clear, it is testing particularly the null hypothesis that the correlation coefficient is zero, but not the null hypothesis that the regression model is not performing significantly better than a null model. However, it’s still good to understand these tests, so let’s talk about them briefly. 14.5.1 Testing the model as a whole Okay, suppose you’ve estimated your regression model. The first hypothesis test you might want to try is one in which the null hypothesis is that there is no relationship between the predictors and the outcome, and the alternative hypothesis is that the data are distributed in exactly the way that the regression model predicts. Formally, our “null model” corresponds to the fairly trivial “regression” model in which we include 0 predictors, and only include the intercept term b0b_0 H0:Yi=b0+ϵi H_0: Y_i = b_0 + \\epsilon_i If our regression model has KK predictors, the “alternative model” is described using the usual formula for a multiple regression model: H1:Yi=(∑k=1KbkXik)+b0+ϵi H_1: Y_i = \\left( \\sum_{k=1}^K b_{k} X_{ik} \\right) + b_0 + \\epsilon_i How can we test these two hypotheses against each other? The trick is to understand that just like we did with ANOVA, it’s possible to divide up the total variance SStot\\mbox{SS}_ {tot} into the sum of the residual variance SSres\\mbox{SS}_ {res} and the regression model variance SSmod\\mbox{SS}_ {mod}. Skipping over the technicalities, note that: SSmod=SStot−SSres \\mbox{SS}_{mod} = \\mbox{SS}_{tot} - \\mbox{SS}_{res} And, just like we did with the ANOVA, we can convert the sums of squares in to mean squares by dividing by the degrees of freedom. MSmod=SSmoddfmodMSres=SSresdfres \\begin{array}{rcl} \\mbox{MS}_{mod} &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_{mod} }{df_{mod}} \\\\ \\\\ \\mbox{MS}_{res} &amp;=&amp; \\displaystyle\\frac{\\mbox{SS}_{res} }{df_{res} } \\end{array} So, how many degrees of freedom do we have? As you might expect, the dfdf associated with the model is closely tied to the number of predictors that we’ve included. In fact, it turns out that dfmod=Kdf_{mod} = K. For the residuals, the total degrees of freedom is dfres=N−K−1df_{res} = N - K - 1. Now that we’ve got our mean square values, you’re probably going to be entirely unsurprised (possibly even bored) to discover that we can calculate an FF-statistic like this: F=MSmodMSres F = \\frac{\\mbox{MS}_{mod}}{\\mbox{MS}_{res}} and the degrees of freedom associated with this are KK and N−K−1N-K-1. This FF statistic has exactly the same interpretation as the one we introduced in Chapter 12. Large FF values indicate that the null hypothesis is performing poorly in comparison to the alternative hypothesis. The FF-test for our parentsleep and parentgrump variable pair is: F(1,98)=434.906,p&lt;0.001 F(1, 98) = 434.906, p &lt; 0.001 . 14.5.2 Tests for individual coefficients The FF-test that we’ve just introduced is useful for checking that the model as a whole is performing better than chance. This is important: if your regression model doesn’t produce a significant result for the FF-test then you probably don’t have a very good regression model (or, quite possibly, you don’t have very good data). However, while failing the FF-test is a pretty strong indicator that the model has problems, passing the test (i.e. rejecting the null) doesn’t imply that the model is good! Why is that, you might be wondering? The estimated regression coefficient is quite large for the parentsleep variable (−8.937-8.937)74. Should we run an analysis with the pair of babysleep and parentgrump, we’d notice the linear regression line is: Linear regression: y = -2.742x + 85.782, meaning our regression coefficient is much smaller. Let us combine these two predictors into a single model without CogStat75, and add both babysleep and parentsleep to the model predicting parentgrump, we get the following result: Table 14.1: Model coefficients for the combined model with both predictors at α=0.05\\alpha = 0.05 Predictor Coefficient estimate 95% CI (low) 95% CI (high) babysleep 0.011 -0.527 0.549 parentsleep -8.950 -10.049 -7.852 Intercept 125.966 119.93 132.001 Given that these two variables are absolutely on the same scale (they’re both measured in “hours slept”), this is suspicious. In fact, we should begin to suspect that the amount of sleep that the parent gets is what really only matters in order to predict their grumpiness. Once again, we can reuse a hypothesis test that we discussed earlier, this time the tt-test. The test that we’re interested in has a null hypothesis that the true regression coefficient is zero (b=0b = 0), which is to be tested against the alternative hypothesis that it isn’t (b≠0b \\neq 0). That is: H0:b=0H1:b≠0 \\begin{array}{rl} H_0: &amp; b = 0 \\\\ H_1: &amp; b \\neq 0 \\end{array} How can we test this? Well, if the central limit theorem is kind to us, we might be able to guess that the sampling distribution of b̂\\hat{b}, the estimated regression coefficient, is a normal distribution with mean centred on bb. What that would mean is that if the null hypothesis were true, then the sampling distribution of b̂\\hat{b} has mean zero and unknown standard deviation. Assuming that we can come up with a good estimate for the standard error of the regression coefficient, SE(b̂)\\mbox{SE}({\\hat{b}}), then we’re in luck. That’s exactly the situation for which we introduced the one-sample tt way back in Chapter 11. So let’s define a tt-statistic like this, t=b̂SE(b̂) t = \\frac{\\hat{b}}{\\mbox{SE}({\\hat{b})}} Our degrees of freedom in this case are df=N−K−1df = N- K- 1. Irritatingly, the estimate of the standard error of the regression coefficient, SE(b̂)\\mbox{SE}({\\hat{b}}), is not as easy to calculate as the standard error of the mean that we used for the simpler tt-tests in Chapter 11. In fact, the formula is somewhat ugly, and not terribly helpful to look at. For our purposes, it’s sufficient to point out that the standard error of the estimated regression coefficient depends on both the predictor and outcome variables, and is somewhat sensitive to violations of the homogeneity of variance assumption (discussed shortly). In any case, this tt-statistic can be interpreted in the same way as the tt-statistics that we discussed in Chapter 11. Assuming that you have a two-sided alternative (i.e. you don’t really care if b&gt;0b &gt;0 or b&lt;0b &lt; 0), then it’s the extreme values of tt (i.e. a lot less than zero or a lot greater than zero) that suggest that you should reject the null hypothesis. Table 14.2: Model coefficients for the combined model with both predictors at α=0.05\\alpha = 0.05 with tt-statistics Predictor Coefficient estimate 95% CI (low) 95% CI (high) tt-statistic pp-value babysleep 0.011 -0.527 0.549 0.039 0.969 parentsleep -8.950 -10.049 -7.852 -16.172 &lt;.001 Intercept 125.966 119.93 132.001 41.423 &lt;.001 Let’s run the FF-test for the combined model with the total degrees of freedom is dfres=N−K−1df_{res} = N - K - 1, and we calculate the R2R^2, we get: F(2,97)=215.238,p&lt;0.001 F(2, 97) = 215.238, p &lt; 0.001 R2=0.816 R^2 = 0.816 So in this case, the model performs significantly better than you’d expect by chance (F(2,97)=215.2F(2,97) = 215.2, p&lt;.001p&lt;.001), which isn’t all that surprising: the R2=.816R^2 = .816 value indicate that the regression model accounts for 81.6% of the variability in the outcome measure. However, when we look back up at the tt-tests for each of the individual coefficients, we have pretty strong evidence that the babysleep variable has no significant effect; all the work is being done by the parentsleep variable. Taken together, these results suggest that babysleep &gt; parentgrump is actually the wrong model for the data: you’d probably be better off dropping the babysleep predictor entirely. In other words, the parentsleep &gt; parentgrump model that we started with is the better model. 14.5.3 Calculating standardised regression coefficients One more thing that you might want to do is to calculate “standardised” regression coefficients, often denoted β\\beta. The rationale behind standardised coefficients goes like this. In a lot of situations, your variables are on fundamentally different scales. E.g. a 7-point Likert scale compared to a 5-point one; IQ scores compared to years of education; or, in our case, hours of sleep compared to grumpiness. In these situations, it’s not really fair to compare the regression coefficients for the two variables. Yet, there are situations where you simply must make comparisons between different coefficients. Specifically, you might want some kind of standard measure of which predictors have the strongest relationship to the outcome. This is what standardised coefficients aim to do. The basic idea is quite simple: the standardised coefficients are the coefficients that you would have obtained if you’d converted all the variables to zz-scores before running the regression. The idea here is that, by converting all the predictors to zz-scores, they all go into the regression on the same scale, thereby removing the problem of having variables on different scales. Regardless of what the original variables were, a β\\beta value of 1 means that an increase in the predictor of 1 standard deviation will produce a corresponding 1 standard deviation increase in the outcome variable. Therefore, if variable A has a larger absolute value of β\\beta than variable B, it is deemed to have a stronger relationship with the outcome. Or at least that’s the idea: it’s worth being a little cautious here, since this does rely very heavily on the assumption that “a 1 standard deviation change” is fundamentally the same kind of thing for all variables. It’s not always obvious that this is true. Leaving aside the interpretation issues, let’s look at how it’s calculated. What you could do is standardise all the variables yourself and then run a regression76. The β\\beta coefficient for a predictor XX and outcome YY has a very simple formula, namely βX=bX×σXσY \\beta_X = b_X \\times \\frac{\\sigma_X}{\\sigma_Y} where σX\\sigma_X is the standard deviation of the predictor, and σY\\sigma_Y is the standard deviation of the outcome variable YY. What does this mean in our original example (i.e. parentsleep and parentgrump)? To calculate this manually with CogStat, you can use Explore variable function to get the Standard deviation of both the predictor and outcome variables: (parentsleep is XX) σX=1.011\\sigma_X = 1.011, and (parentgrump is YY) σY=10.0\\sigma_Y = 10.0. Then you can use the Explore relation of variable pair function (which we’ve been using in this Chapter) to get the bXb_X value. In this case, it was −8.937-8.937. Let’s put these figures in the formula: βX=bX×σXσY=−8.937×1.01110=−0.903 \\begin{array}{rcl} \\beta_X &amp;=&amp; b_X \\times \\frac{\\sigma_X}{\\sigma_Y} \\\\ &amp;=&amp; -8.937 \\times \\frac{1.011}{10} \\\\ &amp;=&amp; -0.903 \\end{array} To calculate it for our combined model manually, we can use the same, just with different figures (see Table 14.2): bXb_X for parentsleep is −8.950-8.950 and bXb_X for babysleep is 0.0110.011. We know the σ\\sigma values for parentsleep and parentgrump, so we only need to calculate the σ\\sigma value for babysleep using the Explore variable and getting the Standard deviation. In this case, it’s 2.0642.064. So putting these in the formula, we get the followings: parentsleep: βX=bX×σXσY=−8.950×1.01110=−0.905 \\begin{array}{rcl} \\beta_X &amp;=&amp; b_X \\times \\frac{\\sigma_X}{\\sigma_Y} \\\\ &amp;=&amp; -8.950 \\times \\frac{1.011}{10} \\\\ &amp;=&amp; -0.905 \\end{array} babysleep: βX=bX×σXσY=0.011×2.06410=0.002 \\begin{array}{rcl} \\beta_X &amp;=&amp; b_X \\times \\frac{\\sigma_X}{\\sigma_Y} \\\\ &amp;=&amp; 0.011 \\times \\frac{2.064}{10} \\\\ &amp;=&amp; 0.002 \\end{array} Table 14.3: Model coefficients (both estimate and standardised estimate) for the combined model with both predictors at α=0.05\\alpha = 0.05 with tt-statistics Predictor Coefficient estimate Standardised coefficient (β\\beta) 95% CI (low) 95% CI (high) tt-statistic pp-value babysleep 0.011 0.002 -0.527 0.549 0.039 0.969 parentsleep -8.950 -0.905 -10.049 -7.852 -16.172 &lt;.001 Intercept 125.966 – 119.93 132.001 41.423 &lt;.001 This clearly shows that the parentsleep variable has a much stronger effect than the babysleep variable. Also, let’s not forget that this β\\beta coefficient can also have a confidence interval, which we are not going to cover now. This, however, is a perfect example of a situation where it would probably make sense to use the original coefficients bb rather than the standardised coefficients β\\beta. After all, the parent’s sleep and the baby’s sleep are already on the same scale: number of hours slept. Why complicate matters by converting these to zz-scores? 14.6 Model checking The main focus of this section is regression diagnostics77, a term that refers to the art of checking that the assumptions of your regression model have been met, figuring out how to fix the model if the assumptions are violated, and generally to check that nothing “funny” is going on. If done manually, and not with an automatic statistics software, it’s easy to get lost in all the details of checking this thing or that thing, and it’s quite exhausting to try to remember what all the different things are. This has the very nasty side effect that a lot of people get frustrated when trying to learn all the tools, so instead they decide not to do any model checking. This is a bit of a worry! In this section, we discuss several different things you can theoretically do to check that your regression model is doing what it’s supposed to. 14.6.1 Three kinds of residuals The majority of regression diagnostics revolve around looking at the residuals. In particular, the following three kinds of residual are referred to in this section: “ordinary residuals” (which in some cases is identical to “Pearson residual”), “standardised residuals”, and “Studentised residuals”. The first and simplest kind of residuals that we care about are ordinary residuals. These are the actual, raw residuals we’ve been talking about throughout this chapter. The ordinary residual is just the difference between the fitted value Ŷi\\hat{Y}_i and the observed value YiY_i. We’ve been using the notation ϵi\\epsilon_i to refer to the ii-th ordinary residual. With this in mind, we have a very simple equation: ϵi=Yi−Ŷi \\epsilon_i = Y_i - \\hat{Y}_i One drawback to using ordinary residuals is that they’re always on a different scale, depending on what the outcome variable is and how good the regression model is. The ordinary residuals will have mean 0; but the variance is different for every regression. In a lot of contexts, especially where you’re only interested in the pattern of the residuals and not their actual values, it’s convenient to estimate the standardised residuals, which are normalised in such a way as to have standard deviation 1. The way we calculate these is, we divide the ordinary residual by an estimate of the (population) standard deviation of these residuals. For technical reasons, the formula for this is: ϵi′=ϵiσ̂1−hi \\epsilon_{i}^\\prime = \\frac{\\epsilon_i}{\\hat{\\sigma} \\sqrt{1-h_i}} where σ̂\\hat\\sigma in this context is the estimated population standard deviation of the ordinary residuals, and hih_i is the “hat value” of the iith observation. For now, it’s enough to interpret the standardised residuals as if we’d converted the ordinary residuals to zz-scores. In fact, that is more or less the truth, it’s just that we’re being a bit fancier. The third kind of residuals are Studentised residuals, and they’re even fancier than standardised residuals. Again, the idea is to take the ordinary residual and divide it by some quantity in order to estimate some standardised notion of the residual, but the formula for doing the calculations this time is subtly different: ϵi*=ϵiσ̂(−i)1−hi \\epsilon_{i}^* = \\frac{\\epsilon_i}{\\hat{\\sigma}_{(-i)} \\sqrt{1-h_i}} Notice that our estimate of the standard deviation here is written σ̂(−i)\\hat{\\sigma}_{(-i)}. This corresponds to the estimate of the residual standard deviation that you would have obtained, if you just deleted the iith observation from the data set. This sounds like the sort of thing that would be a nightmare to calculate, since it seems to be saying that you have to run NN new regression models (even a modern computer might grumble a bit at that, especially if you’ve got a large data set). Fortunately, this standard deviation estimate is actually given by the following equation: σ̂(−i)=σ̂N−K−1−ϵi′2N−K−2 \\hat\\sigma_{(-i)} = \\hat{\\sigma} \\ \\sqrt{\\frac{N-K-1 - {\\epsilon_{i}^\\prime}^2}{N-K-2}} It’s always nice to know how to actually get hold of these things yourself in case you ever need to do something non-standard. 14.6.2 Three kinds of anomalous data One danger that you can run into with linear regression models is that your analysis might be disproportionately sensitive to a smallish number of “unusual” or “anomalous” observations. In the context of linear regression, there are three conceptually distinct ways in which an observation might be called “anomalous”. All three are interesting, but they have rather different implications for your analysis. The first kind of unusual observation is an outlier. The definition of an outlier (in this context) is an observation that is very different from what the regression model predicts. An example is shown in Figure 14.5. In practice, we operationalise this concept by saying that an outlier is an observation that has a very large Studentised residual, ϵi*\\epsilon_i^*. Outliers are interesting: a big outlier might correspond to junk data. E.g. the variables might have been entered incorrectly, or some other defect may be detectable. Note that you shouldn’t throw an observation away just because it’s an outlier. But the fact that it’s an outlier is often a cue to look more closely at that case, and try to find out why it’s so different. Figure 14.5: An illustration of outliers. The dotted lines plot the regression line that would have been estimated without the anomalous observation included, and the corresponding residual (i.e. the Studentised residual). The solid line shows the regression line with the anomalous observation included. The outlier has an unusual value on the outcome (y axis location) but not the predictor (x axis location), and lies a long way from the regression line. The second way in which an observation can be unusual is if it has high leverage: this happens when the observation is very different from all the other observations. This doesn’t necessarily have to correspond to a large residual: if the observation happens to be unusual on all variables in precisely the same way, it can actually lie very close to the regression line. An example of this is shown in Figure 14.6. Figure 14.6: An illustration of high leverage points. The anomalous observation in this case is unusual both in terms of the predictor (x axis) and the outcome (y axis), but this unusualness is highly consistent with the pattern of correlations that exists among the other observations; as a consequence, the observation falls very close to the regression line and does not distort it. The leverage of an observation is operationalised in terms of its hat value, usually written hih_i. The formula for the hat value is rather complicated78 but its interpretation is not: hih_i is a measure of the extent to which the ii-th observation is “in control” of where the regression line ends up going. In general, if an observation lies far away from the other ones in terms of the predictor variables, it will have a large hat value (as a rough guide, high leverage is when the hat value is more than 2-3 times the average; and note that the sum of the hat values is constrained to be equal to K+1K+1). High leverage points are also worth looking at in more detail, but they’re much less likely to be a cause for concern unless they are also outliers. This brings us to our third measure of unusualness, the influence of an observation. A high influence observation is an outlier that has high leverage. That is, it is an observation that is very different to all the other ones in some respect, and also lies a long way from the regression line. This is illustrated in Figure 14.7. Notice the contrast to the previous two figures: outliers don’t move the regression line much, and neither do high leverage points. But an outlier that has high leverage will have a big effect on the regression line. Figure 14.7: An illustration of high influence points. In this case, the anomalous observation is highly unusual on the predictor variable (x axis), and falls a long way from the regression line. As a consequence, the regression line is highly distorted, even though (in this case) the anomalous observation is entirely typical in terms of the outcome variable (y axis). That’s why we call these points high-influence; and it’s why they’re the biggest worry. We operationalise influence in terms of a measure known as Cook’s distance, Di=ϵi*2K+1×hi1−hi D_i = \\frac{{\\epsilon_i^*}^2 }{K+1} \\times \\frac{h_i}{1-h_i} Notice that this is a multiplication of something that measures the outlier-ness of the observation (the bit on the left), and something that measures the leverage of the observation (the bit on the right). In other words, in order to have a large Cook’s distance, an observation must be a fairly substantial outlier and have high leverage. Some statistics software will provide you with this measure, but it is not available in CogStat yet. It is good to know about it, though. As a rough guide, Cook’s distance greater than 1 is often considered large, though a quick scan of the internet and a few papers suggests that 4/N4/N has also been suggested as a possible rule of thumb. An obvious question to ask next is, if you do have large values of Cook’s distance, what should you do? As always, there’s no hard-and-fast rules. Probably the first thing to do is to run the regression with that point excluded (i.e. removing it from the source data) and see what happens to the model performance and to the regression coefficients. If they really are substantially different, it’s time to start digging into your data set and your notes that you no doubt were scribbling as your ran your study; try to figure out why the point is so different. If you start to become convinced that this one data point is badly distorting your results, you might consider excluding it, but that’s less than ideal unless you have a solid explanation for why this particular case is qualitatively different from the others and therefore deserves to be handled separately. 14.6.3 Checking the normality of the residuals Like many of the statistical tools we’ve discussed in this book, regression models rely on a normality assumption. In this case, we assume that the residuals are normally distributed. It never hurts to draw a histogram. You’ve seen an example of this very early on in this Chapter in Figure 14.3. If the residuals are normally distributed, you should see a roughly bell-shaped curve in the right-hand chart. CogStat will automatically test for normality as usual. The test used by CogStat is not the Shapiro-Wilk test but the Henze-Zirkler test of multivariate normality, but it also provides us with a WW-value and pp-value. And the rule is, again, if the pp-value is less than 0.05, we can reject the null hypothesis that the residuals are normally distributed, meaning, our data set violates the assumption of normality. In such a case, CogStat will specifically call out that the confidence intervals for the regression coefficients and the intercept might be biased. Also, only the Spearman’s rank-order correlation will be run as part of the Hypothesis tests, because Pearson’s correlation assumes normality. 14.6.4 Checking the homoscedasticity of the residuals The regression models that we’ve talked about all make a homogeneity of variance assumption: the variance of the residuals is assumed to be constant. Again, you might recall from Figure 14.3 that if on the left chart, the residuals are leaning towards one of the sides and are not spread more or less evenly, this is a sign that the variance is not constant, hence the homoscedasticity assumption is violated. CogStat uses two tests to determine whether the homoscedasticity assumption is violated (meaning the data is heteroscedatic): Koenker’s studentised score test is a studentised version of Breuschand Pagan’s score test, and is robust when long-tailed errors or unusual observations are present (Lyon &amp; Tsai, 1996); White’s test tests for bias due to heteroskedasticity, but it’s generally advised to use Koenker’s test instead (Lyon &amp; Tsai, 1996). Both tests will give you a test statistic (LMLM79) and a pp-value. If either test’s pp-value is less than 0.05, we can reject the null hypothesis that the residuals are homoscedastic, in which case CogStat will specifically call out that the confidence intervals for the regression coefficients and the intercept might be biased, and will run, again, only the Spearman’s rank-order correlation as part of the Hypothesis tests. 14.7 Summary The linear regression model relies on several assumptions: Normality. Like half the models in statistics, standard linear regression relies on an assumption of normality. Specifically, it assumes that the residuals are normally distributed. It’s actually okay if the predictors XX and the outcome YY are non-normal, so long as the residuals ϵ\\epsilon are normal. See Section 14.6.3. Linearity. A pretty fundamental assumption of the linear regression model is that relationship between XX and YY actually be linear! Regardless of whether it’s a simple regression or a multiple regression, we assume that the relatiships involved are linear. Homogeneity of variance. Strictly speaking, the regression model assumes that each residual ϵi\\epsilon_i is generated from a normal distribution with mean 0, and (more importantly for the current purposes) with a standard deviation σ\\sigma that is the same for every single residual. In practice, it’s impossible to test the assumption that every residual is identically distributed. Instead, what we care about is that the standard deviation of the residual is the same for all values of Ŷ\\hat{Y}, and (if we’re being especially paranoid) all values of every predictor XX in the model. See Section 14.6.4. Residuals are independent of each other. This is really just a “catch all” assumption, to the effect that “there’s nothing else funny going on in the residuals”. If there is something weird (e.g., the residuals all depend heavily on some other unmeasured variable) going on, it might screw things up. No “bad” outliers. Again, not actually a technical assumption of the model (or rather, it’s sort of implied by all the others), but there is an implicit assumption that your regression model isn’t being too strongly influenced by one or two anomalous data points; since this raises questions about the adequacy of the model, and the trustworthiness of the data in some cases. See Section 14.6.2. References Fox, J., &amp; Weisberg, S. (2011). An R companion to applied regression (2nd ed.). Sage. Lyon, J. D., &amp; Tsai, C.-L. (1996). A comparison of tests for heteroscedasticity. Journal of the Royal Statistical Society: Series D (The Statistician), 45(3), 337–349. The ϵ\\epsilon symbol is the Greek letter epsilon. It’s traditional to use ϵi\\epsilon_i or eie_i to denote a residual.↩︎ On the off chance that someone reading this is a proper kung fu master of linear algebra, it will help you to know that the solution to the estimation problem turns out to be b̂=(XTX)−1XTy\\hat{b} = (X^TX)^{-1} X^T y, where b̂\\hat{b} is a vector containing the estimated regression coefficients, XX is the “design matrix” that contains the predictor variables (plus an additional column containing all ones; strictly XX is a matrix of the regressors.), and yy is a vector containing the outcome variable. For everyone else, this isn’t exactly helpful, and can be downright scary. However, since quite a few things in linear regression can be written in linear algebra terms, you’ll see a bunch of footnotes like this one in this chapter. If you can follow the maths in them, great. If not, ignore it.↩︎ If you recall our result was: Linear regression: y = -8.937x + 125.95↩︎ This feature is not available in CogStat at the moment of writing, but this section will definitely be updated when it is.↩︎ Which is what you have to do now, as this is not implemented in CogStat yet.↩︎ Some parts of this chapter was influenced by Fox &amp; Weisberg (2011).↩︎ For the linear algebra fanatics: the “hat matrix” is defined to be that matrix HH that converts the vector of observed values yy into a vector of fitted values ŷ\\hat{y}, such that ŷ=Hy\\hat{y} = H y. The name comes from the fact that this is the matrix that “puts a hat on yy”. The hat value of the ii-th observation is the ii-th diagonal element of this matrix (so technically: hiih_{ii} rather than hih_{i}). Here’s how it’s calculated: H=X(XTX)−1XTH = X(X^TX)^{-1} X^T. Pretty, isn’t it?↩︎ Lagrange Multiplier – which is beyond this textbook’s scope to cover.↩︎ "],["bayes.html", "Chapter 15 Introduction to Bayesian statistics 15.1 Priors: what you believed before 15.2 Likelihoods: theories about the data 15.3 The joint probability of data and hypothesis 15.4 Updating beliefs using Bayes’ rule", " Chapter 15 Introduction to Bayesian statistics In our reasonings concerning matter of fact, there are all imaginable degrees of assurance, from the highest certainty to the lowest species of moral evidence. A wise man, therefore, proportions his belief to the evidence. – David Hume80. The ideas so far in this book describe inferential statistics from the frequentist perspective. Almost every textbook given to undergraduate psychology students presents the opinions of the frequentist statistician as the theory of inferential statistics, the one true way to do things. The frequentist view of statistics dominated the academic field for most of the 20th century, and this dominance is even more extreme among applied scientists. It was and is the current practice among psychologists to use frequentist methods. Because frequentist methods are ubiquitous in scientific papers, every statistics student needs to understand them; otherwise, they will be unable to make sense of what those papers are saying! Unfortunately, the current practice in psychology is often misguided, and the reliance on frequentist methods is partly to blame. In this chapter, we will introduce Bayesian statistics, an approach that – some, including Danielle, think – is generally superior to the orthodox approach. From a Bayesian perspective, statistical inference is about belief revision. We start with a set of candidate hypotheses hh about the world. We don’t know which of these hypotheses is true, but we do have some beliefs about which hypotheses are plausible and which are not. When we observe the data dd, we have to revise those beliefs. If the data are consistent with a hypothesis, our belief in that hypothesis is strengthened. Should the data be inconsistent with the hypothesis, our belief is weakened. Consider the following reasoning problem: Attila is carrying an umbrella. Do you think it will rain today? In this problem, we have presented a single piece of data (d=d = Attila is carrying the umbrella), and we’re asking you to tell us your beliefs about whether it’s raining. You have two possible hypotheses, hh: either it rains today or it does not. How should you solve this problem? 15.1 Priors: what you believed before Firstly, you must ignore everything about the umbrella and write down your pre-existing beliefs about rain. This is important: if you want to be honest about how your beliefs have been revised in the light of new evidence, then you must say something about what you believed before those data appeared! So, what might you believe about whether it will rain today? You probably know that Attila lives in Budapest and that the weather here is mild and relatively dry. In fact, you might have decided to take a quick look on Wikipedia81 and discovered that Budapest gets an average of 7.3 days of rain across the 31 days of January, let’s say. Without knowing anything else, you might conclude that the probability of January rain in Budapest is about (7.331=\\frac{7.3}{31}=) 23.5%, and the probability of a dry day is ($1 - 0.235 = $)76.5%. If this is what you believe about Budapest rainfall, then what we have written here is your prior distribution, written P(h)P(h): Hypothesis hh Degree of Belief P(h)P(h) Rainy day 0.235 Dry day 0.765 15.2 Likelihoods: theories about the data To solve the reasoning problem, you need a theory about Attila’s behaviour. When does he carry an umbrella? You might guess that he only carries umbrellas on rainy days. But he’s also a busy professor. Might he be forgetful? Let’s suppose82 that on rainy days he remembers his umbrella about 30% of the time. Let’s say that on dry days, he’s only about 5% likely to be carrying an umbrella. So you might write out a little table like this: Hypothesis hh Umbrella No umbrella Rainy day 0.30 0.70 Dry day 0.05 0.95 It’s important to remember that each cell in this table describes your beliefs about what data dd will be observed, given the truth of a particular hypothesis hh. This “conditional probability” is written P(d|h)P(d|h), which you can read as “the probability of dd given hh”. In Bayesian statistics, this is referred to as likelihood of data dd given hypothesis hh.83 15.3 The joint probability of data and hypothesis At this point, all the elements are in place. Having written down the priors and the likelihood, you have all the information you need to do Bayesian reasoning. The question now becomes, how do we use this information? Let’s start out with one of the rules of probability theory. The rule talks about the probability that two things are true. In our example, you might want to calculate the probability that today is rainy (i.e. hypothesis hh is true) and that Attila is carrying an umbrella (i.e. data dd is observed). The joint probability of the hypothesis and the data is written P(d,h)P(d,h), and you can calculate it by multiplying the prior P(h)P(h) by the likelihood P(d|h)P(d|h). Mathematically, we say that: P(d,h)=P(d|h)P(h) P(d,h) = P(d|h) P(h) So, what is the probability that today is a rainy day and that he carries an umbrella? The prior tells us that the probability of a rainy day is 23.5%, and the likelihood tells us that the probability of Attila carrying an umbrella on a rainy day is 30%. So the probability that both of these things are true is calculated by multiplying the two: P(rainy,umbrella)=P(umbrella|rainy)×P(rainy)=0.30×0.235=0.0705 \\begin{array}{rcl} P(\\mbox{rainy}, \\mbox{umbrella}) &amp; = &amp; P(\\mbox{umbrella} | \\mbox{rainy}) \\times P(\\mbox{rainy}) \\\\ &amp; = &amp; 0.30 \\times 0.235 \\\\ &amp; = &amp; 0.0705 \\end{array} In other words, before being told anything about what actually happened, you think there is a 7.1% probability that today will be a rainy day and that Attila will remember to bring an umbrella. However, there are, of course, four possible things that could happen, right? So let’s repeat the exercise for all four. If we do that, we end up with the following table: Day Umbrella No umbrella Total Rainy 0.0705 0.1645 0.2350 Dry 0.0383 0.7268 0.7650 Total 0.1088 0.8912 1.0000 This is a handy table, so it’s worth taking a moment to think about what all these numbers are telling us. First, notice that the row sums aren’t telling us anything new at all. For example, the first row tells us that if we ignore all this umbrella business, the chance that today will be a rainy day is 23.5%. That’s not surprising, of course: that’s our prior. The important thing isn’t the number itself: rather, the important thing is that it gives us some confidence that our calculations are sensible! Now take a look at the column sums, and notice that they tell us something that we haven’t explicitly stated yet. In the same way that the row sums tell us the probability of rain, the column sums tell us the probability of Attila carrying an umbrella. Specifically, the first column tells us that the probability of him carrying an umbrella is, on average, 10.88%, regardless of the weather. Finally, notice that when we sum across all four logically-possible events, everything adds up to 1. In other words, what we have written down is a proper probability distribution defined over all possible combinations of data and hypothesis. Now, because this table is so useful, let’s make sure you understand what all the elements correspond to and how they are written: Day Umbrella No umbrella Total Rainy PP(Umbrella, Rainy) PP(No umbrella, Rainy) PP(Rainy) Dry PP(Umbrella, Dry) PP(No umbrella, Dry) PP(Dry) Total PP(Umbrella) PP(No umbrella) Finally, let’s use “proper” statistical notation. So we’ll let d1d_1 refer to the possibility that you observe Attila carrying an umbrella, and d2d_2 refers to you observing him not carrying one. Similarly, h1h_1 is your hypothesis that today is rainy, and h2h_2 is the hypothesis that it is not. Using this notation, the table looks like this: d1d_1 d2d_2 h1h_1 P(h1,d1)P(h_1, d_1) P(h1,d2)P(h_1, d_2) P(h1)P(h_1) h2h_2 P(h2,d1)P(h_2, d_1) P(h2,d2)P(h_2, d_2) P(h2)P(h_2) P(d1)P(d_1) P(d2)P(d_2) 15.4 Updating beliefs using Bayes’ rule The table we laid out in the last section is a powerful tool for solving the rainy day problem because it considers all four logical possibilities and states exactly how confident you are in each of them before being given any data. It is now time to consider what happens to our beliefs when we are actually given the data. In the rainy day problem, you are told that Attila really is carrying an umbrella. This is something of a surprising event: according to our table, the probability of him carrying an umbrella is only 10.88%. But that makes sense, right? No matter how unlikely you thought it was, you must now adjust your beliefs to accommodate the fact that you now know that he has an umbrella. To reflect this new knowledge, our revised table must have the following numbers: Umbrella No umbrella Rainy day 0 Dry day 0 Total 1 0 In other words, the facts have eliminated any possibility of “no umbrella”, so we have to put zeros into any cell in the table that implies that. Also, you know for a fact that he is carrying an umbrella, so the column sum on the left must be 1 to correctly describe the fact that P(umbrella)=1P(\\mbox{umbrella})=1. What two numbers should we put in the empty cells? Again, let’s not worry about the maths and instead use our intuitions. We worked out that the joint probability of “rain and umbrella” was 7.05%, and the joint probability of “dry and umbrella” was 3.83%. But notice that both of these possibilities are consistent with the fact that he actually is carrying an umbrella. So what we expect to see in our final table are some numbers that preserve the fact that “rain and umbrella” is more plausible than “dry and umbrella” while still ensuring that the numbers in the table add up. Something like this, perhaps? Umbrella No umbrella Rainy day 0.648 0 Dry day 0.352 0 Total 1.000 0 This table infers that, after being told that Attila is carrying an umbrella, you believe that there is a 64.8% chance that today will be a rainy day and a 35.2% chance that it will not. That is the answer to our problem! The posterior probability of rain P(h|d)P(h|d) given that Attila is carrying an umbrella is 64.8%. How did we calculate these numbers? You can probably guess: take the 0.0705 probability of “rain and umbrella” and divide it by the 0.1088 chance of “umbrella”. This produces a table that satisfies our need to have everything sum to 1 and our need not to interfere with the relative plausibility of the two events that are actually consistent with the data. To say the same thing using fancy statistical jargon: divide the joint probability of the hypothesis and the data P(d,h)P(d,h) by the marginal probability of the data P(d)P(d), and this is what gives us the posterior probability of the hypothesis given that we know the data have been observed. To write this as an equation:84 P(h|d)=P(d,h)P(d) P(h | d) = \\frac{P(d,h)}{P(d)} Remember that the joint probability P(d,h)P(d,h) is calculated by multiplying the prior P(h)P(h) by the likelihood P(d|h)P(d|h). In real life, the things we actually know how to write down are the priors and the likelihood, so let us substitute those back into the equation. This gives us the following formula for the posterior probability: P(h|d)=P(d|h)P(h)P(d) P(h | d) = \\frac{P(d|h) P(h)}{P(d)} And this formula is known as Bayes’ rule. It describes how a learner starts out with prior beliefs about the plausibility of different hypotheses and tells you how those beliefs should be revised in the face of data. In the Bayesian paradigm, all statistical inference flows from this one simple rule. http://en.wikiquote.org/wiki/David_Hume↩︎ https://en.wikipedia.org/wiki/Climate_of_Budapest↩︎ I’m confident he is anything but forgetful. At least, that is how I know him. I hope he won’t mind this little easter egg of an example. – Robert↩︎ Some statisticians would object to using the word “likelihood” here. The problem is that the word “likelihood” has a very specific meaning in frequentist statistics, and it’s not quite the same as what it means in Bayesian statistics. Bayesians didn’t originally have any agreed-upon name for the likelihood, and so it became common practice for people to use the frequentist terminology. This wouldn’t have been a problem, except for the fact that the way that Bayesians use the word turns out to be quite different to the way frequentists do. This isn’t the place for yet another lengthy history lesson, but to put it crudely: when a Bayesian says “a likelihood function” they’re usually referring to one of the rows of the table. When a frequentist says the same thing, they’re referring to the same table, but to them, “a likelihood function” almost always refers to one of the columns. This distinction matters in some contexts, but it’s not important for our purposes.↩︎ You might notice that this equation is actually a restatement of the same basic rule from the start of the last section. If you multiply both sides of the equation by P(d)P(d), then you get P(d)P(h|d)=P(d,h)P(d) P(h| d) = P(d,h), which is the rule for how joint probabilities are calculated.↩︎ "],["bayesianhypothesistests.html", "Chapter 16 Bayesian hypothesis tests 16.1 The Bayes factor 16.2 Interpreting Bayes factors 16.3 Bayesian statistics in CogStat", " Chapter 16 Bayesian hypothesis tests Chapter 9 describes the orthodox approach to hypothesis testing. It took an entire chapter to describe because null hypothesis testing is a very elaborate contraption that people find very hard to make sense of. In contrast, the Bayesian approach to hypothesis testing is straightforward. Let us pick a setting that is closely analogous to the orthodox scenario. We want to compare two hypotheses: a null hypothesis h0h_0 and an alternative hypothesis h1h_1. Before running the experiment, we have some beliefs (P(h)P(h)) about which hypotheses are true. We run an experiment and obtain data dd. Unlike frequentist statistics, Bayesian statistics does allow talking about the probability that the null hypothesis is true. Better yet, it allows us to calculate the posterior probability of the null hypothesis, using Bayes’ rule: P(h0|d)=P(d|h0)P(h0)P(d) P(h_0 | d) = \\frac{P(d|h_0) P(h_0)}{P(d)} This formula tells us exactly how much belief we should have in the null hypothesis after observing the data dd. Similarly, we can work out how much belief to place in the alternative hypothesis using the same equation. All we do is change the subscript: P(h1|d)=P(d|h1)P(h1)P(d) P(h_1 | d) = \\frac{P(d|h_1) P(h_1)}{P(d)} 16.1 The Bayes factor In practice, most Bayesian data analysts tend not to talk about the raw posterior probabilities P(h0|d)P(h_0|d) and P(h1|d)P(h_1|d). Instead, we tend to talk in terms of the posterior odds ratio. Think of it like betting. Suppose, for instance, the posterior probability of the null hypothesis is 25%, and the posterior probability of the alternative is 75%. The alternative hypothesis is three times as probable as the null, so we say that the odds are 3:1 in favour of the alternative. Mathematically, all we have to do to calculate the posterior odds is divide one posterior probability by the other: P(h1|d)P(h0|d)=0.750.25=3 \\frac{P(h_1 | d)}{P(h_0 | d)} = \\frac{0.75}{0.25} = 3 Or, to write the same thing in terms of the equations above: P(h1|d)P(h0|d)=P(d|h1)P(d|h0)×P(h1)P(h0) \\frac{P(h_1 | d)}{P(h_0 | d)} = \\frac{P(d|h_1)}{P(d|h_0)} \\times \\frac{P(h_1)}{P(h_0)} This equation is worth expanding on. There are three different terms here that you should know. On the left-hand side, we have the posterior odds, which tells you what you believe about the relative plausibility of the null hypothesis and the alternative hypothesis after seeing the data. On the right-hand side, we have the prior odds, which indicates what you thought before seeing the data. In the middle, we have the Bayes factor, which describes the amount of evidence provided by the data: P(h1|d)P(h0|d)=P(d|h1)P(d|h0)×P(h1)P(h0)↑↑↑Posterior oddsBayes factorPrior odds \\begin{array}{ccccc}\\displaystyle \\frac{P(h_1 | d)}{P(h_0 | d)} &amp;=&amp; \\displaystyle\\frac{P(d|h_1)}{P(d|h_0)} &amp;\\times&amp; \\displaystyle\\frac{P(h_1)}{P(h_0)} \\\\[6pt] \\\\[-2pt] \\uparrow &amp;&amp; \\uparrow &amp;&amp; \\uparrow \\\\[6pt] \\mbox{Posterior odds} &amp;&amp; \\mbox{Bayes factor} &amp;&amp; \\mbox{Prior odds} \\end{array} The Bayes factor (abbreviated as BF) has a special place in Bayesian hypothesis testing because it serves a similar role to the pp-value in orthodox hypothesis testing: it quantifies the strength of evidence provided by the data. As such, it is the Bayes factor that people tend to report when running a Bayesian hypothesis test. The reason for reporting Bayes factors rather than posterior odds is that different researchers will have different priors. Some people might have a strong bias to believe the null hypothesis is true; others might have a strong bias to believe it is false. Because of this, the polite thing for an applied researcher to do is to report the Bayes factor. That way, anyone reading the paper can multiply the Bayes factor by their own personal prior odds, and they can work out for themselves what the posterior odds would be. In any case, by convention, we pretend that we give equal consideration to both the null hypothesis and the alternative, in which case the prior odds equal 1, and the posterior odds become the same as the Bayes factor. 16.2 Interpreting Bayes factors One of the nice things about the Bayes factor is that the numbers are inherently meaningful. An experiment with a Bayes factor of 4 corresponds to betting odds of 4:1 in favour of the alternative. However, some have attempted to quantify the standards of evidence that would be considered meaningful in a scientific context. The two most widely used are Jeffreys (1961) and Kass &amp; Raftery (1995). Of the two, Kass &amp; Raftery (1995) is somewhat more conservative. Table 16.1: Interpretation of Bayes factors by Kass &amp; Raftery (1995) Bayes factor Interpretation 1 - 3 Negligible evidence 3 - 20 Positive evidence 20 - 150 Strong evidence &gt;&gt; 150 Very strong evidence Jeffreys (1961) had the following guideline: Table 16.2: Interpretation of Bayes factors by Jeffreys (1961) Bayes factor BF10BF_10 Interpretation &gt;&gt; 100 Extreme evidence for h1h_1 30 - 100 Very strong evidence for h1h_1 10 - 30 Strong evidence for h1h_1 3 - 10 Moderate evidence for h1h_1 1 - 3 Anecdotal evidence for h1h_1 1 No evidence for h1h_1 1/3 - 1 Anecdotal evidence for h0h_0 1/10 - 1/3 Moderate evidence for h0h_0 1/30 - 1/10 Strong evidence for h0h_0 1/100 - 1/30 Very strong evidence for h0h_0 &lt;&lt; 1/100 Extreme evidence for h0h_0 There are no hard and fast rules here: what counts as strong or weak evidence depends entirely on how conservative you are and upon the standards that your community insists upon before it is willing to label a finding as “true”. In any case, note that all the numbers listed above make sense if the Bayes factor is greater than 1 (i.e. the evidence favours the alternative hypothesis). However, one important practical advantage of the Bayesian approach relative to the frequentist approach is that it also allows for quantifying evidence for the null. When that happens, the Bayes factor will be less than 1. You can choose to report a Bayes factor of less than 1, but it might be confusing for some. For example, suppose that the likelihood of the data under the null hypothesis P(d|h0)P(d|h_0) is equal to 0.2, and the corresponding likelihood P(d|h0)P(d|h_0) under the alternative hypothesis is 0.1. Using the equations given above, the Bayes factor here would be: BF=P(d|h1)P(d|h0)=0.10.2=0.5 \\mbox{BF} = \\frac{P(d|h_1)}{P(d|h_0)} = \\frac{0.1}{0.2} = 0.5 This result tells that the evidence in favour of the alternative is 0.5 to 1. For some, it makes a lot more sense to turn the equation “upside down” and report the amount of evidence in favour of the null. In other words, what we calculate is this: BF′=P(d|h0)P(d|h1)=0.20.1=2 \\mbox{BF}^\\prime = \\frac{P(d|h_0)}{P(d|h_1)} = \\frac{0.2}{0.1} = 2 We would report a Bayes factor of 2:1 in favour of the null. Much easier to understand, and you can interpret this using the table above. A few words on notation: the Bayes factor is often written as BF10BF_{10}, where the subscript indicates that we are giving evidence for h1h_1 over h0h_0. When noted as BF01BF_{01}, however, it is the other way around. Always be mindful which statistic you are reporting, and make sure you are consistent in your notation. No need to worry too much though, because BF10=1BF01 \\mbox{BF}_{10} = \\frac{1}{\\mbox{BF}_{01}} 16.3 Bayesian statistics in CogStat Bayesian hypothesis testing is a new feature since CogStat 2.3. You might have already noticed the results of Bayesian hypothesis tests in the output of CogStat in some screenshots. Let us revisit some of our examples from earlier chapters. 16.3.1 One-sample tt-test You might recall Dr Zeppo’s psychology students and their grades from Chapter 11.2. The file was called zeppo.csv. Let us load it again to CogStat, and let’s use the function Explore variable, and let us use our last null hypothesis of 67.567.5 as the population standard deviation (fill in 67.5 in the dialog box’s Central tendency test value). The results were: Hypothesis tests Testing if mean deviates from the value 67.5. Interval variable. &gt;&gt; Choosing one-sample t-test or Wilcoxon signed-rank test depending on the assumption. Checking for normality. Shapiro-Wilk normality test in variable x: W = 0.96, p = .586 Normality is not violated. &gt;&gt; Running one-sample t-test. Sensitivity power analysis. Minimal effect size to reach 95% power with the present sample size for the present hypothesis test. Minimal effect size in d: 0.85. One sample t-test against 67.5: t(19) = 2.25, p = .036 Result of the Bayesian one sample t-test: BF10 = 1.80, BF01 = 0.56 While the one-sample tt-test statistic was significant, the Bayes factor (BF10BF_10) was 1.80:1 in favour of the alternative, which is not very strong evidence by any of the guidances. So we should not be able to reject the null hypothesis. So what we would write up is: With a mean grade of 72.3, the psychology students scored slightly higher than the average grade of 67.5 but there is no statistical evidence for a difference (BF10=1.80BF_{10} = 1.80). 16.3.2 Independent samples tt-test Let’s load the file harpo.csv, where we see the grades for Dr Harpo’s lectures with the two tutors for the class (Anastasia and Bernadette). We’ll use the Compare groups functions with grades in the Dependent variable(s) box and tutor in the Group(s) box. The results were: And again, with a bayesian approach, there is not much evidence of significant difference. The mean grade in Anastasia’s class was 74.5 (SD = 8.7), whereas the mean in Bernadette’s class was 69.1 (SD = 5.6). A Student’s independent samples tt-test showed that this 5.5 difference was significant (t(31)=2.12t(31) = 2.12, p&lt;.05p&lt;.05, CI95=[0.2,10.8]CI_{95} = [0.2, 10.8]), suggesting that a genuine difference in learning outcomes has occurred. However, the Bayes factor (BF10=1.75BF_{10} = 1.75) is not strong enough to reject the null hypothesis, so we cannot conclude that the difference is real. 16.3.3 ANOVA Let’s jump back to our clinical trial from Chapter 12: clinicaltrial.csv. Let’s put therapy in the Dependent variable(s) box and mood_gain in the Group(s) box in the Compare groups function. The results were given: Result of the Bayesian independent two-samples t-test: BF10 = 1.75, BF01 = 0.57 You’ll notice that when running the same exercise with drug instead of therapy, there is no Bayes factor in the results. Bayesian statistics is not yet implemented for ANOVA (more than two groups or more than one grouping variables). 16.3.4 Linear regression Let’s use our parenthood.csv file, and let’s use the Explore relation of variable pair function with parentgrump and parentsleep. The results are staggering: Pearson's correlation: r(98) = -0.90, p &lt .001 Bayes Factor for Pearson correlation: BF10 = 25912605631674947492297885431627776.00, BF01 = 0.00 As you see, the Pearson’s correlation is −0.90-0.90 with a p&lt;.001p &lt; .001. An rr value close to 1 is already very strong (particularly with a significant pp-value), but that’s a frequentist statistic. The Bayes factor of BF10=2.59×1028BF_{10} = 2.59 \\times 10^{28}:1 in favour of the alternative is a very strong evidence. And the inverted notation BF01=0.00BF_{01} = 0.00 also speaks volumes. So we have no doubt that there is a strong correlation between the two variables. References Jeffreys, H. (1961). The theory of probability (3rd ed.). Oxford. Kass, R. E., &amp; Raftery, A. E. (1995). Bayes factors. Journal of the American Statistical Association, 90, 773–795. "],["whybayes.html", "Chapter 17 Why be a Bayesian? 17.1 Evidentiary standards you can believe 17.2 The pp-value is a lie. 17.3 Is it really this bad?", " Chapter 17 Why be a Bayesian? One of the most significant advantages of the Bayesian approach is that it answers the right questions. Within the Bayesian framework, it is sensible and allowable to refer to “the probability that a hypothesis is true”. You can even try to calculate this probability. Ultimately, isn’t that what you want your statistical tests to tell you? To an actual human being, this would seem to be the whole point of doing statistics: determining what is true and what isn’t. Any time you aren’t exactly sure about the truth, you should use the language of probability theory to say things like “there is an 80% chance that Theory A is true, but a 20% chance that Theory B is true instead”. This seems so obvious to a human, yet it is explicitly forbidden within the orthodox framework. To a frequentist, such statements are nonsense because “the theory is true” is not a repeatable event. A theory is true, or it is not, and no probabilistic statements are allowed, no matter how much you might want to make them. There’s a reason why you must not interpret the pp-value as the probability that the null hypothesis is true. There’s a reason why almost every textbook on statistics is forced to repeat that warning. It’s because people desperately want that to be the correct interpretation. However, it’s such an appealing idea that even trained statisticians fall prey to the mistake of trying to interpret a pp-value this way. For example, here is a quote from an official Newspoll report in 2013 explaining how to interpret their (frequentist) data analysis:85 Throughout the report, where relevant, statistically significant changes have been noted. All significance tests have been based on the 95 percent level of confidence. This means that if a change is noted as being statistically significant, there is a 95 percent probability that a real change has occurred, and is not simply due to chance variation. (emphasis added) Nope! That’s not what p&lt;.05p&lt;.05 means. That’s not what 95% confidence means to a frequentist statistician. The bolded section is just plain wrong. Orthodox methods cannot tell you that “there is a 95% chance that a real change has occurred” because this is not the kind of event to which frequentist probabilities may be assigned. To an ideological frequentist, this sentence should be meaningless. Even if you’re a more pragmatic frequentist, it’s still the wrong definition of a pp-value. It is simply not an allowed or correct thing to say if you want to rely on orthodox statistical tools. On the other hand, let’s suppose you are a Bayesian. Although the bolded passage is the wrong definition of a pp-value, it’s pretty much exactly what a Bayesian means when they say that the posterior probability of the alternative hypothesis is greater than 95%. And here’s the thing. If the Bayesian posterior is the thing you want to report, why are you even trying to use orthodox methods? If you wish to make Bayesian claims, all you have to do is be a Bayesian and use Bayesian tools. Once you’ve made the jump, you no longer have to wrap your head around counterintuitive definitions of pp-values. You don’t have to bother remembering why you can’t say that you’re 95% confident that the true mean lies within some interval. You have to be honest about what you believed before running the study and then report what you learned from doing it. Sounds nice, doesn’t it? To me, this is the big promise of the Bayesian approach: you do the analysis you want to do and express what you believe the data are telling you. 17.1 Evidentiary standards you can believe If pp is below .02 it is strongly indicated that the null hypothesis fails to account for the whole of the facts. We shall not often be astray if we draw a conventional line at .05 and consider that smaller values of pp indicate a real discrepancy. – Sir Ronald Fisher (1925) Consider the quote above by Sir Ronald Fisher, one of the founders of what has become the orthodox approach to statistics. If anyone has ever been entitled to express an opinion about the intended function of pp-values, it’s Fisher. In this passage, taken from his classic guide Statistical Methods for Research Workers, he’s pretty clear about what it means to reject a null hypothesis at p&lt;.05p&lt;.05. In his opinion, if we take p&lt;.05p&lt;.05 to mean there is “a real effect”, then “we shall not often be astray”. This view is hardly unusual: most practitioners express views very similar to Fisher’s. In essence, the p&lt;.05p&lt;.05 convention is assumed to represent a fairly stringent evidentiary standard. Well, how true is that? One way to approach this question is to try to convert pp-values to Bayes factors and see how the two compare. It’s not an easy thing to do because a pp-value is a fundamentally different kind of calculation to a Bayes factor, and they don’t measure the same thing. However, there have been some attempts to work out the relationship between the two, and it’s somewhat surprising. For example, Johnson (2013) presents a pretty compelling case that (for tt-tests at least) the p&lt;.05p&lt;.05 threshold corresponds roughly to a Bayes factor of somewhere between 3:1 and 5:1 in favour of the alternative. If that’s right, then Fisher’s claim is a bit of a stretch. Let’s suppose that the null hypothesis is true about half the time (i.e., the prior probability of H0H_0 is 0.5), and we use those numbers to work out the posterior probability of the null hypothesis, given that it has been rejected at p&lt;.05p&lt;.05. Using the data from Johnson (2013), we see that if you reject the null at p&lt;.05p&lt;.05, you’ll be correct about 80% of the time. An evidentiary standard that ensures you’ll be wrong on 20% of your decisions isn’t good enough. The fact remains that, quite contrary to Fisher’s claim, if you reject at p&lt;.05p&lt;.05 you shall quite often go astray. It’s not a very stringent evidentiary threshold at all. 17.2 The pp-value is a lie. Okay, at this point, you might be thinking that the real problem is not with orthodox statistics, just the p&lt;.05p&lt;.05 standard. In one sense, that’s true. The recommendation that Johnson (2013) gives is not that “everyone must be a Bayesian now”. Instead, the suggestion is that it would be wiser to shift the conventional standard to something like a p&lt;.01p&lt;.01 level. That’s not an unreasonable view to take. Nonetheless, there’s a fairly big problem built into the way most (but not all) orthodox hypothesis tests are constructed. They are grossly naive about how humans actually do research, and because of this, most pp-values are wrong. That sounds like an absurd claim, right? Well, consider the following scenario. You’ve come up with a really exciting research hypothesis, and you design a study to test it. You’re very diligent, so you run a power analysis to work out what your sample size should be, and you run the study. You run your hypothesis test, and out pops a pp-value of 0.072. Really bloody annoying, right? What should you do? Here are some possibilities: You conclude that there is no effect and try to publish it as a null result You guess that there might be an effect and try to publish it as a “borderline significant” result You give up and try a new study You collect some more data to see if the pp value goes up or (preferably!) drops below the “magic” criterion of p&lt;.05p&lt;.05 Which would you choose? Before reading any further, take some time to think about it. Be honest with yourself. But don’t stress about it too much because it actually doesn’t matter what you choose. Danielle has some insights to share based on her own experiences as an author, reviewer and editor. Here’s what might easily happen in each case: Let’s start with option 1. If you try to publish it as a null result, the paper will struggle to be published. Some reviewers will think that p=.072p=.072 is not a null result. They’ll argue it’s borderline significant. Other reviewers will agree it’s a null result but will claim that even though some null results are publishable, yours isn’t. One or two reviewers might even be on your side, but you’ll be fighting an uphill battle to get it through. Okay, let’s think about option number 2. Suppose you try to publish it as a borderline significant result. Some reviewers will claim that it’s a null result and should not be published. Others will claim that the evidence is ambiguous and that you should collect more data until you get a clear significant result. Again, the publication process does not favour you. Given the difficulties in publishing an “ambiguous” result like p=.072p=.072, option number 3 might seem tempting: give up and do something else. But that’s a recipe for career suicide. If you give up and try a new project every time you face ambiguity, your work will never be published. And if you’re in academia without a publication record, you can lose your job. So that option is out. It looks like you’re stuck with option 4. You don’t have conclusive results, so you decide to collect some more data and re-run the analysis. It seems sensible, but unfortunately for you, if you do this, all of your pp-values are now incorrect. All of them. Not just the pp-values that you calculated for this study. All of them. All the pp-values you calculated in the past and all the pp-values you will calculate in the future. Fortunately, no one will notice. You’ll get published, and you’ll have lied. What does that mean? It sounded like a perfectly reasonable strategy, didn’t it? You collected some data, but the results weren’t conclusive, so now what you want to do is collect more data until the results are conclusive. What’s wrong with that? In real life, this is exactly what every researcher does. Unfortunately, the theory of null hypothesis testing, as described in Chapter 9, forbids you from doing this.86 The reason is that the theory assumes that the experiment is finished and all the data are in. And because it assumes the experiment is over, it only considers two possible decisions. If you’re using the conventional p&lt;.05p&lt;.05 threshold, those decisions are: pp-value Decision p&lt;.05p &lt; .05 Reject H0H_0 p&gt;.05p &gt; .05 Retain H0H_0 What you’re doing is adding a third possible action to the decision-making problem. Specifically, what you’re doing is using the pp-value itself as a reason to justify continuing the experiment. And as a consequence, you’ve transformed the decision-making procedure into one that looks more like this: pp-value Decision p&lt;.05p &lt; .05 Stop the experiment and reject the null 0.10&gt;p&gt;.050.10 &gt; p &gt; .05 Continue the experiment and retain the null p&gt;.10p &gt; .10 Stop the experiment and retain the null The “basic” theory of null hypothesis testing isn’t built to handle this sort of thing, not in the form described in Chapter 9. If you’re the kind of person who would choose to “collect more data” in real life, it implies that you are not making decisions in accordance with the rules of null hypothesis testing. Even if you arrive at the same decision as the hypothesis test, you aren’t following the decision process it implies, and it’s this failure to follow the process causing the problem.87 Your pp-values are a lie. Worse yet, they’re a lie in a dangerous way because they’re all too small. To give you a sense of just how bad it can be, consider the following (worst case) scenario. Imagine you’re a really super-enthusiastic researcher on a tight budget who didn’t pay any attention to the warnings above. You design a study comparing two groups. You desperately want to see a significant result at the p&lt;.05p&lt;.05 level, but you really don’t want to collect any more data than you have to (because it’s expensive). In order to cut costs, you start collecting data, but every time a new observation arrives, you run a tt-test on your data. If the tt-tests says p&lt;.05p&lt;.05 then you stop the experiment and report a significant result. If not, you keep collecting data. You keep doing this until you reach your pre-defined spending limit for this experiment. Let’s say that limit kicks in at N=1000N=1000 observations. As it turns out, the truth of the matter is that there is no real effect to be found: the null hypothesis is true. So, what’s the chance that you’ll make it to the end of the experiment and (correctly) conclude that there is no effect? In an ideal world, the answer here should be 95%. After all, the whole point of the p&lt;.05p&lt;.05 criterion is to control the Type I error rate at 5%, so what we’d hope is that there’s only a 5% chance of falsely rejecting the null hypothesis in this situation. However, there’s no guarantee that will be true. You’re breaking the rules: you’re running tests repeatedly, “peeking” at your data to see if you’ve gotten a significant result, and all bets are off. Figure 17.1: How badly can things go wrong if you re-run your tests every time new data arrive? If you are a frequentist, the answer is “very wrong”. So, how bad is it? The answer is shown as the solid black line in Figure 17.1, and it’s astoundingly bad. If you peek at your data after every single observation, there is a 49% chance that you will make a Type I error. That’s, um, quite a bit bigger than the 5% that it’s supposed to be. By way of comparison, imagine that you had used the following strategy. Start collecting data. Every single time an observation arrives, run a Bayesian tt-test and look at the Bayes factor. Assume that Johnson (2013) is right, and let’s treat a Bayes factor of 3:1 as roughly equivalent to a pp-value of .05.88 This time around, our trigger-happy researcher uses the following procedure: if the Bayes factor is 3:1 or more in favour of the null, stop the experiment and retain the null. If it is 3:1 or more in favour of the alternative, stop the experiment and reject the null. Otherwise, continue testing. Now, just like last time, let’s assume that the null hypothesis is true. What happens? The simulation results for this scenario are shown as the dashed line in Figure 17.1. It turns out that the Type I error rate is much much lower than the 49% rate that we were getting by using the orthodox tt-test. In some ways, this is remarkable. The entire point of orthodox null hypothesis testing is to control the Type I error rate. Bayesian methods aren’t actually designed to do this at all. Yet, the Bayesian approach is much more effective when faced with a “trigger-happy” researcher who keeps running hypothesis tests as the data come in. Even the 3:1 standard, which most Bayesians would consider unacceptably lax, is much safer than the p&lt;.05p&lt;.05 rule. 17.3 Is it really this bad? The example in the previous section is a pretty extreme situation. In real life, people don’t run hypothesis tests every time a new observation arrives. So it’s not fair to say that the p&lt;.05p&lt;.05 threshold “really” corresponds to a 49% Type I error rate (i.e., p=.49p=.49). But the fact remains that if you want your pp-values to be honest, then you either have to switch to a completely different way of doing hypothesis tests, or you must enforce a strict rule: no peeking. You are not allowed to use the data to decide when to terminate the experiment. You are not allowed to look at a “borderline” pp-value and decide to collect more data. You aren’t even allowed to change your data analysis strategy after looking at the data. You are strictly required to follow these rules. Otherwise, the pp-values you calculate will be nonsense. And yes, these rules are surprisingly strict. Suppose you started running your study with the intention of collecting N=80N=80 people. When the study starts out, you follow the rules, refusing to look at the data or run any tests. But when you reach N=50N=50, your willpower gives in, and you take a peek. Guess what? You’ve got a significant result! Now, sure, you know you said that you’d keep running the study out to a sample size of N=80N=80, but it seems pointless now, right? The result is significant with a sample size of N=50N=50, so wouldn’t it be wasteful and inefficient to keep collecting data? Aren’t you tempted to stop? Just a little? Well, keep in mind that if you do, your Type I error rate at p&lt;.05p&lt;.05 just ballooned out to 8%. When you report p&lt;.05p&lt;.05 in your paper, what you’re really saying is p&lt;.08p&lt;.08. That’s how bad the consequences of “just one peek” can be. Now consider this: the scientific literature is filled with tt-tests, ANOVAs, regressions and chi-square tests. The tests in this book and the ones baked into CogStat aren’t picked arbitrarily. The reason why these four tools appear in most introductory statistics texts is that these are the bread and butter tools of science. None of these tools includes a correction to deal with “data peeking”: they all assume that you’re not doing it. But how realistic is that assumption? In real life, how many people do you think have “peeked” at their data before the experiment was finished and adapted their subsequent behaviour after seeing what the data looked like? Except when an external constraint fixes the sampling procedure, the answer probably is: “most people have done it”. If that has happened, you can infer that the reported pp-values are wrong. Worse yet, because we don’t know what decision process they actually followed, we have no way to know what the pp-values should have been. You can’t compute a pp-value when you don’t know the decision-making procedure that the researcher used. And so the reported pp-value remains a lie. Given all of the above, what is the take-home message? It’s not that Bayesian methods are foolproof. If a researcher is determined to cheat, they can always do so. Bayes’ rule cannot stop people from lying, nor can it stop them from rigging an experiment. The reason why we run statistical tests is to protect us from ourselves. And the reason why “data peeking” is such a concern is that it’s so tempting, even for honest researchers. A theory for statistical inference has to acknowledge this. Yes, you might try to defend pp-values by saying that it’s the researcher’s fault for not using them correctly. A theory of statistical inference that is so utterly naive about humans that it doesn’t even consider the possibility that the researcher might look at their data isn’t a theory worth having. The point here is: Good laws have their origins in bad morals. – Ambrosius Macrobius89 Good rules for statistical testing have to acknowledge human frailty. None of us is without sin. None of us is beyond temptation. A good system for statistical inference should still work even when it is used by actual humans. Orthodox null hypothesis testing does not. Let us be fair: by adopting a sequential analysis perspective, you can avoid these errors within the orthodox framework as well. You can explicitly design studies with interim analyses in mind. However, that is not the current practice amongst psychology researchers. So until then, the default Bayes factor methods are much more robust in the face of data analysis practices as they exist in the real world. References Fisher, R. A. (1925). Statistical methods for research workers. Oliver; Boyd. Johnson, V. E. (2013). Revised standards for statistical evidence. Proceedings of the National Academy of Sciences, 48, 19313–19317. http://about.abc.net.au/reports-publications/appreciation-survey-summary-report-2013/↩︎ In the interests of being completely honest, not all orthodox statistical tests that rely on this silly assumption. There are several sequential analysis tools that are sometimes used in clinical trials and the like. These methods are built on the premise that data are analysed as they arrive, and these tests aren’t horribly broken. However, sequential analysis methods are constructed in a very different fashion from the “standard” version of null hypothesis testing. They don’t make it into any introductory textbooks, and they’re not very widely used in psychological literature. The concern raised here is valid for every single orthodox test presented so far.↩︎ A related problem: http://xkcd.com/1478/↩︎ Some readers might wonder why 3:1 rather than 5:1, given that Johnson (2013) suggests that p=.05p=.05 lies somewhere in that range. Let’s be charitable to the pp-value. Should we choose a 5:1 Bayes factor instead, the results would look even better for the Bayesian approach.↩︎ http://www.quotationspage.com/quotes/Ambrosius_Macrobius/↩︎ "],["summaryguide.html", "Chapter 18 Summary guide Descriptive statistics Analysing differences with hyptothesis testing Analysing relationship with hyptothesis testing", " Chapter 18 Summary guide This is a non-comprehensive summary guide about the tools used. Descriptive statistics Meaning Mean Average – the “centre of gravity” of the data Standard deviation How clustered is the data around the mean (smaller figure means more clustered, larger figure closer to interquartile range means more spread out) Skewness The assymetry of the data compared to a normal distribution (bell curve) Kurtosis Pointiness of the data. Smaller figure means more pointy, larger figure means less pointy Range The spread of the data set between the maximum and minimum values Maximum The highest value in the data set Upper quartile 25% of the data points reside at and above this value Median This is the value of the data point in the middle (or the average of the two middle points in case of even number of data points). 50-50% of data points reside at above and below this value Lower quartile 25% of the data points reside at and below this value Minimum The lowest value in the data set Analysing differences with hyptothesis testing Test Description Example from the chapter CATEGORICAL DATA χ2\\chi^2 goodness‑of‑fit test Tests whether the observed data fits a theoretical distribution Probability of card suits being random χ2\\chi^2 test for independence Tests whether two distributions are the same Probability that a member of species jj gives response ii to aliens Fisher’s exact test Tests whether two distributions are the same (small sample sizes and contingency tables Witches’ happiness being burned in Salem McNemar test of marginal homogeneity 2 by 2 contingency table with nominal data Whether the frequencies of suit choices are different the second time than the first time NON-CATEGORICAL DATA One group in one situation One-sample z‑test Tests whether the mean is equal to a given hypothetical value (you know the population standard deviation and your sample size is large) The mean of grades in Dr Zeppo’s class is above 67.5 One-sample t-test or Student’s t-test Tests whether the mean is equal to a given hypothetical value (you only have an estimated standard deviation, you cannot speak for the population) The mean of grades in Dr Zeppo’s class is above 67.5 Two groups in one situation Independent samples t-test (Student’s) Comparing two groups: Tests whether the means of two independent samples are equal (assumes normal distribution) The mean of grades of students tutored by Anastasia and Bernadette in Dr Harpo’s class Independent samples t-test (Welch) Comparing two groups: Tests whether the means of two independent samples are equal (assumes unequal variances) The mean of grades of students tutored by Anastasia and Bernadette in Dr Harpo’s class (with an alternative data set that violates normality assumption) Two-sample Wilcoxon test (Mann-Whitney test) Tests whether the means of two independent samples are equal (assumes non-normal distribution) AFL games attendance if the game is finals or not One group in two situations Paired samples t-test Tests whether the means of two samples are equal (assumes normal distribution) Changes to the mean of grades between the first test and the second test in Dr Chico’s class Wilcoxon signed-rank test (paired) Tests whether the means of two paired samples are equal (assumes non-normal distribution) Whether a biology class has any effect on the happiness of students Three or more groups One-way ANOVA Tests whether the means of three or more independent samples are equal (assumes normal distribution) Effects of 3 drugs on mood in our clinical trial Kruskal-Wallis rank sum test Tests whether the means of three or more independent samples are equal (assumes non-normal distribution) Effects of 3 drugs on mood in our clinical trial (adjusted data set) Factorial ANOVA Tests whether the means of three or more independent samples are equal but with more than one grouping variable Effects of 3 drugs and 2 therapy methods on mood in our clinical trial Analysing relationship with hyptothesis testing Test Description Example from the chapter Pearson’s correlation coefficient Tests whether two variables are correlated (continuous data) Correlation between the number of hours of slept and mood Spearman’s rank-order correlation Tests whether two variables are correlated (ordinal data) Correlation between effort and grade Linear regression Tests whether a linear relationship exists between two variables (continuous data) Correlation between the number of hours of sleep (parent, baby) and parent grumpiness "],["epilogue.html", "Epilogue The undiscovered statistics Statistical models missing from the book Last words", " Epilogue An epilogue is what you write when a book is finished, and this book really isn’t finished. The content will change along with feedback from students and other readers, and it must be revised anyway once more and more features are added to CogStat. This book is primarily online for students to use. The undiscovered statistics One thing that students often fail to realise is that their introductory statistics classes are just that: an introduction. If you want to go out into the wider world and do real data analysis, you have to learn a whole lot of new tools that extend the content of your undergraduate lectures in all sorts of different ways. Don’t assume that something can’t be done just because it wasn’t covered in undergrad. Don’t assume that something is the right thing to do just because it it was covered in an undergrad class. To stop you from falling victim to that trap, it’s useful to give an overview of some of the other ideas out there. Omissions within the topics covered Even within the topics covered in the book, there are a lot of omissions that must appear in future versions of the book. Just sticking to things that are purely about statistics (rather than things associated with CogStat), the following is a representative but not an exhaustive list of topics that we must expand on in later versions: Contrasts Since contrasts are not featured in CogStat yet, it is a topic omitted from this book version; however, it is an integral part of ANOVA if you want to understand more of the mechanics. Other types of correlations We talked about two types of correlation: Pearson and Spearman. Both of these methods of assessing correlation are applicable to the case where you have two continuous variables and want to assess the relationship between them. What about the case where your variables are both nominal scale? Or when one is nominal scale, and the other is continuous? There are actually methods for computing correlations in such cases (e.g., polychoric correlation). More detail on effect sizes In general, the treatment of effect sizes throughout the book is a little more cursory than it should be. However, for almost all tests and models, there are multiple ways of thinking about effect size, and we might go into more detail in the future. Dealing with violated assumptions In a number of places in the book, we’ve talked about some things you can do (or what CogStat automatically does) when you find that the assumptions of your test (or model) are violated. It would have been nice to talk in more detail about how you can transform variables to fix problems. Interaction terms for regression In Chapter 13, we talked about the fact that you can have interaction terms in an ANOVA, and we hinted that ANOVA could be interpreted as a kind of linear regression model. Yet, when talking about regression in Chapter 14, we made no mention of interactions at all. However, there’s nothing stopping you from including interaction terms in a regression model. It’s just a little more complicated to figure out what an “interaction” actually means when you’re talking about the interaction between two continuous predictors, and it can be done in more than one way. Multiple comparison methods Even within the context of talking about post hoc tests and multiple comparisons, it would have been lovely to talk about the methods in more detail, and about other methods that exist. Statistical models missing from the book Statistics is a huge field. The core tools in this book (chi-square tests, tt-tests, ANOVA and regression) are basic tools that are widely used in everyday data analysis, and they form the core of most introductory stats books. However, there are plenty of other tools out there. To give you a sense of just how much more there is, here is a much shorter list. Analysis of covariance In Chapter 13. “Analysis of covariance” (ANCOVA) refers to the situation where some of your predictors are continuous (like in a regression model), and others are categorical (like in an ANOVA). Non-linear regression When discussing regression in Chapter 14, we saw that regressions assume that the relationship between predictors and outcomes is linear. On the other hand, when we talked about the simpler correlation problem, we saw that tools (e.g., Spearman correlations) could assess non-linear relationships between variables. Some non-linear regression models assume that the relationship between predictors and outcomes is monotonic (e.g. isotonic regression), while others assume that it is smooth but not necessarily monotonic (e.g. Lowess regression), while others assume that the relationship is of a known form that happens to be non-linear (e.g. polynomial regression). Logistic regression Yet another variation in regression occurs when the outcome variable is binary valued, but the predictors are continuous. For instance, suppose you’re investigating social media, and you want to know if it’s possible to predict whether or not someone is on Twitter as a function of their income, their age, and a range of other variables. This is basically a regression model, but you can’t use regular linear regression because the outcome variable is binary (you’re either on Twitter or you’re not): because the outcome variable is binary, there’s no way that the residuals could possibly be normally distributed. There are a number of tools that statisticians can apply to this situation, the most prominent of which is logistic regression. The General Linear Model (GLM) The GLM is actually a family of models that include logistic regression, linear regression, (some) non-linear regression, ANOVA and many others. The basic idea in the GLM is essentially the same idea that underpins linear models, but it allows for the idea that your data might not be normally distributed and allows for non-linear relationships between predictors and outcomes. There are a lot of very handy analyses that you can run that fall within the GLM, so it’s a handy thing to know about. Survival analysis In Chapter 2, we talked about “differential attrition”, the tendency for people to leave the study in a non-random fashion. Suppose you’re interested in determining how long people play different computer games in a single session. Do people play RTS (real-time strategy) games for lengthier stretches than FPS (first-person shooter) games? You might design your study like this. People come into the lab, and they can play for as long or as little as they like. Once they’re finished, you record the time they spent playing. However, due to ethical restrictions, let’s suppose that you cannot allow them to keep playing longer than two hours. A lot of people will stop playing before the two-hour limit, so you know exactly how long they played. But some people will run into the two-hour limit, and so you don’t know how long they would have kept playing if you’d been able to continue the study. As a consequence, your data are systematically censored: you’re missing all of the very long times. How do you analyse this data sensibly? This is the problem that survival analysis solves. It is specifically designed to handle this situation, where you’re systematically missing one “side” of the data because the study ended. It’s very widely used in health research, and in that context, it is often literally used to analyse survival. For instance, you may be tracking people with a particular type of cancer, some who have received treatment A and others who have received treatment B, but you only have funding to track them for five years. At the end of the study period, some people are alive, and others are not. In this context, survival analysis helps determine which treatment is more effective and tells you about the risk of death that people face over time. Repeated measures ANOVA The basic idea behind RM-ANOVA is to consider the fact that participants can have different overall performance levels. In other words, a repeated measures design means that we can attribute some of the variations in our measurement to individual differences, which allows us to draw stronger conclusions. Reliability analysis Back in Chapter 2, we talked about reliability as one of the desirable characteristics of measurement. For example, when designing a survey to measure some aspect of someone’s personality (e.g., extraversion), one generally attempts to include several different questions that all ask the same basic question in many different ways. When you do this, you tend to expect that all of these questions will tend to be correlated with one another, because they’re all measuring the same latent construct. There are a number of tools (e.g. Cronbach’s α\\alpha, or rather McDonald’s ω\\omega) that you can use to check whether this is actually true for your study. Factor analysis One big shortcoming with reliability measures like Cronbach’s α\\alpha is that they assume that your observed variables are all measuring a single latent construct. But that’s not true in general. If you look at most personality questionnaires, IQ tests, or almost anything where you’re taking lots of measurements, it’s probably the case that you’re actually measuring several things at once. For example, all the different tests used when measuring IQ do tend to correlate with one another, but the pattern of correlations that you see across tests suggests that there are multiple different “things” going on in the data. Factor analysis (and related tools like principal components analysis and independent components analysis) is a tool that you can use to help you figure out what these things are. Broadly speaking, what you do with these tools is take a big correlation matrix that describes all pairwise correlations between your variables and attempt to express this pattern of correlations using only a small number of latent variables. Factor analysis is an excellent way to see how your variables are related to one another – but it can be tricky to use well. A lot of people make the mistake of thinking that when factor analysis uncovers a latent variable (e.g. extraversion pops out as a latent variable when you factor analyse most personality questionnaires), it must actually correspond to a real “thing”. That’s not necessarily true. Even so, factor analysis is a very useful thing to know about, especially for psychologists. Of course, even this list if far from complete. Last words In short, the big payoff for learning statistics the way of this book is extensibility. There are many other things that it pushes you to learn besides the specific analyses the book covers. You want to make sure that you learn to use the same tools that real data analysts use so that you can learn to do what they do. And so yeah, okay, you’re a beginner right now (or you were when you started this book), but that doesn’t mean you should be given a dumbed-down story, a story where we omit the nightmare that is factorial ANOVA with unbalanced designs, or all the underlying formula and notation that we’ve probably bored some of you to the point of closing the browser. What you need is not to have the complexities of real-world data analysis hidden from you. What you need are the skills and tools that will let you handle those complexities when they inevitably ambush you in the real world. And what we hope is that this book, with all its future changes and expansions, can help you with that. "],["references.html", "References", " References Agresti, A. (1996). An introduction to categorical data analysis. Wiley. Agresti, A. (2002). Categorical data analysis (2nd ed.). Wiley. American Educational Research Association, American Psychological Association, &amp; National Council on Measurement in Education. (2014). Standards for Educational and Psychological Testing. American Educational Research Association. Anscombe, F. J. (1973). Graphs in statistical analysis. American Statistician, 27, 17–21. Bickel, P. J., Hammel, E. A., &amp; O’Connell, J. W. (1975). Sex bias in graduate admissions: Data from Berkeley. Science, 187, 398–404. Boncz, I. (2015). Research methodology basics [Kutatásmódszertani alapismeretek]. Pécsi Tudományegyetem. Box, J. F. (1987). Guinness, gosset, fisher, and small samples. Statistical Science, 2, 45–52. Brodey, B. B., First, M., Linthicum, J., Haman, K., Sasiela, J. W., &amp; Ayer, D. (2016). Validation of the NetSCID: An automated web-based adaptive version of the SCID. Comprehensive Psychiatry, 66, 67–70. https://doi.org/10.1016/j.comppsych.2015.10.005 Brown, M. B., &amp; Forsythe, A. B. (1974). Robust tests for equality of variances. Journal of the American Statistical Association, 69, 364–367. Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Lawrence Erlbaum. Cowan, N. (2015). George Miller’s magical number of immediate memory in retrospect: Observations on the faltering progression of science. Psychological Review, 122(3), 536–541. https://doi.org/10.1037/a0039035 Cramér, H. (1946). Mathematical methods of statistics. Princeton University Press. Edwards, M. C., Slagle, A., Rubright, J. D., &amp; Wirth, R. J. (2018). Fit for purpose and modern validity theory in clinical outcomes assessment. Quality of Life Research, 27(7), 1711–1720. https://doi.org/10.1007/s11136-017-1644-z Ellis, P. D. (2010). The essential guide to effect sizes: Statistical power, meta-analysis, and the interpretation of research results. Cambridge University Press. Evans, J. St. B. T., Barston, J. L., &amp; Pollard, P. (1983). On the conflict between logic and belief in syllogistic reasoning. Memory and Cognition, 11, 295–306. Fisher, R. A. (1922a). On the interpretation of χ2\\chi^2 from contingency tables, and the calculation of pp. Journal of the Royal Statistical Society, 84, 87–94. Fisher, R. A. (1922b). On the mathematical foundation of theoretical statistics. Philosophical Transactions of the Royal Society A, 222, 309–368. Fisher, R. A. (1925). Statistical methods for research workers. Oliver; Boyd. Fox, J., &amp; Weisberg, S. (2011). An R companion to applied regression (2nd ed.). Sage. Garcia-Romeu, A., Barrett, F. S., Carbonaro, T. M., Johnson, M. W., &amp; Griffiths, R. R. (2021). Optimal dosing for psilocybin pharmacotherapy: Considering weight-adjusted and fixed dosing approaches. Journal of Psychopharmacology, 35(4), 353–361. https://doi.org/10.1177/0269881121991822 Gelman, A., &amp; Stern, H. (2006). The difference between “significant” and “not significant” is not itself statistically significant. The American Statistician, 60, 328–331. Hays, W. L. (1994). Statistics (5th ed.). Harcourt Brace. Hogg, R. V., McKean, J. V., &amp; Craig, A. T. (2005). Introduction to mathematical statistics (6th ed.). Pearson. Howitt, D., &amp; Cramer, D. (2020). Understanding statistics in psychology with SPSS (Eighth edition). Pearson. Hsu, J. C. (1996). Multiple comparisons: Theory and methods. Chapman; Hall. Hubley, A. M. (2014). Divergent Validity. In A. C. Michalos (Ed.), Encyclopedia of Quality of Life and Well-Being Research (pp. 1675–1676). Springer Netherlands. https://doi.org/10.1007/978-94-007-0753-5_766 Jeffreys, H. (1961). The theory of probability (3rd ed.). Oxford. Johnson, V. E. (2013). Revised standards for statistical evidence. Proceedings of the National Academy of Sciences, 48, 19313–19317. Kass, R. E., &amp; Raftery, A. E. (1995). Bayes factors. Journal of the American Statistical Association, 90, 773–795. Keynes, J. M. (1923). A tract on monetary reform. Macmillan; Company. Krajcsi, A. (2021). Advancing best practices in data analysis with automatic and optimized output data analysis software [Preprint]. PsyArXiv. https://doi.org/10.31234/osf.io/hnmsq Kruskal, W. H., &amp; Wallis, W. A. (1952). Use of ranks in one-criterion variance analysis. Journal of the American Statistical Association, 47, 583–621. Larntz, K. (1978). Small-sample comparisons of exact levels for chi-squared goodness-of-fit statistics. Journal of the American Statistical Association, 73, 253–263. Lehmann, E. L. (2011). Fisher, Neyman, and the creation of classical statistics. Springer. Levene, H. (1960). Robust tests for equality of variances. In I. O. et al (Ed.), Contributions to probability and statistics: Essays in honor of harold hotelling (pp. 278–292). Stanford University Press. Lyon, J. D., &amp; Tsai, C.-L. (1996). A comparison of tests for heteroscedasticity. Journal of the Royal Statistical Society: Series D (The Statistician), 45(3), 337–349. Marks, D., &amp; Yardley, L. (Eds.). (2004). Research methods for clinical and health psychology. SAGE. McGrath, R. E., &amp; Meyer, G. J. (2006). When effect sizes disagree: The case of rr and dd. Psychological Methods, 11, 386–401. McNemar, Q. (1947). Note on the sampling error of the difference between correlated proportions or percentages. Psychometrika, 12, 153–157. Meehl, P. H. (1967). Theory testing in psychology and physics: A methodological paradox. Philosophy of Science, 34, 103–115. Merriam-Webster. (2022). Petrichor, cromulent, and other words the internet loves. https://www.merriam-webster.com/words-at-play/internets-favorite-words Michalos, A. C. (Ed.). (2014). Encyclopedia of quality of life and well-being research. Springer. Miller, G. A. (1956). The magical number seven, plus or minus two: Some limits on our capacity for processing information. Psychological Review, 63(2), 81–97. https://doi.org/10.1037/h0043158 Open Science Collaboration. (2015). Estimating the reproducibility of psychological science. Science, 349(6251), aac4716. https://doi.org/10.1126/science.aac4716 Pearson, K. (1900). On the criterion that a given system of deviations from the probable in the case of a correlated system of variables is such that it can be reasonably supposed to have arisen from random sampling. Philosophical Magazine, 50, 157–175. Sahai, H., &amp; Ageel, M. I. (2000). The analysis of variance: Fixed, random and mixed models. Birkhauser. Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test for normality (complete samples). Biometrika, 52, 591–611. Sokal, R. R., &amp; Rohlf, F. J. (1994). Biometry: The principles and practice of statistics in biological research (3rd ed.). Freeman. Stevens, S. S. (1946). On the theory of scales of measurement. Science, 103, 677–680. Stigler, S. M. (1986). The history of statistics. Harvard University Press. Student, A. (1908). The probable error of a mean. Biometrika, 6, 1–2. Taylor, S. E., &amp; Stanton, A. L. (2021). Health Psychology (Eleventh). McGraw-Hill. Welch, B. L. (1947). The generalization of “Student’s” problem when several different population variances are involved. Biometrika, 34, 28–35. Yates, F. (1934). Contingency tables involving small numbers and the χ2\\chi^2 test. Supplement to the Journal of the Royal Statistical Society, 1, 217–235. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
